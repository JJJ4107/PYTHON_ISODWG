import ezdxf
import os
import sys
import math
from ezdxf.math import Vec2

def extract_points(entity):
    if entity.dxftype() == 'LWPOLYLINE':
        return [Vec2(x, y) for x, y, *_ in entity.get_points()]
    elif entity.dxftype() == 'POLYLINE':
        try:
            return [Vec2(v.dxf.location.x, v.dxf.location.y) for v in entity]
        except:
            return []
    elif entity.dxftype() == 'LINE':
        try:
            # LINE ì—”í‹°í‹°ì˜ ê²½ìš°
            start_3d = entity.dxf.start
            end_3d = entity.dxf.end
            return [Vec2(start_3d.x, start_3d.y), Vec2(end_3d.x, end_3d.y)]
        except:
            try:
                # ëŒ€ì²´ ë°©ë²•
                start = entity.get_dxf_attrib('start')
                end = entity.get_dxf_attrib('end')
                return [Vec2(start[0], start[1]), Vec2(end[0], end[1])]
            except:
                return []
    return []

def distance(p1, p2):
    return math.hypot(p2.x - p1.x, p2.y - p1.y)

def get_entity_layer(entity):
    """ì—”í‹°í‹°ì˜ ë ˆì´ì–´ ì´ë¦„ì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°"""
    try:
        return entity.dxf.layer
    except AttributeError:
        try:
            return entity.get_dxf_attrib('layer', default='UNKNOWN')
        except:
            return 'UNKNOWN'

def get_entity_handle(entity):
    """ì—”í‹°í‹°ì˜ í•¸ë“¤ì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°"""
    try:
        return entity.dxf.handle
    except AttributeError:
        try:
            return entity.get_dxf_attrib('handle', default='UNKNOWN')
        except:
            return 'UNKNOWN'

def get_entity_color(entity):
    """ì—”í‹°í‹°ì˜ ìƒ‰ìƒì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°"""
    try:
        return entity.dxf.color
    except AttributeError:
        try:
            return entity.get_dxf_attrib('color', default=7)
        except:
            return 7

def set_entity_layer(entity, layer_name):
    """ì—”í‹°í‹°ì˜ ë ˆì´ì–´ë¥¼ ì•ˆì „í•˜ê²Œ ì„¤ì •í•˜ê¸°"""
    try:
        entity.dxf.layer = layer_name
    except AttributeError:
        try:
            entity.set_dxf_attrib('layer', layer_name)
        except:
            pass

def set_entity_color(entity, color):
    """ì—”í‹°í‹°ì˜ ìƒ‰ìƒì„ ì•ˆì „í•˜ê²Œ ì„¤ì •í•˜ê¸°"""
    try:
        entity.dxf.color = color
    except AttributeError:
        try:
            entity.set_dxf_attrib('color', color)
        except:
            pass

def get_angle(p1, p2):
    return math.degrees(math.atan2(p2.y - p1.y, p2.x - p1.x))

def normalize_angle(angle):
    """ê°ë„ë¥¼ -180 ~ 180 ë²”ìœ„ë¡œ ì •ê·œí™”"""
    while angle > 180:
        angle -= 360
    while angle < -180:
        angle += 360
    return angle

def angles_are_similar(angle1, angle2, tolerance=15):
    """ë‘ ê°ë„ê°€ ìœ ì‚¬í•œì§€ í™•ì¸ (tolerance: í—ˆìš© ì˜¤ì°¨)"""
    # ê°ë„ë¥¼ -180 ~ 180 ë²”ìœ„ë¡œ ì •ê·œí™”
    a1 = normalize_angle(angle1)
    a2 = normalize_angle(angle2)
    
    # ì§ì ‘ ì°¨ì´
    diff = abs(a1 - a2)
    
    # 180ë„ ë°˜ëŒ€ ë°©í–¥ë„ ë™ì¼í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
    diff_opposite = abs(diff - 180)
    
    # 360ë„ ê²½ê³„ ì²˜ë¦¬
    if diff > 180:
        diff = 360 - diff
    
    return diff <= tolerance or diff_opposite <= tolerance

def get_offset_by_angle(angle_deg, distance_mm):
    angle_rad = math.radians(angle_deg)
    return Vec2(math.cos(angle_rad), math.sin(angle_rad)) * distance_mm

def get_perpendicular_offset(angle_deg, distance_mm):
    angle_rad = math.radians(angle_deg + 90)
    return Vec2(math.cos(angle_rad), math.sin(angle_rad)) * distance_mm

def rotate_point(point, center, angle_deg):
    angle_rad = math.radians(angle_deg)
    dx, dy = point - center
    cos_a, sin_a = math.cos(angle_rad), math.sin(angle_rad)
    return Vec2(center.x + dx * cos_a - dy * sin_a,
                center.y + dx * sin_a + dy * cos_a)

def rotate_text(text, center, angle_deg):
    insert = text.dxf.insert
    pt = Vec2(insert[0], insert[1])
    new_pt = rotate_point(pt, center, angle_deg)
    text.dxf.insert = (new_pt.x, new_pt.y, 0)
    text.dxf.rotation += angle_deg

def move_text(text, offset):
    insert = text.dxf.insert
    pt = Vec2(insert[0], insert[1])
    new_pt = pt + offset
    text.dxf.insert = (new_pt.x, new_pt.y, 0)

def segments_cross(a1, a2, b1, b2):
    def ccw(A, B, C):
        return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x)
    return (ccw(a1, b1, b2) != ccw(a2, b1, b2)) and (ccw(a1, a2, b1) != ccw(a1, a2, b2))

def polyline_intersects_with_fall(pl_points, fall_points):
    """í´ë¦¬ë¼ì¸ì´ FALL í´ë¦¬ë¼ì¸ì˜ ì–´ë–¤ ì„ ë¶„ê³¼ë„ êµì°¨í•˜ëŠ”ì§€ í™•ì¸"""
    for i in range(len(fall_points)):
        j = (i + 1) % len(fall_points)
        fall_seg_start = fall_points[i]
        fall_seg_end = fall_points[j]
        
        for k in range(len(pl_points) - 1):
            pl_seg_start = pl_points[k]
            pl_seg_end = pl_points[k + 1]
            
            if segments_cross(fall_seg_start, fall_seg_end, pl_seg_start, pl_seg_end):
                return True
    return False

def g1_crosses_both_fall_segments(g1_pts, fall_pts):
    """G1ì´ FALLì˜ ì 1-2 ì„ ë¶„ê³¼ ì 3-4 ì„ ë¶„ì„ ëª¨ë‘ í†µê³¼í•˜ëŠ”ì§€ í™•ì¸"""
    if len(g1_pts) != 2 or len(fall_pts) != 4:
        return False
    
    # FALLì˜ ì 1-2 ì„ ë¶„ê³¼ êµì°¨ í™•ì¸
    crosses_12 = segments_cross(g1_pts[0], g1_pts[1], fall_pts[0], fall_pts[1])
    
    # FALLì˜ ì 3-4 ì„ ë¶„ê³¼ êµì°¨ í™•ì¸
    crosses_34 = segments_cross(g1_pts[0], g1_pts[1], fall_pts[2], fall_pts[3])
    
    return crosses_12 and crosses_34

def polylines_intersect(pl1_points, pl2_points):
    """ë‘ í´ë¦¬ë¼ì¸ì´ êµì°¨í•˜ëŠ”ì§€ í™•ì¸"""
    for i in range(len(pl1_points) - 1):
        for j in range(len(pl2_points) - 1):
            if segments_cross(pl1_points[i], pl1_points[i+1], 
                            pl2_points[j], pl2_points[j+1]):
                return True
    return False

def check_all_segments_under_21(pts):
    """ëª¨ë“  ì ê°„ ê±°ë¦¬ê°€ 2.1mm ì´í•˜ì¸ì§€ í™•ì¸"""
    for i in range(len(pts) - 1):
        if distance(pts[i], pts[i+1]) > 2.1:
            return False
    return True

def find_arrow_lines_near_points(msp, points, max_dist=0.2, max_length=1.0):
    """AD1ì˜ ì ì—ì„œ max_dist(0.2mm) ë‚´ì˜ max_length(1mm) ì´í•˜ ARROW ë ˆì´ì–´ line ì°¾ê¸°"""
    arrow_lines = []
    for line in msp.query('LINE'):
        if get_entity_layer(line).upper() != 'ARROW':
            continue
        
        start = Vec2(line.dxf.start.x, line.dxf.start.y)
        end = Vec2(line.dxf.end.x, line.dxf.end.y)
        
        # ë¼ì¸ ê¸¸ì´ í™•ì¸
        line_length = distance(start, end)
        if line_length > max_length:
            continue
        
        # ê° AD1 ì ì—ì„œ lineê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬ í™•ì¸
        for pt in points:
            dist_to_start = distance(pt, start)
            dist_to_end = distance(pt, end)
            min_dist_to_line = min(dist_to_start, dist_to_end)
            
            if min_dist_to_line <= max_dist:
                arrow_lines.append(line)
                break
    
    return arrow_lines

def find_ad1_near_g1_start(g1_pts, ad1_groups, max_dist=0.5):
    """G1ì˜ ì‹œì‘ì ì—ì„œ AD1 í´ë¦¬ë¼ì¸ì´ max_dist(0.5mm) ë‚´ì— ìˆëŠ” AD1 ì°¾ê¸°"""
    if not g1_pts:
        return []
    
    g1_start = g1_pts[0]  # G1ì˜ ì‹œì‘ì 
    found_ad1_groups = []
    
    for ad1_group in ad1_groups:
        ad1_pts = extract_points(ad1_group['polyline'])
        
        # AD1ì˜ ëª¨ë“  ì  ì¤‘ í•˜ë‚˜ë¼ë„ G1 ì‹œì‘ì ì—ì„œ 0.5mm ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
        for i, pt in enumerate(ad1_pts):
            dist = distance(g1_start, pt)
            if dist <= max_dist:
                found_ad1_groups.append(ad1_group)
                break  # í•˜ë‚˜ë¼ë„ ì°¾ìœ¼ë©´ ì¶”ê°€í•˜ê³  ë‹¤ìŒ AD1ë¡œ
    
    return found_ad1_groups

def is_text_upside_down(text_rotation):
    """í…ìŠ¤íŠ¸ê°€ ë’¤ì§‘í˜€ ìˆëŠ”ì§€ í™•ì¸ (90ë„ < íšŒì „ < 270ë„)"""
    # íšŒì „ ê°ë„ë¥¼ 0-360 ë²”ìœ„ë¡œ ì •ê·œí™”
    normalized_rotation = text_rotation % 360
    return 90 < normalized_rotation < 270

def get_text_bounds(text):
    """í…ìŠ¤íŠ¸ì˜ ëŒ€ëµì ì¸ ê²½ê³„ ìƒìë¥¼ ë°˜í™˜"""
    # ezdxfì˜ TEXT ì—”í‹°í‹° ì†ì„± ì ‘ê·¼ ë°©ì‹
    try:
        # ë°©ë²• 1: dxf ì†ì„± ì‚¬ìš©
        insert = text.dxf.insert
        text_str = text.dxf.text
        height = text.dxf.height
        rotation = text.dxf.rotation
    except AttributeError:
        try:
            # ë°©ë²• 2: get_dxf_attrib ë©”ì„œë“œ ì‚¬ìš©
            insert = text.get_dxf_attrib('insert', default=(0, 0, 0))
            text_str = text.get_dxf_attrib('text', default='')
            height = text.get_dxf_attrib('height', default=1.0)
            rotation = text.get_dxf_attrib('rotation', default=0.0)
        except:
            # ë°©ë²• 3: ì§ì ‘ ì†ì„± ì ‘ê·¼
            insert = getattr(text, 'insert', (0, 0, 0))
            text_str = getattr(text, 'text', '')
            height = getattr(text, 'height', 1.0)
            rotation = getattr(text, 'rotation', 0.0)
    
    pos = Vec2(insert[0], insert[1])
    
    # í…ìŠ¤íŠ¸ í¬ê¸° ì¶”ì • (í°íŠ¸ í¬ê¸°ì™€ í…ìŠ¤íŠ¸ ê¸¸ì´ ê¸°ë°˜)
    text_length = len(text_str) * height * 0.7
    text_height = height * 1.2
    
    # íšŒì „ ê³ ë ¤
    angle_rad = math.radians(rotation)
    cos_a, sin_a = math.cos(angle_rad), math.sin(angle_rad)
    
    # ë„¤ ëª¨ì„œë¦¬ ì  ê³„ì‚°
    corners = [
        pos,
        pos + Vec2(text_length * cos_a, text_length * sin_a),
        pos + Vec2(text_length * cos_a - text_height * sin_a, 
                   text_length * sin_a + text_height * cos_a),
        pos + Vec2(-text_height * sin_a, text_height * cos_a)
    ]
    
    return corners

def point_to_line_distance(point, line_start, line_end):
    """ì ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°"""
    line_vec = line_end - line_start
    point_vec = point - line_start
    line_len = distance(line_start, line_end)
    
    if line_len < 0.001:  # ì„ ë¶„ì´ ì ì¸ ê²½ìš°
        return distance(point, line_start)
    
    t = max(0, min(1, (point_vec.x * line_vec.x + point_vec.y * line_vec.y) / (line_len * line_len)))
    projection = line_start + line_vec * t
    
    return distance(point, projection)

def text_intersects_polyline(text, polyline_points):
    """í…ìŠ¤íŠ¸ê°€ í´ë¦¬ë¼ì¸ê³¼ êµì°¨í•˜ëŠ”ì§€ í™•ì¸"""
    text_corners = get_text_bounds(text)
    
    # í…ìŠ¤íŠ¸ ê²½ê³„ì˜ ê° ì„ ë¶„ê³¼ í´ë¦¬ë¼ì¸ì˜ ê° ì„ ë¶„ì´ êµì°¨í•˜ëŠ”ì§€ í™•ì¸
    for i in range(len(text_corners)):
        j = (i + 1) % len(text_corners)
        for k in range(len(polyline_points) - 1):
            if segments_cross(text_corners[i], text_corners[j], 
                            polyline_points[k], polyline_points[k+1]):
                return True
    
    # í…ìŠ¤íŠ¸ì˜ ê° ëª¨ì„œë¦¬ê°€ í´ë¦¬ë¼ì¸ì— ë„ˆë¬´ ê°€ê¹Œìš´ì§€ í™•ì¸ (1mm ì´ë‚´)
    for corner in text_corners:
        for k in range(len(polyline_points) - 1):
            if point_to_line_distance(corner, polyline_points[k], polyline_points[k+1]) < 1.0:
                return True
    
    return False

def texts_overlap(text1, text2):
    """ë‘ í…ìŠ¤íŠ¸ê°€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸"""
    if text1 == text2:
        return False
    
    corners1 = get_text_bounds(text1)
    corners2 = get_text_bounds(text2)
    
    # ë‘ í…ìŠ¤íŠ¸ ê²½ê³„ê°€ êµì°¨í•˜ëŠ”ì§€ í™•ì¸
    for i in range(len(corners1)):
        j = (i + 1) % len(corners1)
        for k in range(len(corners2)):
            l = (k + 1) % len(corners2)
            if segments_cross(corners1[i], corners1[j], corners2[k], corners2[l]):
                return True
    
    # í•œ í…ìŠ¤íŠ¸ì˜ ì¤‘ì‹¬ì´ ë‹¤ë¥¸ í…ìŠ¤íŠ¸ ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
    try:
        insert1 = text1.dxf.insert
        insert2 = text2.dxf.insert
        height1 = text1.dxf.height
        height2 = text2.dxf.height
    except AttributeError:
        try:
            insert1 = text1.get_dxf_attrib('insert', default=(0, 0, 0))
            insert2 = text2.get_dxf_attrib('insert', default=(0, 0, 0))
            height1 = text1.get_dxf_attrib('height', default=1.0)
            height2 = text2.get_dxf_attrib('height', default=1.0)
        except:
            insert1 = getattr(text1, 'insert', (0, 0, 0))
            insert2 = getattr(text2, 'insert', (0, 0, 0))
            height1 = getattr(text1, 'height', 1.0)
            height2 = getattr(text2, 'height', 1.0)
    
    center1 = Vec2(insert1[0], insert1[1])
    center2 = Vec2(insert2[0], insert2[1])
    
    # ì¤‘ì‹¬ ê°„ ê±°ë¦¬ê°€ ë„ˆë¬´ ê°€ê¹Œìš´ ê²½ìš°
    if distance(center1, center2) < (height1 + height2) * 0.5:
        return True
    
    return False

def count_interferences(text, msp, pipe_entities, other_texts):
    """í…ìŠ¤íŠ¸ì˜ ê°„ì„­ ìˆ˜ë¥¼ ê³„ì‚° (PIPE ì œì™¸)"""
    interference_count = 0
    
    # ëª¨ë“  í´ë¦¬ë¼ì¸ê³¼ì˜ ê°„ì„­ í™•ì¸ (PIPE ì œì™¸)
    for entity in msp.query('LWPOLYLINE POLYLINE'):
        if entity in pipe_entities:
            continue
        
        pts = extract_points(entity)
        if pts and text_intersects_polyline(text, pts):
            interference_count += 1
    
    # ë¼ì¸ê³¼ì˜ ê°„ì„­ í™•ì¸ (PIPE ì œì™¸)
    for line in msp.query('LINE'):
        if get_entity_layer(line).upper() == 'PIPE':
            continue
        
        line_pts = [
            Vec2(line.dxf.start.x, line.dxf.start.y),
            Vec2(line.dxf.end.x, line.dxf.end.y)
        ]
        if text_intersects_polyline(text, line_pts):
            interference_count += 1
    
    # ë‹¤ë¥¸ í…ìŠ¤íŠ¸ì™€ì˜ ê°„ì„­ í™•ì¸
    for other_text in other_texts:
        if texts_overlap(text, other_text):
            interference_count += 100  # í…ìŠ¤íŠ¸ ê°„ì„­ì€ ë§¤ìš° ë†’ì€ ê°€ì¤‘ì¹˜
    
    return interference_count

def find_optimal_text_position(text, pipe_angle, msp, pipe_entities, other_texts, max_offset=10):
    """í…ìŠ¤íŠ¸ì˜ ìµœì  ìœ„ì¹˜ ì°¾ê¸° (1mm ë‹¨ìœ„ë¡œ ì´ë™í•˜ë©° ê°„ì„­ ìµœì†Œí™”)"""
    insert = text.dxf.insert
    original_pos = Vec2(insert[0], insert[1])
    min_interference = count_interferences(text, msp, pipe_entities, other_texts)
    best_offset = 0
    
    # ê°„ì„­ì´ ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ ìœ ì§€
    if min_interference == 0:
        return
    
    # -10mm ~ +10mm ë²”ìœ„ì—ì„œ 1mmì”© ì´ë™í•˜ë©° í…ŒìŠ¤íŠ¸
    for offset_mm in range(-max_offset, max_offset + 1):
        if offset_mm == 0:
            continue
        
        # ì„ì‹œë¡œ í…ìŠ¤íŠ¸ ì´ë™
        offset_vec = get_offset_by_angle(pipe_angle, offset_mm)
        text.dxf.insert = (original_pos.x + offset_vec.x, 
                          original_pos.y + offset_vec.y, 0)
        
        # ê°„ì„­ ìˆ˜ ê³„ì‚°
        interference = count_interferences(text, msp, pipe_entities, other_texts)
        
        # ë” ì ì€ ê°„ì„­ì„ ì°¾ì€ ê²½ìš°
        if interference < min_interference:
            min_interference = interference
            best_offset = offset_mm
            
            # ê°„ì„­ì´ 0ì´ë©´ ì¦‰ì‹œ ì¤‘ë‹¨
            if interference == 0:
                break
    
    # ìµœì  ìœ„ì¹˜ë¡œ ì´ë™
    if best_offset != 0:
        offset_vec = get_offset_by_angle(pipe_angle, best_offset)
        text.dxf.insert = (original_pos.x + offset_vec.x, 
                          original_pos.y + offset_vec.y, 0)
    else:
        # ì›ë˜ ìœ„ì¹˜ë¡œ ë³µì›
        text.dxf.insert = (original_pos.x, original_pos.y, 0)

def min_distance_to_polyline(point, polyline_points):
    """ì ì—ì„œ í´ë¦¬ë¼ì¸ê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°"""
    min_dist = float('inf')
    for i in range(len(polyline_points) - 1):
        dist = point_to_line_distance(point, polyline_points[i], polyline_points[i+1])
        min_dist = min(min_dist, dist)
    return min_dist

def find_fall_text_with_box(msp, reference_point, max_distance=100):
    """reference_point ì£¼ìœ„ì—ì„œ FALLì„ í¬í•¨í•˜ëŠ” í…ìŠ¤íŠ¸ë¥¼ ì°¾ê³  BOXí™”í•˜ì—¬ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ"""
    candidates = []
    
    for t in msp.query('TEXT'):
        if 'FALL' in t.dxf.text.upper():  # íšŒì „ ê°ë„ ì œí•œ ì—†ìŒ
            insert = t.dxf.insert
            t_pos = Vec2(insert[0], insert[1])
            
            # reference_pointì—ì„œ max_distance ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
            if distance(t_pos, reference_point) <= max_distance:
                # í…ìŠ¤íŠ¸ BOX ìƒì„±
                text_corners = get_text_bounds(t)
                
                # BOXì˜ ëª¨ë“  ì  ì¤‘ reference_pointì— ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
                min_dist = float('inf')
                for corner in text_corners:
                    dist = distance(corner, reference_point)
                    min_dist = min(min_dist, dist)
                
                candidates.append({
                    'text': t,
                    'min_distance': min_dist,
                    'corners': text_corners
                })
    
    # ê°€ì¥ ê°€ê¹Œìš´ CT ì„ íƒ
    if candidates:
        candidates.sort(key=lambda x: x['min_distance'])
        selected = candidates[0]
        return selected['text']
    
    return None

def find_connected_pipes(msp, start_pipe, tolerance=0.2):
    """ì‹œì‘ PIPEì—ì„œ ì—°ê²°ëœ ëª¨ë“  PIPE ì°¾ê¸°"""
    connected_pipes = [start_pipe]
    processed = set([start_pipe])
    to_process = [start_pipe]
    
    # ì¢Œí‘œ ìŠ¤ì¼€ì¼ í™•ì¸ì„ ìœ„í•œ ì²« ë²ˆì§¸ íŒŒì´í”„ í™•ì¸
    first_pts = extract_points(start_pipe)
    if len(first_pts) >= 2:
        first_length = distance(first_pts[0], first_pts[-1])
        
        # íŒŒì´í”„ ê¸¸ì´ê°€ ë§¤ìš° í¬ë©´ tolerance ì¡°ì •
        if first_length > 1000:  # 1000 ì´ìƒì´ë©´ ë‹¨ìœ„ê°€ ë‹¤ë¥¼ ê°€ëŠ¥ì„±
            adjusted_tolerance = tolerance * 1000  # ë¯¸í„° ë‹¨ìœ„ë¡œ ê°€ì •
            tolerance = adjusted_tolerance
    
    while to_process:
        current_pipe = to_process.pop(0)
        
        # extract_points í•¨ìˆ˜ ì‚¬ìš©ìœ¼ë¡œ í†µì¼
        current_pts = extract_points(current_pipe)
        
        if len(current_pts) < 2:
            continue
            
        # í˜„ì¬ PIPEì˜ ì–‘ ëì 
        end_points = [current_pts[0], current_pts[-1]]
        
        # ë‹¤ë¥¸ PIPEë“¤ê³¼ ì—°ê²° í™•ì¸
        for entity in msp.query('LWPOLYLINE POLYLINE LINE'):
            if entity in processed or get_entity_layer(entity).upper() != 'PIPE':
                continue
                
            # extract_points í•¨ìˆ˜ ì‚¬ìš©ìœ¼ë¡œ í†µì¼
            other_pts = extract_points(entity)
                
            if len(other_pts) < 2:
                continue
                
            # ë‹¤ë¥¸ PIPEì˜ ì–‘ ëì 
            other_end_points = [other_pts[0], other_pts[-1]]
            
            # ëì  ê°„ ì—°ê²° í™•ì¸
            connected = False
            min_connection_dist = float('inf')
            
            for ep1 in end_points:
                for ep2 in other_end_points:
                    dist = distance(ep1, ep2)
                    min_connection_dist = min(min_connection_dist, dist)
                    if dist <= tolerance:
                        connected = True
                        break
                if connected:
                    break
            
            if connected:
                connected_pipes.append(entity)
                processed.add(entity)
                to_process.append(entity)
            elif min_connection_dist < tolerance * 10:  # ê·¼ì²˜ì— ìˆì§€ë§Œ ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš°
                pass
    
    return connected_pipes

def create_tpipe_segments(connected_pipes):
    """ì—°ê²°ëœ PIPEë“¤ë¡œë¶€í„° ëª¨ë“  ì„ ë¶„ ì¶”ì¶œ"""
    segments = []
    
    for i, pipe in enumerate(connected_pipes):
        pts = extract_points(pipe)
        
        if len(pts) >= 2:
            # LINEì¸ ê²½ìš° í•˜ë‚˜ì˜ ì„ ë¶„
            if pipe.dxftype() == 'LINE':
                segments.append([pts[0], pts[1]])
            else:
                # POLYLINEì¸ ê²½ìš° ì—¬ëŸ¬ ì„ ë¶„
                for j in range(len(pts) - 1):
                    segments.append([pts[j], pts[j+1]])
    
    return segments

def find_fall_text_near_tpipe(msp, tpipe_segments, processed_texts, tpipe_layer_name, max_distance=20):
    """TPIPE ì„ ë¶„ì—ì„œ max_distance ë‚´ì˜ ëª¨ë“  FALL í…ìŠ¤íŠ¸ ì°¾ê¸° (ê¸°ìš¸ê¸° í™•ì¸ í¬í•¨)"""
    fall_texts = []
    
    # ë””ë²„ê¹…: ì „ì²´ TEXT ê°œìˆ˜ í™•ì¸
    all_texts = list(msp.query('TEXT'))
    fall_containing_texts = [t for t in all_texts if 'FALL' in t.dxf.text.upper() and t not in processed_texts]
    
    changed_count = 0
    
    for t in msp.query('TEXT'):
        if 'FALL' in t.dxf.text.upper() and t not in processed_texts:
            insert = t.dxf.insert
            t_pos = Vec2(insert[0], insert[1])
            
            # í…ìŠ¤íŠ¸ BOXì˜ ê° ëª¨ì„œë¦¬ ì 
            text_corners = get_text_bounds(t)
            
            # í…ìŠ¤íŠ¸ì˜ íšŒì „ ê°ë„
            text_rotation = t.dxf.rotation
            
            # TPIPEì˜ ê° ì„ ë¶„ì— ëŒ€í•´ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
            min_dist_to_tpipe = float('inf')
            closest_segment = None
            closest_info = None
            
            # 1. ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬ í™•ì¸
            for seg_idx, segment in enumerate(tpipe_segments):
                # ì„ ë¶„ì˜ ê°ë„ ê³„ì‚°
                segment_angle = get_angle(segment[0], segment[1])
                
                # í…ìŠ¤íŠ¸ì™€ ì„ ë¶„ì˜ ê°ë„ê°€ ìœ ì‚¬í•œì§€ í™•ì¸ (15ë„ ì´ë‚´)
                if not angles_are_similar(text_rotation, segment_angle, tolerance=15):
                    continue  # ê°ë„ê°€ ë§ì§€ ì•Šìœ¼ë©´ ìŠ¤í‚µ
                
                # í…ìŠ¤íŠ¸ BOXì˜ ê° ì ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬
                for corner in text_corners:
                    dist = point_to_line_distance(corner, segment[0], segment[1])
                    if dist < min_dist_to_tpipe:
                        min_dist_to_tpipe = dist
                        closest_segment = segment
                        closest_info = f"ì„ ë¶„[{seg_idx}]ì˜ corner (ê°ë„: {segment_angle:.1f}Â°)"
                
                # í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì ì—ì„œë„ ê±°ë¦¬ ì¸¡ì •
                dist_center = point_to_line_distance(t_pos, segment[0], segment[1])
                if dist_center < min_dist_to_tpipe:
                    min_dist_to_tpipe = dist_center
                    closest_segment = segment
                    closest_info = f"ì„ ë¶„[{seg_idx}]ì˜ center (ê°ë„: {segment_angle:.1f}Â°)"
            
            if min_dist_to_tpipe <= max_distance and closest_segment:
                fall_texts.append(t)
                processed_texts.add(t)  # ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ë¡œ í‘œì‹œ
                
                # TPIPE ë ˆì´ì–´ë¡œ ë³€ê²½
                if t.dxf.layer != tpipe_layer_name:
                    old_layer = t.dxf.layer
                    old_color = t.dxf.color
                    t.dxf.layer = tpipe_layer_name
                    t.dxf.color = 4  # CYAN
                    changed_count += 1
    
    return fall_texts

def find_fall_polyline_near_text(msp, text, processed_polylines):
    """í…ìŠ¤íŠ¸ì™€ ê°€ì¥ ê°€ê¹Œìš´ 4ì  FALL ë ˆì´ì–´ í´ë¦¬ë¼ì¸ ì°¾ê¸° (ê±°ë¦¬ ì œí•œ ì—†ìŒ)"""
    insert = text.dxf.insert
    t_pos = Vec2(insert[0], insert[1])
    
    candidates = []
    
    for pl in msp.query('LWPOLYLINE POLYLINE'):
        if get_entity_layer(pl).upper() == 'FALL' and pl not in processed_polylines:
            pts = extract_points(pl)
            if len(pts) == 4:
                # í´ë¦¬ë¼ì¸ì˜ ê° ì ì—ì„œ í…ìŠ¤íŠ¸ê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬
                min_dist = float('inf')
                for pt in pts:
                    dist = distance(pt, t_pos)
                    if dist < min_dist:
                        min_dist = dist
                
                # í´ë¦¬ë¼ì¸ì˜ ì¤‘ì‹¬ì—ì„œ í…ìŠ¤íŠ¸ê¹Œì§€ì˜ ê±°ë¦¬ë„ í™•ì¸
                pl_center = Vec2(
                    sum(p.x for p in pts) / 4,
                    sum(p.y for p in pts) / 4
                )
                center_dist = distance(pl_center, t_pos)
                min_dist = min(min_dist, center_dist)
                
                candidates.append({
                    'polyline': pl,
                    'distance': min_dist
                })
    
    # ê°€ì¥ ê°€ê¹Œìš´ FL ë°˜í™˜
    if candidates:
        candidates.sort(key=lambda x: x['distance'])
        selected = candidates[0]
        return selected['polyline']
    
    return None

def find_fall_polyline_near_text_with_limit(msp, text, max_distance=20):
    """í…ìŠ¤íŠ¸ ê·¼ì²˜ì˜ 4ì  FALL ë ˆì´ì–´ í´ë¦¬ë¼ì¸ ì°¾ê¸° (ê±°ë¦¬ ì œí•œ ìˆìŒ, ì´ˆê¸° FALL ì²˜ë¦¬ìš©)"""
    insert = text.dxf.insert
    t_pos = Vec2(insert[0], insert[1])
    
    candidates = []
    
    # ìŠ¤ì¼€ì¼ ìë™ ì¡°ì •ì„ ìœ„í•œ ì²« ë²ˆì§¸ FALL í´ë¦¬ë¼ì¸ í™•ì¸
    first_fall_pl = None
    for pl in msp.query('LWPOLYLINE POLYLINE'):
        if get_entity_layer(pl).upper() == 'FALL':
            pts = extract_points(pl)
            if len(pts) == 4:
                first_fall_pl = pl
                first_pts = pts
                break
    
    # ê±°ë¦¬ ìŠ¤ì¼€ì¼ ì¡°ì •
    adjusted_max_distance = max_distance
    if first_fall_pl:
        # ì²« ë²ˆì§¸ FALL í´ë¦¬ë¼ì¸ì˜ í¬ê¸° í™•ì¸
        min_x = min(p.x for p in first_pts)
        max_x = max(p.x for p in first_pts)
        min_y = min(p.y for p in first_pts)
        max_y = max(p.y for p in first_pts)
        pl_size = max(max_x - min_x, max_y - min_y)
        
        if pl_size > 100:  # í´ë¦¬ë¼ì¸ì´ í¬ë©´ ìŠ¤ì¼€ì¼ ì¡°ì •
            scale_factor = pl_size / 10
            adjusted_max_distance = max_distance * scale_factor
    
    for pl in msp.query('LWPOLYLINE POLYLINE'):
        if get_entity_layer(pl).upper() == 'FALL':
            pts = extract_points(pl)
            if len(pts) == 4:
                # í´ë¦¬ë¼ì¸ì˜ ê° ì ì—ì„œ í…ìŠ¤íŠ¸ê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬
                min_dist = float('inf')
                for pt in pts:
                    dist = distance(pt, t_pos)
                    if dist < min_dist:
                        min_dist = dist
                
                # í´ë¦¬ë¼ì¸ì˜ ì¤‘ì‹¬ì—ì„œ í…ìŠ¤íŠ¸ê¹Œì§€ì˜ ê±°ë¦¬ë„ í™•ì¸
                pl_center = Vec2(
                    sum(p.x for p in pts) / 4,
                    sum(p.y for p in pts) / 4
                )
                center_dist = distance(pl_center, t_pos)
                min_dist = min(min_dist, center_dist)
                
                if min_dist <= adjusted_max_distance:
                    candidates.append({
                        'polyline': pl,
                        'distance': min_dist
                    })
    
    # ê°€ì¥ ê°€ê¹Œìš´ FL ë°˜í™˜
    if candidates:
        candidates.sort(key=lambda x: x['distance'])
        selected = candidates[0]
        return selected['polyline']
    
    return None

def process_file(filepath):
    doc = ezdxf.readfile(filepath)
    msp = doc.modelspace()
    
    # DXF íŒŒì¼ì˜ ë‹¨ìœ„ í™•ì¸
    try:
        units = doc.header.get('$INSUNITS', 0)
        unit_names = {0: "ì—†ìŒ", 1: "ì¸ì¹˜", 2: "í”¼íŠ¸", 3: "ë§ˆì¼", 4: "ë°€ë¦¬ë¯¸í„°", 
                     5: "ì„¼í‹°ë¯¸í„°", 6: "ë¯¸í„°", 7: "í‚¬ë¡œë¯¸í„°", 8: "ë§ˆì´í¬ë¡œì¸ì¹˜",
                     9: "ë°€", 10: "ì•¼ë“œ", 11: "ì˜¹ìŠ¤íŠ¸ë¡¬", 12: "ë‚˜ë…¸ë¯¸í„°",
                     13: "ë§ˆì´í¬ë¡ ", 14: "ë°ì‹œë¯¸í„°", 15: "ë°ì¹´ë¯¸í„°", 16: "í—¥í† ë¯¸í„°",
                     17: "ê¸°ê°€ë¯¸í„°", 18: "ì²œë¬¸ë‹¨ìœ„", 19: "ê´‘ë…„", 20: "íŒŒì„¹"}
        unit_name = unit_names.get(units, f"ì•Œ ìˆ˜ ì—†ìŒ({units})")
    except:
        pass
    
    # ì‚­ì œí•  ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸
    entities_to_delete = []
    
    # ëª¨ë“  í…ìŠ¤íŠ¸ ìˆ˜ì§‘ (ê°„ì„­ ì²´í¬ìš©)
    all_texts = list(msp.query('TEXT'))
    
    # PIPE ì—”í‹°í‹° ìˆ˜ì§‘
    pipe_entities = []
    for entity in msp.query('LWPOLYLINE POLYLINE LINE'):
        if get_entity_layer(entity).upper() == 'PIPE':
            pipe_entities.append(entity)

    # FF ê·¸ë£¹ ì €ì¥ (FT + FL)
    ff_groups = []

    # 1. FALL ë ˆì´ì–´ì˜ 4ì  í´ë¦¬ë¼ì¸ ì°¾ê¸°
    fall_polylines = []
    for pl in msp.query('LWPOLYLINE POLYLINE'):
        if get_entity_layer(pl).upper() == 'FALL':
            pts = extract_points(pl)
            if len(pts) == 4:
                fall_polylines.append(pl)

    # ê° FALL í´ë¦¬ë¼ì¸ ì²˜ë¦¬
    for fall_pl in fall_polylines:
        fall_pts = extract_points(fall_pl)
        
        # FALL í´ë¦¬ë¼ì¸ì˜ ì  1ë²ˆê³¼ 2ë²ˆì˜ ì¤‘ì‹¬ì  ê³„ì‚°
        fall_p1_p2_center = Vec2(
            (fall_pts[0].x + fall_pts[1].x) / 2,
            (fall_pts[0].y + fall_pts[1].y) / 2
        )
        
        # FALL ì¤‘ì‹¬ ê³„ì‚°
        fall_center = Vec2(
            sum(p.x for p in fall_pts) / 4,
            sum(p.y for p in fall_pts) / 4
        )
        
        # 2. FALL ì„ ë¶„ì— ì ‘í•˜ëŠ” 2ì , 3ì  í´ë¦¬ë¼ì¸ ì°¾ê¸° ë° ë¶„ë¥˜
        g1_list = []  # 2ì  í´ë¦¬ë¼ì¸ + ì ê°„ê±°ë¦¬ 2.1 ì´ˆê³¼ 3ì  í´ë¦¬ë¼ì¸
        ad1_list = []  # ì ê°„ê±°ë¦¬ 2.1 ì´í•˜ 3ì  í´ë¦¬ë¼ì¸
        ad1_groups = []  # AD1ê³¼ ì—°ê´€ëœ ARROW lineë“¤ì˜ ê·¸ë£¹
        
        for pl in msp.query('LWPOLYLINE POLYLINE'):
            if pl is fall_pl:  # FALL ìì‹ ì€ ì œì™¸
                continue
                
            pts = extract_points(pl)
            
            if not polyline_intersects_with_fall(pts, fall_pts):
                continue
            
            # 2ì  í´ë¦¬ë¼ì¸ â†’ G1
            if len(pts) == 2:
                set_entity_layer(pl, "G1")
                set_entity_color(pl, 4)  # CYAN
                g1_list.append(pl)
            
            # 3ì  í´ë¦¬ë¼ì¸ â†’ ì ê°„ ê±°ë¦¬ì— ë”°ë¼ ë¶„ë¥˜
            elif len(pts) == 3:
                if check_all_segments_under_21(pts):
                    # ëª¨ë“  ì ê°„ ê±°ë¦¬ 2.1 ì´í•˜ â†’ AD1
                    set_entity_layer(pl, "AD1")
                    set_entity_color(pl, 3)  # GREEN
                    ad1_list.append(pl)
                    
                    # ARROW ë ˆì´ì–´ line ì°¾ê¸° (0.2mm ë‚´, 1mm ì´í•˜)
                    arrow_lines = find_arrow_lines_near_points(msp, pts)
                    for arrow in arrow_lines:
                        set_entity_color(arrow, 3)  # GREEN
                    
                    ad1_groups.append({
                        'polyline': pl,
                        'arrows': arrow_lines
                    })
                else:
                    # ì ê°„ ê±°ë¦¬ 2.1 ì´ˆê³¼ â†’ G1
                    set_entity_layer(pl, "G1")
                    set_entity_color(pl, 4)  # CYAN
                    g1_list.append(pl)
        
        # ì‚­ì œ ì œì™¸í•  G1ê³¼ AD1 ì°¾ê¸°
        exclude_from_deletion = set()
        
        for g1 in g1_list:
            g1_pts = extract_points(g1)
            if len(g1_pts) == 2 and g1_crosses_both_fall_segments(g1_pts, fall_pts):
                exclude_from_deletion.add(g1)
                
                # ì´ G1ê³¼ ì ‘ì´‰í•˜ëŠ” AD1ë„ ì œì™¸
                for ad1_group in ad1_groups:
                    ad1_pts = extract_points(ad1_group['polyline'])
                    if polylines_intersect(g1_pts, ad1_pts):
                        exclude_from_deletion.add(ad1_group['polyline'])
        
        # 3. G1ê³¼ AD1ì—ì„œ FALL TEXT ì°¾ê¸° (ê°œì„ ëœ ë°©ì‹)
        fall_text = None
        fall_o_text = None
        found_entities = []  # FALL TEXTë¥¼ ì°¾ì€ ëª¨ë“  ì—”í‹°í‹°ë“¤
        found_ad1_groups = []  # FALL TEXTë¥¼ ì°¾ì€ AD1 ê·¸ë£¹ë“¤
        
        # G1 ë¦¬ìŠ¤íŠ¸ì—ì„œ ì°¾ê¸° (BOXí™” ë°©ì‹)
        for g1 in g1_list:
            g1_pts = extract_points(g1)
            
            # G1ì˜ FALLë¡œë¶€í„° ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
            max_dist = 0
            far_point = None
            for pt in g1_pts:
                d = distance(pt, fall_center)
                if d > max_dist:
                    max_dist = d
                    far_point = pt
            
            if not far_point:
                continue
            
            # ë¨¼ ì  ê·¼ì²˜ì—ì„œ FALL TEXT ì°¾ê¸° (BOXí™” ë°©ì‹, 100mm ë²”ìœ„)
            ct = find_fall_text_with_box(msp, far_point, max_distance=100)
            if ct:
                if not fall_text:  # ì²« ë²ˆì§¸ ë°œê²¬í•œ ê²ƒë§Œ ì²˜ë¦¬ìš©ìœ¼ë¡œ ì €ì¥
                    fall_text = ct
                found_entities.append(g1)
        
        # AD1ì—ì„œë„ ì°¾ê¸°
        for ad1_group in ad1_groups:
            ad1_pts = extract_points(ad1_group['polyline'])
            
            # AD1ì˜ FALLë¡œë¶€í„° ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
            max_dist = 0
            far_point = None
            for pt in ad1_pts:
                d = distance(pt, fall_center)
                if d > max_dist:
                    max_dist = d
                    far_point = pt
            
            if not far_point:
                continue
            
            # ë¨¼ ì  ê·¼ì²˜ì—ì„œ FALL TEXT ì°¾ê¸° (50mmë¡œ í™•ëŒ€, íšŒì „ ì œí•œ ì—†ìŒ)
            for t in msp.query('TEXT'):
                if 'FALL' in t.dxf.text.upper():  # íšŒì „ ê°ë„ ì œí•œ ì œê±°
                    insert = t.dxf.insert
                    t_pos = Vec2(insert[0], insert[1])
                    
                    if distance(t_pos, far_point) <= 50:  # 20mm â†’ 50mm
                        if not fall_text:  # ì²« ë²ˆì§¸ ë°œê²¬í•œ ê²ƒë§Œ ì²˜ë¦¬ìš©ìœ¼ë¡œ ì €ì¥
                            fall_text = t
                        found_entities.append(ad1_group['polyline'])
                        found_ad1_groups.append(ad1_group)
                        break
        
        # O í…ìŠ¤íŠ¸ ì°¾ê¸° (ê±°ë¦¬ ì œí•œ ì—†ì´ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ)
        if fall_text:
            insert = fall_text.dxf.insert
            t_pos = Vec2(insert[0], insert[1])
            min_dist = float('inf')
            for o in msp.query('TEXT'):
                if o.dxf.text.strip().upper() == 'O':
                    try:
                        o_insert = o.dxf.insert
                        o_pos = Vec2(o_insert[0], o_insert[1])
                        dist = distance(o_pos, t_pos)
                        if dist < min_dist:  # ê±°ë¦¬ ì œí•œ ì œê±°
                            min_dist = dist
                            fall_o_text = o
                    except:
                        continue
        
        if not fall_text:
            continue
        
        fall_insert = fall_text.dxf.insert
        fall_pos = Vec2(fall_insert[0], fall_insert[1])
        
        # 4. FALL ë ˆì´ì–´ì— ê°€ì¥ ê°€ê¹Œìš´ PIPE ë ˆì´ì–´ ì°¾ê¸°
        found_pipe = None
        pipe_p1, pipe_p2 = None, None
        min_pipe_dist = float('inf')
        pipe_angle = 0  # PIPE ê°ë„ ì €ì¥
        
        for pl in msp.query('LWPOLYLINE POLYLINE'):
            if get_entity_layer(pl).upper() != "PIPE":
                continue
            pts = extract_points(pl)
            
            if len(pts) == 2:
                for pt in pts:
                    d = distance(pt, fall_center)
                    if d < min_pipe_dist:
                        min_pipe_dist = d
                        found_pipe = pl
                        if distance(pts[0], fall_pos) <= distance(pts[1], fall_pos):
                            pipe_p1, pipe_p2 = pts[0], pts[1]
                        else:
                            pipe_p1, pipe_p2 = pts[1], pts[0]
        
        if not found_pipe:
            pipe_p1, pipe_p2 = fall_pts[0], fall_pts[1]
        
        # PIPE ê°ë„ ê³„ì‚°
        pipe_angle = get_angle(pipe_p1, pipe_p2)
        
        # 5. FALL TEXT ì²˜ë¦¬
        if not fall_text.dxf.text.endswith("Â°"):
            fall_text.dxf.text = fall_text.dxf.text + "Â°"
        
        if fall_o_text:
            try:
                msp.delete_entity(fall_o_text)
            except Exception as e:
                pass
        
        # íšŒì „ ê°ë„ ê³„ì‚°
        angle = get_angle(pipe_p1, pipe_p2)
        rotate_angle = 180 - abs(angle) if angle < -120 else angle
        
        # FALL í…ìŠ¤íŠ¸ íšŒì „ ë° ì´ë™
        rotate_text(fall_text, fall_pos, rotate_angle)
        current_insert = fall_text.dxf.insert
        current_pos = Vec2(current_insert[0], current_insert[1])
        move_text(fall_text, fall_p1_p2_center - current_pos)
        
        if angle < -120:
            move_text(fall_text, get_offset_by_angle(angle, 12))
            move_text(fall_text, get_perpendicular_offset(angle, 5.5))
        else:
            move_text(fall_text, get_offset_by_angle(angle, -5))
            move_text(fall_text, get_perpendicular_offset(angle, -5.5))
        
        # í…ìŠ¤íŠ¸ê°€ ë’¤ì§‘í˜€ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  180ë„ íšŒì „
        current_rotation = fall_text.dxf.rotation % 360
        if is_text_upside_down(current_rotation):
            rotate_text(fall_text, fall_p1_p2_center, 180)
        
        fall_text.dxf.color = 1
        fall_text.dxf.layer = "RED"
        
        # ê°„ì„­ ì²´í¬ ë° ìµœì  ìœ„ì¹˜ ì°¾ê¸°
        find_optimal_text_position(fall_text, pipe_angle, msp, pipe_entities, all_texts)
        
        # 6. FALL TEXTë¥¼ ì°¾ëŠ”ë° ì„±ê³µí•œ ëª¨ë“  G1ê³¼ AD1 ì‚­ì œ (ì œì™¸ ëŒ€ìƒ ì œì™¸)
        for entity in found_entities:
            if entity not in exclude_from_deletion:
                entities_to_delete.append(entity)
                layer = get_entity_layer(entity)
                
                # G1ì¸ ê²½ìš°, ì‹œì‘ì  0.5mm ë‚´ì˜ AD1 ì°¾ê¸°
                if layer == "G1":
                    g1_pts = extract_points(entity)
                    if g1_pts:
                        # G1 ì‹œì‘ì ì—ì„œ 0.5mm ë‚´ì˜ AD1 ì°¾ê¸°
                        near_ad1_groups = find_ad1_near_g1_start(g1_pts, ad1_groups, max_dist=0.5)
                        for ad1_group in near_ad1_groups:
                            if ad1_group['polyline'] not in exclude_from_deletion:
                                # AD1 ì‚­ì œ ì˜ˆì •ì— ì¶”ê°€
                                if ad1_group['polyline'] not in entities_to_delete:
                                    entities_to_delete.append(ad1_group['polyline'])
                                
                                # AD1ì˜ ARROW lineë“¤ë„ ì‚­ì œ ì˜ˆì •ì— ì¶”ê°€
                                for arrow in ad1_group['arrows']:
                                    if arrow not in entities_to_delete:
                                        entities_to_delete.append(arrow)
        
        # AD1ê°€ ì§ì ‘ FALL TEXTë¥¼ ì°¾ì€ ê²½ìš°ì˜ ARROW lineë“¤ë„ ì‚­ì œ
        for ad1_group in found_ad1_groups:
            if ad1_group['polyline'] not in exclude_from_deletion:
                for arrow in ad1_group['arrows']:
                    if arrow not in entities_to_delete:
                        entities_to_delete.append(arrow)
    
    # 7. TPIPE ê¸°ë°˜ FF ì°¾ê¸° ë° ì¤‘ë³µ ì œê±°
    
    # TPIPE ì²˜ë¦¬ ì „ FALL TEXT í†µê³„
    initial_fall_texts = [t for t in msp.query('TEXT') if 'FALL' in t.dxf.text.upper()]
    initial_red_count = sum(1 for t in initial_fall_texts if t.dxf.layer == "RED" and t.dxf.color == 1)
    
    # ì „ì²´ FALL TEXT ìƒ‰ìƒ ë³€ê²½ í†µê³„
    total_fall_texts_changed = 0
    
    # ì´ë¯¸ ì²˜ë¦¬ëœ í…ìŠ¤íŠ¸ì™€ í´ë¦¬ë¼ì¸ ì¶”ì 
    processed_texts = set()
    processed_polylines = set()
    
    # ëª¨ë“  PIPE ì—”í‹°í‹°ì— ëŒ€í•´ TPIPE ìƒì„±
    processed_pipes = set()
    tpipe_count = 0  # TPIPE ë²ˆí˜¸ ì¹´ìš´í„°
    
    for pipe in pipe_entities:
        if pipe in processed_pipes:
            continue
            
        # ì—°ê²°ëœ ëª¨ë“  PIPE ì°¾ê¸°
        connected_pipes = find_connected_pipes(msp, pipe)
        for cp in connected_pipes:
            processed_pipes.add(cp)
        
        tpipe_count += 1
        tpipe_layer_name = f"TPIPE{tpipe_count}"
        
        # ì—°ê²°ëœ PIPEë“¤ì˜ ë ˆì´ì–´ë¥¼ TPIPE#ë¡œ ë³€ê²½
        for cp in connected_pipes:
            set_entity_layer(cp, tpipe_layer_name)
        
        # TPIPE ì„ ë¶„ ìƒì„±
        tpipe_segments = create_tpipe_segments(connected_pipes)
        
        # TPIPEì—ì„œ 20mm ë‚´ì˜ FALL í…ìŠ¤íŠ¸ ì°¾ê¸°
        
        # ê±°ë¦¬ ê¸°ì¤€ 20mmë¡œ ì„¤ì •
        ft_list = find_fall_text_near_tpipe(msp, tpipe_segments, processed_texts, tpipe_layer_name, max_distance=20)
        
        total_fall_texts_changed += len(ft_list)
        
        # ì´ TPIPEì˜ FF í›„ë³´ë“¤ ì €ì¥
        tpipe_ff_candidates = []
        
        # ê° FTì— ëŒ€í•´ FL ì°¾ê¸° (ê±°ë¦¬ ì œí•œ ì—†ìŒ)
        for ft in ft_list:
            fl = find_fall_polyline_near_text(msp, ft, processed_polylines)
            if fl:
                processed_polylines.add(fl)  # ì²˜ë¦¬ëœ í´ë¦¬ë¼ì¸ìœ¼ë¡œ í‘œì‹œ
                
                # FLë„ TPIPE ë ˆì´ì–´ë¡œ ë³€ê²½
                old_fl_layer = fl.dxf.layer
                old_fl_color = fl.dxf.color
                fl.dxf.layer = tpipe_layer_name
                fl.dxf.color = 4  # CYAN
                
                # TPIPEì—ì„œ FTê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
                ft_pos = Vec2(ft.dxf.insert[0], ft.dxf.insert[1])
                min_dist_to_tpipe = float('inf')
                
                for segment in tpipe_segments:
                    dist = point_to_line_distance(ft_pos, segment[0], segment[1])
                    min_dist_to_tpipe = min(min_dist_to_tpipe, dist)
                
                ff_groups.append({
                    'ft': ft,
                    'fl': fl,
                    'ft_text': ft.dxf.text,
                    'tpipe_num': tpipe_count,
                    'tpipe_layer': tpipe_layer_name,
                    'distance': min_dist_to_tpipe
                })
    
    # ì‚­ì œ ì‹¤í–‰
    for entity in entities_to_delete:
        try:
            msp.delete_entity(entity)
            layer = get_entity_layer(entity)
            handle = get_entity_handle(entity)
        except Exception as e:
            pass

    # ë™ì¼í•œ ë ˆì´ì–´ì˜ ì¤‘ë³µ FT ì œê±° (FFì™€ ë³„ê°œë¡œ ëª¨ë“  FT ê²€ì‚¬)
    
    # ëª¨ë“  FALL TEXTë¥¼ ë ˆì´ì–´ë³„ë¡œ ê·¸ë£¹í™”
    all_fall_texts = [t for t in msp.query('TEXT') if 'FALL' in t.dxf.text.upper()]
    ft_by_layer = {}
    
    for ft in all_fall_texts:
        layer = ft.dxf.layer
        if layer not in ft_by_layer:
            ft_by_layer[layer] = []
        ft_by_layer[layer].append(ft)
    
    # ê° ë ˆì´ì–´ì—ì„œ ì¤‘ë³µ FT ì œê±°
    for layer, layer_fts in ft_by_layer.items():
        if len(layer_fts) > 1:
            
            # ê° FTì˜ ìœ„ì¹˜ì™€ í…ìŠ¤íŠ¸ ì •ë³´ ìˆ˜ì§‘
            ft_info_list = []
            for ft in layer_fts:
                ft_pos = Vec2(ft.dxf.insert[0], ft.dxf.insert[1])
                
                # TPIPE ë ˆì´ì–´ì¸ ê²½ìš° í•´ë‹¹ TPIPEì™€ì˜ ê±°ë¦¬ ê³„ì‚°
                min_dist = float('inf')
                if layer.startswith('TPIPE'):
                    # í•´ë‹¹ TPIPEì˜ ì—”í‹°í‹°ë“¤ ì°¾ê¸°
                    for entity in msp.query('LWPOLYLINE POLYLINE LINE'):
                        if get_entity_layer(entity) == layer:
                            pts = extract_points(entity)
                            for i in range(len(pts) - 1):
                                dist = point_to_line_distance(ft_pos, pts[i], pts[i+1])
                                min_dist = min(min_dist, dist)
                
                ft_info_list.append({
                    'ft': ft,
                    'text': ft.dxf.text,
                    'distance': min_dist if min_dist != float('inf') else 0
                })
            
            # ê±°ë¦¬ ìˆœìœ¼ë¡œ ì •ë ¬ (ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ìš°ì„ )
            ft_info_list.sort(key=lambda x: x['distance'])
            
            # ì²« ë²ˆì§¸ë§Œ ìœ ì§€í•˜ê³  ë‚˜ë¨¸ì§€ ì‚­ì œ
            
            for i in range(1, len(ft_info_list)):
                ft_info = ft_info_list[i]
                try:
                    msp.delete_entity(ft_info['ft'])
                except Exception as e:
                    pass

    # ë™ì¼í•œ ë ˆì´ì–´ì˜ ì¤‘ë³µ FF ì œê±° (FLë„ í•¨ê»˜ ì œê±°)
    
    # ë ˆì´ì–´ë³„ë¡œ FF ê·¸ë£¹í™”
    ff_by_layer = {}
    for ff in ff_groups:
        layer = ff['tpipe_layer']
        if layer not in ff_by_layer:
            ff_by_layer[layer] = []
        ff_by_layer[layer].append(ff)
    
    # ê° ë ˆì´ì–´ì—ì„œ ì¤‘ë³µ ì œê±°
    for layer, layer_ffs in ff_by_layer.items():
        if len(layer_ffs) > 1:
            
            # ê±°ë¦¬ ìˆœìœ¼ë¡œ ì •ë ¬ (ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ìš°ì„ )
            layer_ffs.sort(key=lambda x: x['distance'])
            
            # ì²« ë²ˆì§¸ë§Œ ìœ ì§€í•˜ê³  ë‚˜ë¨¸ì§€ì˜ FLë§Œ ì‚­ì œ (FTëŠ” ì´ë¯¸ ìœ„ì—ì„œ ì²˜ë¦¬ë¨)
            
            for i in range(1, len(layer_ffs)):
                ff = layer_ffs[i]
                try:
                    # FL ì‚­ì œ
                    msp.delete_entity(ff['fl'])
                except Exception as e:
                    pass
    
    # ë§ˆì§€ë§‰ì— ì „ì²´ FALL TEXT í†µê³„ ì¶œë ¥
    final_fall_texts = [t for t in msp.query('TEXT') if 'FALL' in t.dxf.text.upper()]
    red_count = sum(1 for t in final_fall_texts if t.dxf.layer == "RED" and t.dxf.color == 1)
    tpipe_count_texts = sum(1 for t in final_fall_texts if t.dxf.layer.startswith("TPIPE"))
    other_count = len(final_fall_texts) - red_count - tpipe_count_texts
    
    # FALL í´ë¦¬ë¼ì¸ í†µê³„
    final_fall_polylines = [pl for pl in msp.query('LWPOLYLINE POLYLINE') 
                           if get_entity_layer(pl).upper() == 'FALL' or get_entity_layer(pl).startswith('TPIPE')]
    fall_layer_count = sum(1 for pl in final_fall_polylines if get_entity_layer(pl).upper() == 'FALL')
    tpipe_layer_count = sum(1 for pl in final_fall_polylines if get_entity_layer(pl).startswith('TPIPE'))
    
    save_path = os.path.splitext(filepath)[0] + "_FALL.dxf"
    doc.saveas(save_path)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python PLTONEWLINE.PY file1.dxf file2.dxf ...")
        sys.exit(1)
    
    for file_path in sys.argv[1:]:
        if os.path.exists(file_path) and file_path.lower().endswith('.dxf'):
            try:
                process_file(file_path)
                print(f"âœ… Processed: {os.path.basename(file_path)}")
            except Exception as e:
                print(f"âŒ Error processing {os.path.basename(file_path)}: {e}")
        else:
            print(f"âŒ File not found or not a DXF file: {file_path}")
    
    print("ğŸ‰ All files processed.")