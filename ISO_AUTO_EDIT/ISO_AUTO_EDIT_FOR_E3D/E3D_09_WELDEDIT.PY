import ezdxf
import os
import math
import re
from ezdxf.math import Vec2
import tkinter as tk
from tkinter import filedialog

### DXF íŒŒì¼ ì—¬ëŸ¬ ê°œ ì„ íƒ í•¨ìˆ˜ ###
def select_dxf_files():
    root = tk.Tk()
    root.withdraw()
    file_paths = filedialog.askopenfilenames(
        title="DXF íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”",
        filetypes=[("DXF Files", "*.dxf")]
    )
    root.destroy()
    if not file_paths:
        print("âŒ ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        exit()
    return file_paths

### ê³µí†µ ìœ í‹¸ í•¨ìˆ˜ë“¤ ###
def distance(p1, p2):
    if isinstance(p1, Vec2) and isinstance(p2, Vec2):
        return math.hypot(p2.x - p1.x, p2.y - p1.y)
    return math.hypot(p2[0] - p1[0], p2[1] - p1[1])

def midpoint(points):
    x = sum(p[0] for p in points) / len(points)
    y = sum(p[1] for p in points) / len(points)
    return (x, y)

def polyline_length(pl):
    try:
        if pl.dxftype() == 'LWPOLYLINE':
            points = [p[:2] for p in pl.get_points()]
        elif pl.dxftype() == 'POLYLINE':
            points = []
            for v in pl.vertices:
                if hasattr(v.dxf, 'location'):
                    pt = (v.dxf.location.x, v.dxf.location.y)
                    points.append(pt)
            if not points:
                return 0
        else:
            return 0
        return sum(distance(points[i], points[i+1]) for i in range(len(points)-1))
    except Exception:
        return 0

def get_poly_points(pl):
    try:
        if pl.dxftype() == 'LWPOLYLINE':
            points = list(pl.get_points())
            points = [pt for pt in points if abs(pt[0]) > 1e-8 or abs(pt[1]) > 1e-8]
            return points
        elif pl.dxftype() == 'POLYLINE':
            pts = []
            for v in pl.vertices:
                if hasattr(v.dxf, 'location'):
                    x, y = v.dxf.location.x, v.dxf.location.y
                    if abs(x) > 1e-8 or abs(y) > 1e-8:
                        pts.append((x, y, 0, 0))
            return pts
        else:
            return []
    except Exception:
        return []

def move_single_point_to(line, target_point, fixed_point):
    try:
        d_start = distance((line.dxf.start[0], line.dxf.start[1]), fixed_point)
        d_end = distance((line.dxf.end[0], line.dxf.end[1]), fixed_point)
        if d_start < d_end:
            line.dxf.end = target_point
        else:
            line.dxf.start = target_point
    except Exception:
        pass

def is_valid_center(center):
    if center is None:
        return False
    x, y = center
    if abs(x) < 1e-5 and abs(y) < 1e-5:
        return False
    if abs(x) > 1e5 or abs(y) > 1e5:
        return False
    return True

def is_nearly_same_points(points, tol=0.05):
    if len(points) < 2:
        return True
    base = points[0][:2]
    for pt in points[1:]:
        if distance(base, pt[:2]) > tol:
            return False
    return True

def is_valid_wdno_text(text_content):
    """WDNOë¡œ ìœ íš¨í•œ í…ìŠ¤íŠ¸ì¸ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜"""
    try:
        # INSTê°€ í¬í•¨ëœ ê²½ìš° ì œì™¸
        if 'INST' in text_content.upper():
            return False
        
        # TEXTê°€ í¬í•¨ëœ ê²½ìš° ì œì™¸ (ëŒ€ì†Œë¬¸ì ë¬´ê´€)
        if 'TEXT' in text_content.upper():
            return False
        
        # < ë¬¸ìê°€ í¬í•¨ëœ ê²½ìš° ì œì™¸
        if '<' in text_content:
            return False
        
        # ìˆ«ìê°€ í•˜ë‚˜ë„ ì—†ëŠ” ê²½ìš° ì œì™¸
        numbers = re.findall(r'\d+', text_content)
        if not numbers:
            return False
        
        return True
    except:
        return False

def is_valid_wdno_entity(text_entity):
    """TEXT ì—”í‹°í‹°ê°€ WDNOë¡œ ìœ íš¨í•œì§€ í™•ì¸ (ë‚´ìš© + ê¸°ìš¸ê¸° í™•ì¸)"""
    try:
        # í…ìŠ¤íŠ¸ ë‚´ìš© ê²€ì¦
        text_content = text_entity.dxf.text.strip()
        if not is_valid_wdno_text(text_content):
            return False
        
        # ê¸°ìš¸ê¸°ê°€ 0ì´ì–´ì•¼ í•¨ (rotationì´ 0 ë˜ëŠ” ë§¤ìš° ì‘ì€ ê°’)
        if hasattr(text_entity.dxf, 'rotation'):
            if abs(text_entity.dxf.rotation) > 0.1:  # 0.1ë„ ì´ë‚´ì˜ ì˜¤ì°¨ í—ˆìš©
                return False
        
        return True
    except:
        return False

### ê°„ì„­ ì²´í¬ í•¨ìˆ˜ ###
def point_to_segment_distance(p: Vec2, a: Vec2, b: Vec2) -> float:
    ap = p - a
    ab = b - a
    ab_len_squared = ab.dot(ab)
    if ab_len_squared == 0:
        return distance(p, a)
    t = max(0, min(1, ap.dot(ab) / ab_len_squared))
    projection = a + ab * t
    return distance(p, projection)

def check_box_overlap(box1, box2):
    """ë‘ ë°”ìš´ë”© ë°•ìŠ¤ê°€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜"""
    if not box1 or not box2:
        return False
    
    # ë°•ìŠ¤ê°€ ê²¹ì¹˜ì§€ ì•ŠëŠ” ì¡°ê±´ í™•ì¸
    if (box1['max_x'] < box2['min_x'] or 
        box1['min_x'] > box2['max_x'] or
        box1['max_y'] < box2['min_y'] or 
        box1['min_y'] > box2['max_y']):
        return False
    
    return True

def check_text_box_interference(text_entity, msp, exclude_entities):
    """TEXT ì—”í‹°í‹°ì˜ ë°”ìš´ë”© ë°•ìŠ¤ê°€ ë‹¤ë¥¸ TEXTì™€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸ (ë°•ìŠ¤ë¥¼ ìš°ì¸¡ìœ¼ë¡œ ì´ë™ í›„ ì²´í¬)"""
    text_bbox = get_text_bounding_box(text_entity)
    if not text_bbox:
        return False
    
    # BOXë¥¼ ìš°ì¸¡ìœ¼ë¡œ ê¸¸ì´ì˜ 1/2ë§Œí¼ ì´ë™
    half_width = text_bbox['width'] / 2
    adjusted_bbox = {
        'center': Vec2(text_bbox['center'].x + half_width, text_bbox['center'].y),
        'width': text_bbox['width'],
        'height': text_bbox['height'],
        'min_x': text_bbox['min_x'] + half_width,
        'max_x': text_bbox['max_x'] + half_width,
        'min_y': text_bbox['min_y'],
        'max_y': text_bbox['max_y']
    }
    
    for e in msp:
        if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
            continue
        
        if e.dxftype() == "TEXT":
            other_bbox = get_text_bounding_box(e)
            if other_bbox:
                # ë‹¤ë¥¸ í…ìŠ¤íŠ¸ë„ ìš°ì¸¡ìœ¼ë¡œ ì´ë™í•˜ì—¬ ë¹„êµ
                other_half_width = other_bbox['width'] / 2
                other_adjusted_bbox = {
                    'min_x': other_bbox['min_x'] + other_half_width,
                    'max_x': other_bbox['max_x'] + other_half_width,
                    'min_y': other_bbox['min_y'],
                    'max_y': other_bbox['max_y']
                }
                if check_box_overlap(adjusted_bbox, other_adjusted_bbox):
                    return True
    
    return False

def check_circle_box_overlap(circle_center, circle_radius, box):
    """ì›ê³¼ ë°”ìš´ë”© ë°•ìŠ¤ê°€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜"""
    if not box:
        return False
    
    # ë°•ìŠ¤ì˜ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
    closest_x = max(box['min_x'], min(circle_center.x, box['max_x']))
    closest_y = max(box['min_y'], min(circle_center.y, box['max_y']))
    
    # ì›ì˜ ì¤‘ì‹¬ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì ê¹Œì§€ì˜ ê±°ë¦¬
    dist = distance(circle_center, Vec2(closest_x, closest_y))
    
    return dist < circle_radius

def find_pipe_lines_near_sw_improved(sw_entity, sw_center, sw_type, msp, search_radius=1.0):
    """SW/SFW ê·¼ì²˜ì˜ PIPE ì„ ì„ ì°¾ëŠ” ê°œì„ ëœ í•¨ìˆ˜"""
    pipe_lines_candidates = []
    
    try:
        # SFWì¸ ê²½ìš° ì‹¤ì œ 6ê°œ ì ë“¤ì„ ê°€ì ¸ì˜´
        sfw_points = []
        if sw_type == 'POLYLINE' or sw_type == 'SFW':
            if sw_entity.dxftype() == "POLYLINE":
                sfw_points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in sw_entity.vertices]
            else:
                sfw_points = [Vec2(x, y) for x, y, *_ in sw_entity.get_points()]
            
            # SFWì˜ ê²½ìš° ê²€ìƒ‰ ë°˜ê²½ì„ 7mmë¡œ ì„¤ì •
            search_radius = 7.0
        
        # LINE ê²€ìƒ‰
        for entity in msp.query('LINE'):
            try:
                if hasattr(entity.dxf, 'layer'):
                    layer_name = entity.dxf.layer.upper()
                    if 'PIPE' in layer_name:
                        start = Vec2(entity.dxf.start.x, entity.dxf.start.y)
                        end = Vec2(entity.dxf.end.x, entity.dxf.end.y)
                        
                        min_dist = float('inf')
                        
                        if sw_type == 'CIRCLE':
                            # SW ì›ì˜ ê²½ìš°: ì¤‘ì‹¬ì—ì„œì˜ ê±°ë¦¬
                            dist_to_start = distance(sw_center, start)
                            dist_to_end = distance(sw_center, end)
                            min_dist = min(dist_to_start, dist_to_end)
                        else:
                            # SFW í´ë¦¬ë¼ì¸ì˜ ê²½ìš°: ì¤‘ì‹¬ì—ì„œ 7mm ë‚´ì˜ PIPE ì„ 
                            dist_to_start = distance(sw_center, start)
                            dist_to_end = distance(sw_center, end)
                            min_dist = min(dist_to_start, dist_to_end)
                        
                        # ìµœì†Œ ê±°ë¦¬ê°€ search_radius ì´ë‚´ë©´ í›„ë³´ì— ì¶”ê°€
                        if min_dist <= search_radius:
                            pipe_lines_candidates.append({
                                'entity': entity,
                                'type': 'LINE',
                                'segments': [(start, end)],
                                'min_distance': min_dist
                            })
            except Exception:
                continue
        
        # POLYLINE/LWPOLYLINE ê²€ìƒ‰
        for poly in msp.query("POLYLINE LWPOLYLINE"):
            try:
                if hasattr(poly.dxf, 'layer'):
                    layer_name = poly.dxf.layer.upper()
                    if 'PIPE' in layer_name:
                        if poly.dxftype() == "POLYLINE":
                            points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                        else:
                            points = [Vec2(x, y) for x, y, *_ in poly.get_points()]
                        
                        if len(points) >= 2:
                            # ëª¨ë“  ì ë“¤ì— ëŒ€í•´ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
                            min_dist = float('inf')
                            
                            if sw_type == 'CIRCLE':
                                # SW ì›ì˜ ê²½ìš°: ì¤‘ì‹¬ì—ì„œ ëª¨ë“  ì ê¹Œì§€ ê±°ë¦¬
                                for pt in points:
                                    dist = distance(sw_center, pt)
                                    min_dist = min(min_dist, dist)
                            else:
                                # SFW í´ë¦¬ë¼ì¸ì˜ ê²½ìš°: ì¤‘ì‹¬ì—ì„œ ëª¨ë“  ì ê¹Œì§€ ê±°ë¦¬
                                for pt in points:
                                    dist = distance(sw_center, pt)
                                    min_dist = min(min_dist, dist)
                            
                            if min_dist <= search_radius:
                                segments = []
                                for i in range(len(points) - 1):
                                    segments.append((points[i], points[i+1]))
                                
                                pipe_lines_candidates.append({
                                    'entity': poly,
                                    'type': poly.dxftype(),
                                    'segments': segments,
                                    'min_distance': min_dist
                                })
            except Exception:
                continue
        
        # ê±°ë¦¬ê°€ ê°€ê¹Œìš´ ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ìƒìœ„ 2ê°œë§Œ ì„ íƒ
        pipe_lines_candidates.sort(key=lambda x: x['min_distance'])
        pipe_lines = pipe_lines_candidates[:2]
        
        print(f"   ğŸ”§ {sw_type} ê·¼ì²˜ PC ê²€ìƒ‰ ì™„ë£Œ: {len(pipe_lines)}ê°œ ë°œê²¬")
        if sw_type == 'POLYLINE':
            print(f"      SFW ì¤‘ì‹¬ì—ì„œ 7mm ë‚´ ê²€ìƒ‰")
        
    except Exception as e:
        print(f"PIPE ì„  ì°¾ê¸° ì˜¤ë¥˜: {e}")
        pipe_lines = []
    
    return pipe_lines

def check_circle_to_segments_distance(circle_center, circle_radius, segments, min_distance=2.0):
    """ì›ê³¼ ì„ ë¶„ë“¤ ì‚¬ì´ì˜ ìµœì†Œ ê±°ë¦¬ê°€ 2mm ì´í•˜ì¸ì§€ í™•ì¸"""
    for start, end in segments:
        # ì›ì˜ ì¤‘ì‹¬ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬
        dist_to_segment = point_to_segment_distance(circle_center, start, end)
        
        # ì›ì˜ ì™¸ì ‘ì„ ê¹Œì§€ì˜ ê±°ë¦¬ = ì¤‘ì‹¬ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬ - ë°˜ì§€ë¦„
        dist_to_circle = dist_to_segment - circle_radius
        
        if dist_to_circle <= min_distance:
            return True
    
    return False

def check_interference_at_position(test_center, msp, exclude_entities, weld_radius=3.0):
    """íŠ¹ì • ìœ„ì¹˜ì—ì„œì˜ ê°„ì„­ì„ ì²´í¬í•˜ëŠ” í•¨ìˆ˜"""
    for e in msp:
        if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
            continue
        
        if e.dxftype() == "TEXT":
            # ì›ê³¼ í…ìŠ¤íŠ¸ ê°„ì˜ ê±°ë¦¬ ì²´í¬ (ë‹¨ìˆœ ê±°ë¦¬)
            text_pos = Vec2(e.dxf.insert.x, e.dxf.insert.y)
            if distance(test_center, text_pos) < weld_radius:
                return True
                
        elif e.dxftype() in ("POLYLINE", "LWPOLYLINE"):
            if e.dxftype() == "POLYLINE":
                pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
            else:
                pts = [Vec2(x, y) for x, y, *_ in e.get_points()]
            
            for i in range(len(pts) - 1):
                if point_to_segment_distance(test_center, pts[i], pts[i+1]) < weld_radius:
                    return True
                    
        elif e.dxftype() == "CIRCLE":
            circle_center = Vec2(e.dxf.center.x, e.dxf.center.y)
            if distance(circle_center, test_center) < (e.dxf.radius + weld_radius):
                return True
    
    return False

def check_text_interference_only(test_center, msp, exclude_entities, weld_radius=3.0):
    """TEXTì™€ì˜ ê°„ì„­ë§Œ ì²´í¬í•˜ëŠ” í•¨ìˆ˜ (ì› ì¤‘ì‹¬ê³¼ í…ìŠ¤íŠ¸ì˜ ê±°ë¦¬)"""
    for e in msp:
        if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
            continue
        
        if e.dxftype() == "TEXT":
            text_pos = Vec2(e.dxf.insert.x, e.dxf.insert.y)
            if distance(test_center, text_pos) < weld_radius:
                return True
    
    return False

### WELDNOEDIT ê¸°ëŠ¥ ###
def is_overlap_and_text(center: Vec2, msp, exclude_entities, weld_radius=3.0):
    overlap = False
    is_text = False
    for e in msp:
        if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
            continue
        if e.dxftype() == "TEXT":
            p = Vec2(e.dxf.insert.x, e.dxf.insert.y)
            if distance(p, center) < weld_radius:
                overlap = True
                is_text = True
        elif e.dxftype() in ("POLYLINE", "LWPOLYLINE"):
            if e.dxftype() == "POLYLINE":
                pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
            else:
                pts = [Vec2(x, y) for x, y, *_ in e.get_points()]
            for i in range(len(pts) - 1):
                if point_to_segment_distance(center, pts[i], pts[i+1]) < weld_radius:
                    overlap = True
                    break
    return overlap, is_text

def process_weldnoedit(doc):
    msp = doc.modelspace()
    tolerance_touch = 0.2
    min_sl1_length = 14
    target_distance = 5
    text_search_radius = 6
    weld_radius = 2.8
    min_seg_len = 4.5
    max_seg_len = 6.0
    cicle_len = 5.6
    offset_len = cicle_len / 2

    weld_blocks = []
    moved = 0
    weld_results = []
    sl1_to_delete = []

    for poly in msp.query("POLYLINE LWPOLYLINE"):
        if poly.dxftype() == "POLYLINE":
            if len(poly.vertices) != 3:
                continue
            has_curve = any(v.dxf.bulge != 0 for v in poly.vertices)
            pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
        else:
            pts = [Vec2(x, y) for x, y, *_ in poly.get_points()]
            if len(pts) != 3:
                continue
            has_curve = any(b != 0 for (*_, b) in poly.get_points())
        if not has_curve:
            continue
        if not any(min_seg_len <= distance(pts[i], pts[i + 1]) <= max_seg_len for i in range(2)):
            continue
        center = Vec2(sum(p.x for p in pts)/3, sum(p.y for p in pts)/3)
        
        text_search_radius = 4
        closest_txt = None
        closest_dist = float('inf')
        for txt in msp.query("TEXT"):
            try:
                # í…ìŠ¤íŠ¸ ì—”í‹°í‹°ê°€ WDNOë¡œ ìœ íš¨í•œì§€ í™•ì¸ (ë‚´ìš© + ê¸°ìš¸ê¸°)
                if not is_valid_wdno_entity(txt):
                    continue
                
                pos = Vec2(txt.dxf.insert.x, txt.dxf.insert.y)
                d = distance(pos, center)
                if d <= text_search_radius and d < closest_dist:
                    closest_txt = txt
                    closest_dist = d
            except:
                continue
        texts = []
        if closest_txt is not None:
            closest_txt.dxf.color = 1
            texts.append(closest_txt)
        poly.dxf.color = 1
        weld_blocks.append({"poly": poly, "texts": texts, "center": center})

    for weld in weld_blocks:
        weld_poly = weld["poly"]
        weld_center = weld["center"]
        weld_texts = weld["texts"]

        if weld_poly.dxftype() == "POLYLINE":
            weld_points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in weld_poly.vertices]
        else:
            weld_points = [Vec2(x, y) for x, y, *_ in weld_poly.get_points()]

        for sl1 in list(msp.query("POLYLINE LWPOLYLINE")):
            if sl1 is weld_poly:
                continue
            if sl1.dxftype() == "POLYLINE":
                sl1_pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in sl1.vertices]
            else:
                sl1_pts = [Vec2(x, y) for x, y, *_ in sl1.get_points()]
            if len(sl1_pts) < 2:
                continue
            start, end = sl1_pts[0], sl1_pts[-1]
            sl1_len = distance(start, end)
            if any(distance(start, wp) <= tolerance_touch for wp in weld_points):
                sp1_idx, sp1, sp2 = 0, start, end
            elif any(distance(end, wp) <= tolerance_touch for wp in weld_points):
                sp1_idx, sp1, sp2 = -1, end, start
            else:
                continue

            final_sp2 = sp2
            if sl1_len < min_sl1_length:
                weld_results.append({"sp2": final_sp2, "center": weld_center, "weld_poly": weld_poly})
                sl1_to_delete.append(sl1)
                break

            direction_vec = sp2 - sp1
            direction_vec = direction_vec.normalize() if direction_vec.magnitude != 0 else None
            if direction_vec is None:
                continue

            found, move_vec = False, None
            for r in range(1, 10):
                test_point = sp2 + direction_vec * (-r)
                overlap, is_text = is_overlap_and_text(test_point, msp, [weld_poly, sl1] + weld_texts, weld_radius)
                if not overlap:
                    move_vec = test_point - sp1
                    found = True
                    break
            if not found:
                move_distance = distance(sp1, sp2) - target_distance
                if move_distance <= 0:
                    break
                move_vec = direction_vec * move_distance

            new_sp1 = sp1 + move_vec
            directions = [Vec2(dx, dy) for d in range(3, 11) for dx, dy in [(-d, 0), (d, 0), (0, -d), (0, d)]]
            final_offset = Vec2(0, 0)
            for offset in directions:
                test_center = weld_center + move_vec + offset
                overlap, is_text = is_overlap_and_text(test_center, msp, [weld_poly, sl1] + weld_texts, weld_radius)
                if not overlap:
                    final_offset = offset
                    break
            move_vec += final_offset
            new_sp1 = sp1 + move_vec

            if sl1.dxftype() == "POLYLINE":
                if sp1_idx == 0:
                    sl1.vertices[0].dxf.location = (new_sp1.x, new_sp1.y, 0)
                else:
                    sl1.vertices[-1].dxf.location = (new_sp1.x, new_sp1.y, 0)
            else:
                points = sl1.get_points()
                if sp1_idx == 0:
                    new_points = [(new_sp1.x, new_sp1.y)] + points[1:]
                else:
                    new_points = points[:-1] + [(new_sp1.x, new_sp1.y)]
                sl1.set_points(new_points)

            dx, dy = move_vec.x, move_vec.y
            if weld_poly.dxftype() == "POLYLINE":
                for v in weld_poly.vertices:
                    loc = v.dxf.location
                    v.dxf.location = (loc.x + dx, loc.y + dy, 0)
            else:
                weld_pts = [(x + dx, y + dy) for x, y, *_ in weld_poly.get_points()]
                weld_poly.set_points(weld_pts)
            for txt in weld_texts:
                pos = txt.dxf.insert
                txt.dxf.insert = (pos.x + dx, pos.y + dy, 0)

            sl1.dxf.color = 1
            weld_poly.dxf.color = 1
            for txt in weld_texts:
                txt.dxf.color = 1

            moved += 1
            weld_results.append({"sp2": final_sp2, "center": weld_center + move_vec + final_offset, "weld_poly": weld_poly})
            sl1_to_delete.append(sl1)
            break

    for weld in weld_results:
        sp2 = weld["sp2"]
        poly = weld["weld_poly"]
        center = weld["center"]
        if poly.dxftype() == "POLYLINE":
            pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
        else:
            pts = [Vec2(x, y) for x, y, *_ in poly.get_points()]
        if len(pts) == 3 and sp2 is not None:
            cp = (pts[0] + pts[1]) * 0.5
            vec = sp2 - cp
            if vec.magnitude != 0:
                cp = cp + vec.normalize() * offset_len
            msp.add_line((cp.x, cp.y), (sp2.x, sp2.y), dxfattribs={'color': 1})

    for sl1 in sl1_to_delete:
        try:
            msp.delete_entity(sl1)
        except Exception as ex:
            print(f"SL1 ì‚­ì œ ì˜¤ë¥˜: {ex}")

    for weld in weld_results:
        poly = weld["weld_poly"]
        if poly.dxftype() == "POLYLINE":
            pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
        else:
            pts = [Vec2(x, y) for x, y, *_ in poly.get_points()]
        if len(pts) == 3:
            cp = (pts[0] + pts[1]) * 0.5
            msp.add_circle(center=cp, radius=cicle_len / 2, dxfattribs={"color": 2})
        try:
            msp.delete_entity(poly)
        except Exception as ex:
            print(f"â— WELD ì‚­ì œ ì˜¤ë¥˜: {ex}")

    print(f"ê¸°ì¡´ WELDNOEDIT ì²˜ë¦¬ ì™„ë£Œ (ìˆ˜í‰ í…ìŠ¤íŠ¸ë§Œ ì„ íƒ, INST/TEXT/<ë¬¸ì/ìˆ«ìì—†ìŒ ì œì™¸)")

### WELDSYMBOL ê¸°ëŠ¥ ###
def process_weldsymbol(doc):
    msp = doc.modelspace()
    modified = False
    to_delete = []
    WELDS = []

    for weld in list(msp.query('LWPOLYLINE POLYLINE')):
        points = get_poly_points(weld)
        if len(points) != 7:
            continue
        if is_nearly_same_points(points):
            continue
        too_far = False
        for i in range(6):
            d = distance(points[i][:2], points[i+1][:2])
            if d > 2.0:
                too_far = True
                break
        if too_far:
            continue
        weld_center = midpoint([pt[:2] for pt in points])
        if not is_valid_center(weld_center):
            continue
        length = polyline_length(weld)
        if length < 1 or length > 100:
            continue

        short_plines = []
        for pl in msp.query('LWPOLYLINE POLYLINE LINE'):
            if pl == weld:
                continue
            pts = get_poly_points(pl)
            if len(pts) != 2:
                continue
            if any(distance(pt[:2], wp[:2]) <= 3.0 for pt in pts for wp in points):
                if polyline_length(pl) <= 2.8:
                    short_plines.append(pl)

        main_circle = msp.add_circle(center=weld_center, radius=1, dxfattribs={"color": 2})
        main_circle.dxf.lineweight = 20

        leader_line = None
        for ent in msp.query('LINE'):
            if hasattr(ent.dxf, 'color') and ent.dxf.color == 1:
                p_start = (ent.dxf.start[0], ent.dxf.start[1])
                p_end = (ent.dxf.end[0], ent.dxf.end[1])
                for pt in points:
                    if distance(pt[:2], p_start) <= 1 or distance(pt[:2], p_end) <= 1:
                        leader_line = ent
                        break
            if leader_line:
                break

        WELDS.append({
            "circle": main_circle,
            "leader_line": leader_line
        })

        if hasattr(weld.dxf, 'linetype') and isinstance(weld.dxf.linetype, str):
            if weld.dxf.linetype.upper() == "GT100":
                weld.dxf.linetype = "DOT"

        if hasattr(weld.dxf, 'linetype') and weld.dxf.linetype.upper() == "BYLAYER":
            for r in [0.85, 0.7, 0.55, 0.4, 0.25]:
                inner = msp.add_circle(center=weld_center, radius=r, dxfattribs={"color": 2})
                inner.dxf.lineweight = 20

        main_circle.dxf.layer = "SW" if len(short_plines) >= 5 else "OW"

        red_lines = []
        for ent in msp.query('LINE'):
            if hasattr(ent.dxf, 'color') and ent.dxf.color == 1:
                p_start = (ent.dxf.start[0], ent.dxf.start[1])
                p_end = (ent.dxf.end[0], ent.dxf.end[1])
                for pt in points:
                    if distance(pt[:2], p_start) <= 1 or distance(pt[:2], p_end) <= 1:
                        red_lines.append((ent, p_start, p_end))
                        break

        for line, p1, p2 in red_lines:
            d1 = distance(p1, weld_center)
            d2 = distance(p2, weld_center)
            wp1 = p1 if d1 < d2 else p2
            wp2 = p2 if d1 < d2 else p1
            move_single_point_to(line, weld_center, fixed_point=wp2)
            break

        to_delete.append(weld)
        to_delete.extend(short_plines)
        modified = True

    for ent in to_delete:
        try:
            msp.delete_entity(ent)
        except Exception:
            pass

    print(f"WELDSYMBOL ì ìš© ì™„ë£Œ")

### NL1 ìƒì„± ë° ê±°ë¦¬ ì œì–´ ê¸°ëŠ¥ ###
def find_all_circles_by_radius(msp, target_radius, radius_tolerance=0.1):
    """íŠ¹ì • ë°˜ì§€ë¦„ì˜ ë…¸ë‘ìƒ‰ ì›ë“¤ì„ ëª¨ë‘ ì°¾ëŠ” í•¨ìˆ˜"""
    circles = []
    for entity in msp.query('CIRCLE'):
        try:
            if (hasattr(entity.dxf, 'color') and entity.dxf.color == 2 and  # ë…¸ë‘ìƒ‰
                hasattr(entity.dxf, 'radius') and abs(entity.dxf.radius - target_radius) < radius_tolerance):
                center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                circles.append({
                    'entity': entity,
                    'center': center,
                    'radius': entity.dxf.radius
                })
        except Exception:
            continue
    return circles

def adjust_weld_circle_distance(weld_circle, small_circle, min_distance=6.0, msp=None):
    """WELD ì›ê³¼ SW/SFW ì‚¬ì´ì˜ ì§ì„ ê±°ë¦¬ë¥¼ ì¡°ì •í•˜ëŠ” í•¨ìˆ˜ (ìµœì†Œ 7mm ë³´ì¥)"""
    weld_center = weld_circle['center']
    small_center = small_circle['center']
    weld_radius = weld_circle['radius']  # ì‹¤ì œë¡œëŠ” 2.8mm (5.6mm ì§€ë¦„)
    small_radius = small_circle['radius']  # 1mm
    
    # í˜„ì¬ ì§ì„ ê±°ë¦¬ ê³„ì‚° (ì¤‘ì‹¬ì  ê°„ ê±°ë¦¬)
    current_distance = distance(weld_center, small_center)
    
    print(f"  í˜„ì¬ WELD-SW/SFW ì§ì„ ê±°ë¦¬: {current_distance:.2f}mm")
    print(f"  ìµœì†Œ ìš”êµ¬ ê±°ë¦¬: {min_distance}mm")
    
    # 6mm ì´ìƒì´ë©´ ì¡°ì • ë¶ˆí•„ìš”
    if current_distance >= min_distance:
        print(f"  ê±°ë¦¬ ì¡°ì • ë¶ˆí•„ìš” (ì§ì„ ê±°ë¦¬ {current_distance:.2f}mm >= {min_distance}mm)")
        return True, weld_center, [], "no_adjustment"
    
    # 6mm ë¯¸ë§Œì¸ ê²½ìš° STRETCH
    print(f"  STRETCH í•„ìš”: {current_distance:.2f}mm â†’ {min_distance}mm")
    
    # ë°©í–¥ ë²¡í„° ê³„ì‚° (SW/SFWì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥)
    direction_vec = weld_center - small_center
    if direction_vec.magnitude == 0:
        print(f"  ì›ë“¤ì´ ê°™ì€ ìœ„ì¹˜ì— ìˆì–´ ì¡°ì • ë¶ˆê°€ëŠ¥")
        return False, weld_center, [], "same_position"
    
    direction_normalized = direction_vec.normalize()
    
    # ìƒˆë¡œìš´ WELD ì› ìœ„ì¹˜ ê³„ì‚° (SW/SFWì—ì„œ ì •í™•íˆ min_distance ë–¨ì–´ì§„ ìœ„ì¹˜)
    new_weld_center = small_center + direction_normalized * min_distance
    
    print(f"  WELD ì› ì´ë™ ê³„íš: ({weld_center.x:.2f}, {weld_center.y:.2f}) â†’ ({new_weld_center.x:.2f}, {new_weld_center.y:.2f})")
    
    # WELDNO í…ìŠ¤íŠ¸ë§Œ ì°¾ê¸° (WELD ì› ì£¼ë³€ 3mm ë‚´ì˜ í…ìŠ¤íŠ¸ë§Œ)
    weldno_texts = []
    weldno_text_search_radius = 3.0
    text_backups = []
    
    for txt in msp.query('TEXT'):
        try:
            txt_pos = Vec2(txt.dxf.insert.x, txt.dxf.insert.y)
            if distance(weld_center, txt_pos) <= weldno_text_search_radius:
                # í…ìŠ¤íŠ¸ ì—”í‹°í‹°ê°€ WDNOë¡œ ìœ íš¨í•œì§€ í™•ì¸ (ë‚´ìš© + ê¸°ìš¸ê¸°)
                if is_valid_wdno_entity(txt):
                    # WELDNO ê´€ë ¨ í…ìŠ¤íŠ¸ë§Œ ì´ë™ (ë‹¤ë¥¸ TEXTëŠ” ì ˆëŒ€ ì´ë™í•˜ì§€ ì•ŠìŒ)
                    weldno_texts.append(txt)
                    text_backups.append({
                        'text': txt,
                        'original_pos': (txt.dxf.insert.x, txt.dxf.insert.y, txt.dxf.insert.z if hasattr(txt.dxf.insert, 'z') else 0)
                    })
        except Exception as e:
            continue
    
    print(f"    WELDNO í…ìŠ¤íŠ¸ {len(weldno_texts)}ê°œ ë°œê²¬ (ë‹¤ë¥¸ TEXTëŠ” ì´ë™í•˜ì§€ ì•ŠìŒ)")
    
    # ì›ë˜ WELD ì› ìœ„ì¹˜ ë°±ì—…
    original_weld_center = Vec2(weld_center.x, weld_center.y)
    
    # ìƒˆ ìœ„ì¹˜ì—ì„œ ê°„ì„­ ì²´í¬
    exclude_entities = [weld_circle['entity'], small_circle['entity']] + weldno_texts
    if check_interference_at_position(new_weld_center, msp, exclude_entities, weld_radius):
        print(f"  ìƒˆ ìœ„ì¹˜ì—ì„œ ê°„ì„­ ë°œìƒ")
        
        # SFWì¸ ê²½ìš° ìµœì†Œ 7mm ìœ„ì¹˜ ì‹œë„
        if hasattr(small_circle['entity'], 'dxftype') and small_circle['entity'].dxftype() in ['POLYLINE', 'LWPOLYLINE']:
            print(f"  SFW í´ë¦¬ë¼ì¸ ê°ì§€ - ìµœì†Œ 7mm ìœ„ì¹˜ ì‹œë„")
            min_7mm_center = small_center + direction_normalized * 7.0
            
            # 7mm ìœ„ì¹˜ì—ì„œ ê°„ì„­ ì²´í¬
            if not check_interference_at_position(min_7mm_center, msp, exclude_entities, weld_radius):
                new_weld_center = min_7mm_center
                print(f"  7mm ìœ„ì¹˜ë¡œ ì¡°ì •: ({new_weld_center.x:.2f}, {new_weld_center.y:.2f})")
            else:
                print(f"  7mm ìœ„ì¹˜ì—ì„œë„ ê°„ì„­ - ì¡°ì • ì‹¤íŒ¨, ì›ë˜ ìœ„ì¹˜ ìœ ì§€")
                return False, weld_center, [], "stretch_interference"
        else:
            print(f"  ì¡°ì • ì‹¤íŒ¨ - ì›ë˜ ìœ„ì¹˜ ìœ ì§€")
            return False, weld_center, [], "stretch_interference"
    
    # ë‹¤ë¥¸ ì›ë“¤ê³¼ì˜ ê±°ë¦¬ ì²´í¬ (ìµœì†Œ 6mm ì§ì„ ê±°ë¦¬)
    all_circles = []
    for entity in msp.query('CIRCLE'):
        try:
            if (hasattr(entity.dxf, 'color') and entity.dxf.color == 2 and
                entity != weld_circle['entity']):
                circle_center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                all_circles.append({
                    'entity': entity,
                    'center': circle_center,
                    'radius': entity.dxf.radius
                })
        except Exception as e:
            continue
    
    # ë‹¤ë¥¸ ì›ë“¤ê³¼ì˜ ìµœì†Œ ê±°ë¦¬ ì²´í¬
    for other_circle in all_circles:
        other_center = other_circle['center']
        dist_between_centers = distance(new_weld_center, other_center)
        
        if dist_between_centers < 6.0:  # ì›ë“¤ ê°„ ìµœì†Œ ê±°ë¦¬ëŠ” 6mm
            print(f"    ë‹¤ë¥¸ ì›ê³¼ì˜ ê±°ë¦¬ ìœ„ë°˜: {dist_between_centers:.2f}mm < 6.0mm")
            
            # SFWì¸ ê²½ìš° ìµœì†Œ 7mm ìœ„ì¹˜ ì‹œë„
            if hasattr(small_circle['entity'], 'dxftype') and small_circle['entity'].dxftype() in ['POLYLINE', 'LWPOLYLINE']:
                min_7mm_center = small_center + direction_normalized * 7.0
                dist_to_other_from_7mm = distance(min_7mm_center, other_center)
                
                if dist_to_other_from_7mm >= 6.0:
                    new_weld_center = min_7mm_center
                    print(f"  7mm ìœ„ì¹˜ë¡œ ì¡°ì •í•˜ì—¬ ë‹¤ë¥¸ ì›ê³¼ì˜ ì¶©ëŒ íšŒí”¼")
                else:
                    print(f"    ì¡°ì • ì‹¤íŒ¨ - ë‹¤ë¥¸ ì›ê³¼ ì¶©ëŒ, ì›ë˜ ìœ„ì¹˜ ìœ ì§€")
                    return False, weld_center, [], "stretch_circle_collision"
            else:
                print(f"    ì¡°ì • ì‹¤íŒ¨ - ë‹¤ë¥¸ ì›ê³¼ ì¶©ëŒ, ì›ë˜ ìœ„ì¹˜ ìœ ì§€")
                return False, weld_center, [], "stretch_circle_collision"
    
    # WELD ì› ë° WELDNO í…ìŠ¤íŠ¸ë§Œ ì´ë™
    try:
        move_vec = new_weld_center - weld_center
        
        # WELD ì› ì´ë™
        weld_circle['entity'].dxf.center = (new_weld_center.x, new_weld_center.y, 0)
        
        # WELDNO í…ìŠ¤íŠ¸ë“¤ë§Œ í•¨ê»˜ ì´ë™ (ë‹¤ë¥¸ TEXTëŠ” ì ˆëŒ€ ì´ë™í•˜ì§€ ì•ŠìŒ)
        for txt in weldno_texts:
            try:
                old_pos = txt.dxf.insert
                new_pos = (old_pos.x + move_vec.x, old_pos.y + move_vec.y, old_pos.z if hasattr(old_pos, 'z') else 0)
                txt.dxf.insert = new_pos
            except Exception as e:
                print(f"    WELDNO í…ìŠ¤íŠ¸ ì´ë™ ì˜¤ë¥˜: {e}")
        
        final_distance = distance(new_weld_center, small_center)
        print(f"  WELD ì› STRETCH ì„±ê³µ: ìµœì¢… ì§ì„ ê±°ë¦¬ {final_distance:.2f}mm")
        print(f"    WELDNO í…ìŠ¤íŠ¸ {len(weldno_texts)}ê°œë§Œ í•¨ê»˜ ì´ë™ ì™„ë£Œ (ë‹¤ë¥¸ TEXTëŠ” ë³´í˜¸ë¨)")
        
        return True, new_weld_center, weldno_texts, "stretch"
        
    except Exception as e:
        print(f"  WELD ì› STRETCH ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
        
        # ì˜¤ë¥˜ ë°œìƒ ì‹œ ì›ë˜ ìœ„ì¹˜ë¡œ ë³µêµ¬
        try:
            weld_circle['entity'].dxf.center = (original_weld_center.x, original_weld_center.y, 0)
            weld_circle['center'] = original_weld_center
            for backup in text_backups:
                backup['text'].dxf.insert = backup['original_pos']
            print(f"    ì˜¤ë¥˜ë¡œ ì¸í•œ ì›ë˜ ìœ„ì¹˜ ë³µêµ¬ ì™„ë£Œ")
        except Exception as restore_e:
            print(f"    ë³µêµ¬ ì¤‘ ì˜¤ë¥˜: {restore_e}")
        
        return False, weld_center, [], "stretch_error"

def ensure_minimum_distances_between_all_circles(msp, min_distance=6.0):
    """ëª¨ë“  ë…¸ë‘ìƒ‰ ì›ë“¤ ê°„ì˜ ìµœì†Œ 6mm ì§ì„ ê±°ë¦¬ë¥¼ ë³´ì¥í•˜ëŠ” í•¨ìˆ˜ - WELD ì›ë§Œ ì´ë™, WELDNO í…ìŠ¤íŠ¸ë§Œ í•¨ê»˜ ì´ë™"""
    print(f"\nğŸ” ëª¨ë“  ì› ê°„ ìµœì†Œ {min_distance}mm ì§ì„ ê±°ë¦¬ ë³´ì¥ ì‹œì‘")
    
    # ëª¨ë“  ë…¸ë‘ìƒ‰ ì›ë“¤ ì°¾ê¸°
    all_circles = []
    for entity in msp.query('CIRCLE'):
        try:
            if hasattr(entity.dxf, 'color') and entity.dxf.color == 2:  # ë…¸ë‘ìƒ‰
                center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                all_circles.append({
                    'entity': entity,
                    'center': center,
                    'radius': entity.dxf.radius
                })
        except Exception:
            continue
    
    print(f"  ë…¸ë‘ìƒ‰ ì› ì´ {len(all_circles)}ê°œ ë°œê²¬")
    
    adjustment_count = 0
    
    # ëª¨ë“  ì› ìŒì— ëŒ€í•´ ê±°ë¦¬ ì²´í¬
    for i in range(len(all_circles)):
        for j in range(i + 1, len(all_circles)):
            circle1 = all_circles[i]
            circle2 = all_circles[j]
            
            center1 = circle1['center']
            center2 = circle2['center']
            current_distance = distance(center1, center2)
            
            if current_distance < min_distance:
                print(f"  ì›ê°„ ì§ì„ ê±°ë¦¬ ìœ„ë°˜: {current_distance:.2f}mm < {min_distance}mm")
                print(f"    ì›1: ({center1.x:.2f}, {center1.y:.2f}, R={circle1['radius']:.1f})")
                print(f"    ì›2: ({center2.x:.2f}, {center2.y:.2f}, R={circle2['radius']:.1f})")
                
                # WELD ì›(2.8mm ë°˜ì§€ë¦„)ë§Œ ì´ë™ ê°€ëŠ¥, ë‹¤ë¥¸ ëª¨ë“  ì›ì€ ê³ ì •
                moving_circle = None
                fixed_circle = None
                
                # WELD ì›(2.8mm)ë§Œ ì´ë™ ëŒ€ìƒìœ¼ë¡œ ì„ íƒ
                if abs(circle1['radius'] - 2.8) <= 0.3 and abs(circle2['radius'] - 2.8) > 0.3:
                    moving_circle = circle1
                    fixed_circle = circle2
                elif abs(circle2['radius'] - 2.8) <= 0.3 and abs(circle1['radius'] - 2.8) > 0.3:
                    moving_circle = circle2
                    fixed_circle = circle1
                elif abs(circle1['radius'] - 2.8) <= 0.3 and abs(circle2['radius'] - 2.8) <= 0.3:
                    moving_circle = circle1
                    fixed_circle = circle2
                else:
                    print(f"    WELD ì›ì´ ì—†ìœ¼ë¯€ë¡œ ì´ë™í•˜ì§€ ì•ŠìŒ")
                    continue
                
                if moving_circle is None:
                    continue
                
                print(f"    ì´ë™ ëŒ€ìƒ: R={moving_circle['radius']:.1f}mm WELD ì›")
                
                # ì´ë™ ë°©í–¥ ê³„ì‚°
                direction_vec = moving_circle['center'] - fixed_circle['center']
                if direction_vec.magnitude == 0:
                    continue
                
                direction_normalized = direction_vec.normalize()
                new_center = fixed_circle['center'] + direction_normalized * min_distance
                
                # WELDNO í…ìŠ¤íŠ¸ë§Œ ì°¾ê¸° (ë‹¤ë¥¸ TEXTëŠ” ì ˆëŒ€ ì´ë™í•˜ì§€ ì•ŠìŒ)
                weldno_texts = []
                weldno_text_search_radius = 3.0
                for txt in msp.query('TEXT'):
                    try:
                        txt_pos = Vec2(txt.dxf.insert.x, txt.dxf.insert.y)
                        if distance(moving_circle['center'], txt_pos) <= weldno_text_search_radius:
                            # í…ìŠ¤íŠ¸ ì—”í‹°í‹°ê°€ WDNOë¡œ ìœ íš¨í•œì§€ í™•ì¸ (ë‚´ìš© + ê¸°ìš¸ê¸°)
                            if is_valid_wdno_entity(txt):
                                weldno_texts.append(txt)
                    except Exception as e:
                        continue
                
                # ê°„ì„­ ì²´í¬
                exclude_entities = [circle1['entity'], circle2['entity']] + weldno_texts
                if not check_interference_at_position(new_center, msp, exclude_entities, moving_circle['radius']):
                    try:
                        move_vec = new_center - moving_circle['center']
                        
                        # WELD ì› ì´ë™
                        moving_circle['entity'].dxf.center = (new_center.x, new_center.y, 0)
                        moving_circle['center'] = new_center
                        
                        # WELDNO í…ìŠ¤íŠ¸ë“¤ë§Œ í•¨ê»˜ ì´ë™
                        for txt in weldno_texts:
                            try:
                                old_pos = txt.dxf.insert
                                new_pos = (old_pos.x + move_vec.x, old_pos.y + move_vec.y, old_pos.z if hasattr(old_pos, 'z') else 0)
                                txt.dxf.insert = new_pos
                            except Exception as e:
                                print(f"    WELDNO í…ìŠ¤íŠ¸ ì´ë™ ì˜¤ë¥˜: {e}")
                        
                        adjustment_count += 1
                        print(f"    WELD ì› ì¡°ì • ì™„ë£Œ: ({new_center.x:.2f}, {new_center.y:.2f})ë¡œ ì´ë™")
                        if weldno_texts:
                            print(f"    WELDNO í…ìŠ¤íŠ¸ {len(weldno_texts)}ê°œë§Œ í•¨ê»˜ ì´ë™ (ë‹¤ë¥¸ TEXTëŠ” ë³´í˜¸ë¨)")
                    except Exception as e:
                        print(f"    ì¡°ì • ì‹¤íŒ¨: {e}")
                else:
                    print(f"    ì¡°ì • ë¶ˆê°€: ìƒˆ ìœ„ì¹˜ì—ì„œ ê°„ì„­ ë°œìƒ")
    
    print(f"ì›ê°„ ê±°ë¦¬ ì¡°ì • ì™„ë£Œ: {adjustment_count}ê°œ WELD ì› ì¡°ì •ë¨ (WELDNO í…ìŠ¤íŠ¸ë§Œ ì´ë™)")

def find_closest_yellow_circles_to_weld_circles(msp, radius_tolerance=0.1):
    """WELDNO ê·¸ë£¹ ì•ˆì˜ RED LINE ëì ì—ì„œ 1.5mm ë‚´ ë…¸ë‘ìƒ‰ 1mm ì› ë˜ëŠ” SFW 6ì  í´ë¦¬ë¼ì¸ ì°¾ê¸°"""
    connections = []
    
    try:
        # WELD ì›ë“¤ ì°¾ê¸° (2.8mm ë°˜ì§€ë¦„)
        weld_circles = find_all_circles_by_radius(msp, 2.8, radius_tolerance)
        print(f"ğŸ” WELD ì› {len(weld_circles)}ê°œ ë°œê²¬ (ë°˜ì§€ë¦„ 2.8mm):")
        for i, weld_circle in enumerate(weld_circles):
            print(f"   {i+1}. ìœ„ì¹˜: ({weld_circle['center'].x:.2f}, {weld_circle['center'].y:.2f}), ë°˜ì§€ë¦„: {weld_circle['radius']:.3f}mm")
        
        # ëª¨ë“  ë…¸ë‘ìƒ‰ 1mm ì›ë“¤ ì°¾ê¸°
        small_circles = find_all_circles_by_radius(msp, 1.0, radius_tolerance)
        print(f"ğŸŸ¡ ë…¸ë‘ìƒ‰ 1mm ì› {len(small_circles)}ê°œ ë°œê²¬")
        
        # ëª¨ë“  SFW 6ì  í´ë¦¬ë¼ì¸ ì°¾ê¸°
        sfw_polylines = []
        for poly in msp.query("POLYLINE LWPOLYLINE"):
            try:
                if hasattr(poly.dxf, 'layer') and poly.dxf.layer == "SFW":
                    # ì ë“¤ ê°€ì ¸ì˜¤ê¸°
                    if poly.dxftype() == "POLYLINE":
                        points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                    else:
                        points = [Vec2(x, y) for x, y, *_ in poly.get_points()]
                    
                    # 6ê°œ ì ì¸ì§€ í™•ì¸
                    if len(points) == 6:
                        # ì¤‘ì‹¬ì  ê³„ì‚°
                        center_x = sum(p.x for p in points) / 6
                        center_y = sum(p.y for p in points) / 6
                        center = Vec2(center_x, center_y)
                        
                        sfw_polylines.append({
                            'entity': poly,
                            'center': center,
                            'points': points,
                            'type': 'SFW'
                        })
            except Exception:
                continue
        
        print(f"ğŸ”· SFW 6ì  í´ë¦¬ë¼ì¸ {len(sfw_polylines)}ê°œ ë°œê²¬")
        
        # SW ì›ë“¤ì„ í†µí•© ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
        all_sw_sfw = []
        for circle in small_circles:
            all_sw_sfw.append({
                'entity': circle['entity'],
                'center': circle['center'],
                'radius': circle['radius'],
                'type': 'SW'
            })
        
        # SFW í´ë¦¬ë¼ì¸ë“¤ì„ í†µí•© ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
        for sfw in sfw_polylines:
            all_sw_sfw.append({
                'entity': sfw['entity'],
                'center': sfw['center'],
                'radius': 1.0,  # SFWë¥¼ 1mm ì›ì²˜ëŸ¼ ì·¨ê¸‰
                'type': 'SFW'
            })
        
        # ê° WELD ì›ì„ WELDNOë¡œ ê°„ì£¼í•˜ê³  1ê°œì˜ NL1ë§Œ ìƒì„±
        for weld_circle in weld_circles:
            weld_center = weld_circle['center']
            weld_group_radius = 4.0  # WELD ì£¼ë³€ 4mm ë‚´ì˜ RED LINEë“¤ë§Œ ëŒ€ìƒ
            
            print(f"ğŸ” WELDNO({weld_center.x:.2f}, {weld_center.y:.2f}) ì²˜ë¦¬ ì¤‘...")
            
            # WELD ì£¼ë³€ 4mm ë‚´ì˜ RED LINEë“¤ ì°¾ê¸°
            red_line_endpoints = []
            
            # RED LINE ì°¾ê¸°
            for entity in msp.query('LINE'):
                try:
                    if hasattr(entity.dxf, 'color') and entity.dxf.color == 1:  # ë¹¨ê°„ìƒ‰
                        start_point = Vec2(entity.dxf.start.x, entity.dxf.start.y)
                        end_point = Vec2(entity.dxf.end.x, entity.dxf.end.y)
                        
                        # WELD 4mm ë‚´ì— ìˆëŠ” LINEì¸ì§€ í™•ì¸
                        if (distance(weld_center, start_point) <= weld_group_radius or 
                            distance(weld_center, end_point) <= weld_group_radius):
                            red_line_endpoints.extend([start_point, end_point])
                except Exception as e:
                    continue
            
            # RED POLYLINE/LWPOLYLINE ì°¾ê¸°
            for poly in msp.query("POLYLINE LWPOLYLINE"):
                try:
                    if hasattr(poly.dxf, 'color') and poly.dxf.color == 1:  # ë¹¨ê°„ìƒ‰
                        if poly.dxftype() == "POLYLINE":
                            poly_points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                        else:
                            poly_points = [Vec2(x, y) for x, y, *_ in poly.get_points()]
                        
                        # WELD 4mm ë‚´ì— ìˆëŠ” í´ë¦¬ë¼ì¸ì¸ì§€ í™•ì¸
                        near_weld = False
                        for point in poly_points:
                            if distance(weld_center, point) <= weld_group_radius:
                                near_weld = True
                                break
                        
                        if near_weld and len(poly_points) >= 2:
                            # í´ë¦¬ë¼ì¸ì˜ ì‹œì‘ì ê³¼ ëì ì„ ëì ìœ¼ë¡œ ê°„ì£¼
                            red_line_endpoints.extend([poly_points[0], poly_points[-1]])
                except Exception as e:
                    continue
            
            print(f"   WELD 4mm ë‚´ RED LINE ëì  {len(red_line_endpoints)}ê°œ ë°œê²¬")
            
            if not red_line_endpoints:
                print(f"   WELDNO ê·¸ë£¹ì—ì„œ RED LINEì„ ì°¾ì„ ìˆ˜ ì—†ìŒ - SKIP")
                continue
            
            # ëª¨ë“  RED LINE ëì ì—ì„œ 1.5mm ë‚´ì˜ SW/SFW ì°¾ê¸°
            valid_connections = []
            endpoint_search_radius = 1.5  # RED LINE ëì ì—ì„œ 1.5mm ë‚´
            
            for endpoint in red_line_endpoints:
                for sw_sfw in all_sw_sfw:
                    try:
                        center = sw_sfw['center']
                        dist = distance(endpoint, center)
                        
                        # 1.5mm ë‚´ì— ìˆëŠ” ê²½ìš°ë§Œ ìœ íš¨í•œ ì—°ê²°ë¡œ ê°„ì£¼
                        if dist <= endpoint_search_radius:
                            valid_connections.append({
                                'weld_circle': weld_circle,
                                'small_circle': sw_sfw,  # SW ì› ë˜ëŠ” SFW í´ë¦¬ë¼ì¸
                                'red_line_endpoint': endpoint,
                                'endpoint_to_small_distance': dist,
                                'weld_to_small_distance': distance(weld_center, center),
                                'sw_type': sw_sfw['type']  # 'SW' ë˜ëŠ” 'SFW'
                            })
                            print(f"     ìœ íš¨ ì—°ê²°: REDëì ({endpoint.x:.2f}, {endpoint.y:.2f}) - {sw_sfw['type']}({center.x:.2f}, {center.y:.2f}), ê±°ë¦¬: {dist:.3f}mm")
                    except Exception as e:
                        continue
            
            print(f"   1.5mm ë‚´ ìœ íš¨ ì—°ê²° {len(valid_connections)}ê°œ ë°œê²¬")
            
            if not valid_connections:
                print(f"   RED LINE ëì  1.5mm ë‚´ì— SW/SFWê°€ ì—†ìŒ - SKIP")
                continue
            
            # ê°€ì¥ ê°€ê¹Œìš´ ì—°ê²° ì„ íƒ (WELDNOë‹¹ 1ê°œë§Œ)
            best_connection = min(valid_connections, key=lambda x: x['endpoint_to_small_distance'])
            connections.append(best_connection)
            
            endpoint = best_connection['red_line_endpoint']
            small_center = best_connection['small_circle']['center']
            sw_type = best_connection['sw_type']
            
            print(f"âœ… WELDNO ì—°ê²°: WELDì›({weld_center.x:.2f}, {weld_center.y:.2f}) - REDëì ({endpoint.x:.2f}, {endpoint.y:.2f}) - {sw_type}({small_center.x:.2f}, {small_center.y:.2f})")
            print(f"    ê±°ë¦¬: REDëì â†’{sw_type} {best_connection['endpoint_to_small_distance']:.3f}mm, WELDâ†’{sw_type} {best_connection['weld_to_small_distance']:.3f}mm")
        
        print(f"ğŸ“ ìµœì¢… ê²°ê³¼: WELDNOë³„ NL1 ì—°ê²° {len(connections)}ê°œ (ê° WELDNOë‹¹ 1ê°œ, 1.5mm ë‚´ë§Œ)")
        return connections
        
    except Exception as e:
        print(f"âŒ í•¨ìˆ˜ ì „ì²´ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
        return []

def process_nl1_distance_control(doc):
    """WELDSYMBOL ì™„ë£Œ í›„ NL1 ìƒì„± ë° 6mm ì§ì„ ê±°ë¦¬ ì œì–´"""
    msp = doc.modelspace()
    
    # ê±°ë¦¬ ì œì–´ íŒŒë¼ë¯¸í„°
    min_distance = 6.0  # ìµœì†Œ ì§ì„ ê±°ë¦¬ 6mm
    weld_radius = 2.8   # WELD ì› ë°˜ì§€ë¦„ (5.6mm ì§€ë¦„)
    
    print("\n[3ë‹¨ê³„] NL1 ìƒì„± ë° 6mm ì§ì„ ê±°ë¦¬ ì œì–´ ì‹œì‘")
    
    try:
        # WELDNO ê·¸ë£¹ì—ì„œ WELDë¡œë¶€í„° ë¨¼ ì  ê·¼ì²˜ 1mm ì›ì„ ì°¾ì•„ ì—°ê²°
        connections = find_closest_yellow_circles_to_weld_circles(msp)
        print(f"WELDNO ê·¸ë£¹ë³„ ì—°ê²° {len(connections)}ê°œ ë°œê²¬")
        
        if not connections:
            print("WELDNO ê·¸ë£¹ì—ì„œ ì—°ê²°í•  1mm ì›ì´ ì—†ìŠµë‹ˆë‹¤.")
            return

        print(f"ğŸ“Š ì²˜ë¦¬í•  ì—°ê²° ê°œìˆ˜: {len(connections)}ê°œ")
        
        nl1_created_count = 0
        stretch_count = 0
        nl1_weld_pairs = []  # NL1ê³¼ ì—°ê²°ëœ WELD ì›ë“¤ ì¶”ì 
        
        # ê° ì—°ê²°ì— ëŒ€í•´ ê±°ë¦¬ ì œì–´ ë° STRETCH ìˆ˜í–‰
        for i, connection in enumerate(connections):
            print(f"\nğŸ”§ [{i+1}/{len(connections)}] ì—°ê²° ì²˜ë¦¬ ì¤‘...")
            
            try:
                weld_circle = connection['weld_circle']
                small_circle = connection['small_circle']
                weld_center = weld_circle['center']
                small_center = small_circle['center']
                red_endpoint = connection['red_line_endpoint']
                current_distance = connection['weld_to_small_distance']
                
                print(f"ğŸ” ì—°ê²° ì²˜ë¦¬: WELDì›({weld_center.x:.2f}, {weld_center.y:.2f}) - REDëì ({red_endpoint.x:.2f}, {red_endpoint.y:.2f}) - {connection.get('sw_type', 'SW')}({small_center.x:.2f}, {small_center.y:.2f})")
                print(f"   í˜„ì¬ WELD-{connection.get('sw_type', 'SW')} ì§ì„ ê±°ë¦¬: {current_distance:.2f}mm")
                
                # 6mm ì´í•˜ì¸ ê²½ìš°ë§Œ STRETCH
                if current_distance <= min_distance:
                    if abs(current_distance - min_distance) < 0.1:
                        print(f"   âœ… ì´ë¯¸ 6mm: ì¡°ì • ë¶ˆí•„ìš” (í˜„ì¬ {current_distance:.2f}mm)")
                        moved_texts = []
                    else:
                        print(f"   âš ï¸  ì§ì„ ê±°ë¦¬ {current_distance:.2f}mm <= {min_distance}mm: WELD ì› STRETCH í•„ìš”")
                        
                        adjust_success, new_weld_center, moved_texts, action_type = adjust_weld_circle_distance(
                            weld_circle, small_circle, min_distance, msp
                        )
                        
                        if adjust_success:
                            weld_center = new_weld_center
                            stretch_count += 1
                            print(f"   âœ… WELD ì› STRETCH ì„±ê³µ")
                            
                            # WELD ì›ì´ ì´ë™í–ˆìœ¼ë¯€ë¡œ weld_circle ì •ë³´ ì—…ë°ì´íŠ¸
                            weld_circle['center'] = new_weld_center
                        else:
                            print(f"   âŒ WELD ì› STRETCH ì‹¤íŒ¨ - ì›ë˜ ìœ„ì¹˜ ìœ ì§€")
                            moved_texts = []
                else:
                    print(f"   âœ… ì§ì„ ê±°ë¦¬ OK: {current_distance:.2f}mm > {min_distance}mm (STRETCH ë¶ˆí•„ìš”)")
                    moved_texts = []  # ì¡°ì •í•˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ì´ë™ëœ í…ìŠ¤íŠ¸ ì—†ìŒ
                
                # NL1 í°ìƒ‰ ì„  ìƒì„± (ì´ë™ëœ WELD ì›ê³¼ 1mm ì› ì‚¬ì´ì— ìƒˆë¡œ ê·¸ë¦¬ê¸°)
                nl1_line = msp.add_line(
                    start=(weld_center.x, weld_center.y),
                    end=(small_center.x, small_center.y),
                    dxfattribs={'color': 4}  # í°ìƒ‰
                )
                
                final_distance = distance(weld_center, small_center)
                print(f"   NL1 ìƒì„±: WELDì›({weld_center.x:.2f}, {weld_center.y:.2f}) - 1mmì›({small_center.x:.2f}, {small_center.y:.2f})")
                print(f"   ìµœì¢… ì§ì„ ê±°ë¦¬: {final_distance:.2f}mm")
                
                # WELD ì›(5.6mm ì§€ë¦„)ê³¼ ì ‘í•˜ë„ë¡ NL1 TRIM ì²˜ë¦¬
                try:
                    weld_entity = weld_circle['entity']
                    weld_center_pos = Vec2(weld_entity.dxf.center.x, weld_entity.dxf.center.y)
                    weld_radius_val = weld_entity.dxf.radius  # 2.8mm
                    
                    # NL1ê³¼ WELD ì›ì˜ êµì°¨ì  ê³„ì‚°
                    line_start = Vec2(nl1_line.dxf.start.x, nl1_line.dxf.start.y)
                    line_end = Vec2(nl1_line.dxf.end.x, nl1_line.dxf.end.y)
                    
                    # WELD ì› ì¤‘ì‹¬ì—ì„œ 1mm ì› ë°©í–¥ìœ¼ë¡œì˜ ë²¡í„°
                    direction_to_small = line_end - line_start
                    if direction_to_small.magnitude > 0:
                        direction_normalized = direction_to_small.normalize()
                        # WELD ì› ê²½ê³„ì  ê³„ì‚° (5.6mm ì›ê³¼ ì ‘í•˜ê²Œ)
                        trim_start = weld_center_pos + direction_normalized * weld_radius_val
                        
                        # NL1ì„ WELD ì› ê²½ê³„ì—ì„œ ì‹œì‘í•˜ë„ë¡ TRIM
                        nl1_line.dxf.start = (trim_start.x, trim_start.y, 0)
                        
                        # NL1 ê¸¸ì´ ê³„ì‚°
                        nl1_length = distance(trim_start, Vec2(small_center.x, small_center.y))
                        print(f"   WELD ì›(5.6mm)ê³¼ ì ‘ì´‰: NL1ì´ ({trim_start.x:.2f}, {trim_start.y:.2f})ì—ì„œ ì‹œì‘")
                        print(f"   NL1 ê¸¸ì´: {nl1_length:.2f}mm")
                    else:
                        print(f"   âš ï¸  WELD ì›ê³¼ 1mm ì›ì´ ê°™ì€ ìœ„ì¹˜ì— ìˆì–´ TRIM ë¶ˆê°€")
                except Exception as trim_e:
                    print(f"   âŒ WELD ì› ì ‘ì´‰ TRIM ì¤‘ ì˜¤ë¥˜: {trim_e}")
                
                # NL1ê³¼ WELD ì› ìŒ ì €ì¥ (ì„±ê³µì ìœ¼ë¡œ ìƒì„±ëœ ê²½ìš°)
                nl1_weld_pairs.append({
                    'nl1_line': nl1_line,
                    'weld_circle': weld_circle,
                    'small_circle': small_circle,
                    'connection': connection
                })
                
                nl1_created_count += 1
                print(f"   âœ… NL1 ìƒì„± ì„±ê³µ: WELD ì›ê³¼ í•¨ê»˜ STRETCHë˜ì–´ í•­ìƒ 5.6mm ì›ê³¼ ì ‘í•¨")
                
            except Exception as e:
                print(f"âŒ ì—°ê²° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
                continue

        # ëª¨ë“  WELD ê·¸ë£¹ì˜ RED ìš”ì†Œë“¤ ì‚­ì œ (NL1 ìƒì„± ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´)
        print(f"\nğŸ—‘ï¸  ëª¨ë“  WELD ê·¸ë£¹ì˜ RED ìš”ì†Œ ì‚­ì œ ì‹œì‘ (NL1 ìƒì„± ì—¬ë¶€ ë¬´ê´€)")
        
        red_lines_to_delete = []
        
        # ëª¨ë“  WELD ì› ì°¾ê¸° (2.8mm ë°˜ì§€ë¦„)
        all_weld_circles = find_all_circles_by_radius(msp, 2.8, 0.3)
        
        for weld_circle in all_weld_circles:
            weld_center = weld_circle['center']
            weld_group_radius = 4.0
            
            print(f"   WELD ê·¸ë£¹({weld_center.x:.2f}, {weld_center.y:.2f})ì˜ RED ìš”ì†Œ ì°¾ëŠ” ì¤‘...")
            
            # ì´ íŠ¹ì • WELD ê·¸ë£¹ì˜ RED LINE ì°¾ê¸°
            group_red_count = 0
            for entity in msp.query('LINE'):
                try:
                    if hasattr(entity.dxf, 'color') and entity.dxf.color == 1:  # ë¹¨ê°„ìƒ‰
                        start_point = Vec2(entity.dxf.start.x, entity.dxf.start.y)
                        end_point = Vec2(entity.dxf.end.x, entity.dxf.end.y)
                        
                        # ì´ WELD ê·¸ë£¹ 4mm ë‚´ì— ìˆëŠ” RED LINEì¸ì§€ í™•ì¸
                        if (distance(weld_center, start_point) <= weld_group_radius or 
                            distance(weld_center, end_point) <= weld_group_radius):
                            if entity not in red_lines_to_delete:
                                red_lines_to_delete.append(entity)
                                group_red_count += 1
                except Exception as e:
                    continue
            
            # ì´ íŠ¹ì • WELD ê·¸ë£¹ì˜ RED SL1 ì°¾ê¸°
            for poly in msp.query("POLYLINE LWPOLYLINE"):
                try:
                    if hasattr(poly.dxf, 'color') and poly.dxf.color == 1:  # ë¹¨ê°„ìƒ‰ SL1
                        if poly.dxftype() == "POLYLINE":
                            poly_points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                        else:
                            poly_points = [Vec2(x, y) for x, y, *_ in poly.get_points()]
                        
                        # ì´ WELD ê·¸ë£¹ 4mm ë‚´ì— ìˆëŠ” RED SL1ì¸ì§€ í™•ì¸
                        for point in poly_points:
                            if distance(weld_center, point) <= weld_group_radius:
                                if poly not in red_lines_to_delete:
                                    red_lines_to_delete.append(poly)
                                    group_red_count += 1
                                break
                except Exception as e:
                    continue
            
            print(f"     ë°œê²¬ëœ RED ìš”ì†Œ: {group_red_count}ê°œ")
        
        # RED ìš”ì†Œë“¤ ì‚­ì œ ì‹¤í–‰
        deleted_red_count = 0
        for red_entity in red_lines_to_delete:
            try:
                msp.delete_entity(red_entity)
                deleted_red_count += 1
            except Exception as ex:
                print(f"RED ìš”ì†Œ ì‚­ì œ ì˜¤ë¥˜: {ex}")
        
        print(f"âœ… ëª¨ë“  WELD ê·¸ë£¹ì˜ RED ìš”ì†Œ {deleted_red_count}ê°œ ì‚­ì œ ì™„ë£Œ")
        print(f"   - NL1 ìƒì„± ê°œìˆ˜: {nl1_created_count}ê°œ")
        print(f"   - ì „ì²´ WELD ì› ê°œìˆ˜: {len(all_weld_circles)}ê°œ")
        print(f"   - NL1 ìƒì„± ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ëª¨ë“  RED ìš”ì†Œ ì‚­ì œë¨")

        # ëª¨ë“  ì› ê°„ì˜ ìµœì†Œ ê±°ë¦¬ ë³´ì¥ (WELD ì›ë§Œ ì´ë™, WELDNO í…ìŠ¤íŠ¸ë§Œ í•¨ê»˜ ì´ë™)
        ensure_minimum_distances_between_all_circles(msp, min_distance)
        
        print(f"\nğŸ“Š ìµœì¢… ì²˜ë¦¬ ê²°ê³¼:")
        print(f"   ğŸ“ WELD ì› STRETCH: {stretch_count}ê°œ (6mm ì´í•˜ì¸ ê²½ìš°ë§Œ)")
        print(f"   ğŸ”— NL1 ìƒì„±: {nl1_created_count}ê°œ (SW ì› ë° SFW í´ë¦¬ë¼ì¸ ì—°ê²°)")
        print(f"   ğŸ¯ 5.6mm ì› ì ‘ì´‰: NL1ì´ í•­ìƒ WELD ì›(5.6mm)ê³¼ ì ‘í•¨")
        print(f"   ğŸš« TEXT ë³´í˜¸: WELDNO ì´ì™¸ ë‹¤ë¥¸ TEXTëŠ” ì ˆëŒ€ ì´ë™í•˜ì§€ ì•ŠìŒ")
        print(f"   ğŸ—‘ï¸  RED ìš”ì†Œ ì‚­ì œ: ëª¨ë“  WELD ê·¸ë£¹ì˜ RED ìš”ì†Œ ì‚­ì œ (NL1 ìƒì„± ì—¬ë¶€ ë¬´ê´€)")
        print(f"   ğŸ†• SFW ì§€ì›: 6ì  í´ë¦¬ë¼ì¸ ì¤‘ì‹¬ì„ SW ì›ì²˜ëŸ¼ ì‚¬ìš©í•˜ì—¬ NL1 ìƒì„±")
        print(f"   ğŸ†• WELDNO ì¡°ê±´: ê¸°ìš¸ê¸° 0ë„ + TEXT/INST/< í¬í•¨ ì œì™¸ + ìˆ«ì í¬í•¨ í•„ìˆ˜")
        
        print("[3ë‹¨ê³„] NL1 ìƒì„± ë° WELD ì› STRETCH ì™„ë£Œ")
        
    except Exception as main_e:
        print(f"âŒ NL1 ì²˜ë¦¬ ì¤‘ ì „ì²´ ì˜¤ë¥˜: {main_e}")
        print("[3ë‹¨ê³„] NL1 ìƒì„± ë° ê±°ë¦¬ ì œì–´ ì‹¤íŒ¨")

### [4ë‹¨ê³„] NL1 ê¸¸ì´ 6mm ì¡°ì • ê¸°ëŠ¥ ###
def find_nl1_lines_with_weld_circles(msp):
    """NL1 í°ìƒ‰ ì„ ê³¼ ì—°ê²°ëœ WELD ì›ë“¤ì„ ì°¾ëŠ” í•¨ìˆ˜ (SW ì› ë° SFW í´ë¦¬ë¼ì¸ í¬í•¨)"""
    nl1_weld_pairs = []
    
    # ëª¨ë“  í°ìƒ‰ NL1 ì„  ì°¾ê¸°
    nl1_lines = []
    for entity in msp.query('LINE'):
        try:
            if hasattr(entity.dxf, 'color') and entity.dxf.color == 4:  # í°ìƒ‰
                nl1_lines.append(entity)
        except Exception:
            continue
    
    print(f"ğŸ” í°ìƒ‰ NL1 ì„  {len(nl1_lines)}ê°œ ë°œê²¬")
    
    # ê° NL1 ì„ ì— ëŒ€í•´ ì—°ê²°ëœ WELD ì› ì°¾ê¸°
    for nl1_line in nl1_lines:
        try:
            line_start = Vec2(nl1_line.dxf.start.x, nl1_line.dxf.start.y)
            line_end = Vec2(nl1_line.dxf.end.x, nl1_line.dxf.end.y)
            
            # NL1 ì„ ì˜ ëì  ê·¼ì²˜ì— ìˆëŠ” WELD ì› ì°¾ê¸°
            weld_circle = None
            small_circle = None
            sw_type = None
            
            # WELD ì› ì°¾ê¸° (ë°˜ì§€ë¦„ 2.8mm)
            for entity in msp.query('CIRCLE'):
                try:
                    if (hasattr(entity.dxf, 'color') and entity.dxf.color == 2 and  # ë…¸ë‘ìƒ‰
                        hasattr(entity.dxf, 'radius') and abs(entity.dxf.radius - 2.8) <= 0.3):
                        circle_center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                        
                        # NL1 ì„ ì˜ ì‹œì‘ì ì´ WELD ì› ê²½ê³„ ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸ (2.8mm + ì—¬ìœ )
                        dist_to_start = distance(circle_center, line_start)
                        if dist_to_start <= 3.5:  # WELD ì› ë°˜ì§€ë¦„ + ì—¬ìœ 
                            weld_circle = {
                                'entity': entity,
                                'center': circle_center,
                                'radius': entity.dxf.radius
                            }
                            break
                except Exception:
                    continue
            
            # 1mm SW ì› ì°¾ê¸°
            for entity in msp.query('CIRCLE'):
                try:
                    if (hasattr(entity.dxf, 'color') and entity.dxf.color == 2 and  # ë…¸ë‘ìƒ‰
                        hasattr(entity.dxf, 'radius') and abs(entity.dxf.radius - 1.0) <= 0.1):
                        circle_center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                        
                        # NL1 ì„ ì˜ ëì ì´ 1mm ì› ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸
                        dist_to_end = distance(circle_center, line_end)
                        if dist_to_end <= 1.5:  # 1mm ì› ë°˜ì§€ë¦„ + ì—¬ìœ 
                            small_circle = {
                                'entity': entity,
                                'center': circle_center,
                                'radius': entity.dxf.radius
                            }
                            sw_type = 'SW'
                            break
                except Exception:
                    continue
            
            # SW ì›ì„ ëª» ì°¾ì•˜ìœ¼ë©´ SFW í´ë¦¬ë¼ì¸ ì°¾ê¸°
            if not small_circle:
                for poly in msp.query("POLYLINE LWPOLYLINE"):
                    try:
                        if hasattr(poly.dxf, 'layer') and poly.dxf.layer == "SFW":
                            # ì ë“¤ ê°€ì ¸ì˜¤ê¸°
                            if poly.dxftype() == "POLYLINE":
                                points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                            else:
                                points = [Vec2(x, y) for x, y, *_ in poly.get_points()]
                            
                            # 6ê°œ ì ì¸ì§€ í™•ì¸
                            if len(points) == 6:
                                # ì¤‘ì‹¬ì  ê³„ì‚°
                                center_x = sum(p.x for p in points) / 6
                                center_y = sum(p.y for p in points) / 6
                                center = Vec2(center_x, center_y)
                                
                                # NL1 ëì ì´ SFW ì¤‘ì‹¬ ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸
                                dist_to_end = distance(center, line_end)
                                if dist_to_end <= 2.0:  # SFW ì¤‘ì‹¬ ê·¼ì²˜
                                    small_circle = {
                                        'entity': poly,
                                        'center': center,
                                        'radius': 1.0  # SFWë¥¼ 1mm ì›ì²˜ëŸ¼ ì·¨ê¸‰
                                    }
                                    sw_type = 'SFW'
                                    break
                    except Exception:
                        continue
            
            # NL1ê³¼ WELD ì›, SW/SFWê°€ ëª¨ë‘ ì—°ê²°ëœ ê²½ìš°ë§Œ ì¶”ê°€
            if weld_circle and small_circle:
                nl1_length = distance(line_start, line_end)
                nl1_weld_pairs.append({
                    'nl1_line': nl1_line,
                    'weld_circle': weld_circle,
                    'small_circle': small_circle,
                    'current_length': nl1_length,
                    'sw_type': sw_type
                })
                print(f"   NL1 ë°œê²¬: ê¸¸ì´ {nl1_length:.2f}mm, WELDì›({weld_circle['center'].x:.2f}, {weld_circle['center'].y:.2f}) - {sw_type}({small_circle['center'].x:.2f}, {small_circle['center'].y:.2f})")
        
        except Exception as e:
            print(f"NL1 ì„  ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
            continue
    
    print(f"ğŸ“Š ìœ íš¨í•œ NL1-WELD ìŒ {len(nl1_weld_pairs)}ê°œ ë°œê²¬")
    return nl1_weld_pairs

def adjust_nl1_to_7mm_length(nl1_weld_pair, target_length=7.0, msp=None):
    """NL1 ê¸¸ì´ë¥¼ ì •í™•íˆ 7mmë¡œ ì¡°ì •í•˜ëŠ” í•¨ìˆ˜ (7mm ì´ìƒ/ì´í•˜ ëª¨ë‘ ì¡°ì •)"""
    nl1_line = nl1_weld_pair['nl1_line']
    weld_circle = nl1_weld_pair['weld_circle']
    small_circle = nl1_weld_pair['small_circle']
    current_length = nl1_weld_pair['current_length']
    
    weld_center = weld_circle['center']
    small_center = small_circle['center']
    weld_radius = weld_circle['radius']  # 2.8mm
    
    print(f"ğŸ”§ NL1 ê¸¸ì´ ì¡°ì •: í˜„ì¬ {current_length:.2f}mm â†’ ëª©í‘œ {target_length:.2f}mm")
    
    # 7mmì™€ ê±°ì˜ ê°™ìœ¼ë©´ ì¡°ì • ë¶ˆí•„ìš” (ì˜¤ì°¨ ë²”ìœ„ 0.1mm)
    if abs(current_length - target_length) < 0.1:
        print(f"   âœ… ì¡°ì • ë¶ˆí•„ìš”: í˜„ì¬ ê¸¸ì´ {current_length:.2f}mm â‰ˆ {target_length}mm")
        return True, "no_adjustment"
    
    # WELD ì›ì—ì„œ SW/SFW ë°©í–¥ìœ¼ë¡œì˜ ë²¡í„° (NL1 ë²¡í„° ë°©í–¥)
    direction_vec = small_center - weld_center
    if direction_vec.magnitude == 0:
        print(f"   âŒ ì›ë“¤ì´ ê°™ì€ ìœ„ì¹˜ì— ìˆì–´ ì¡°ì • ë¶ˆê°€ëŠ¥")
        return False, "same_position"
    
    direction_normalized = direction_vec.normalize()
    
    # ìƒˆë¡œìš´ WELD ì› ìœ„ì¹˜ ê³„ì‚° (SW/SFWì—ì„œ ì •í™•íˆ 7mm ë–¨ì–´ì§„ ìœ„ì¹˜)
    new_weld_center = small_center - direction_normalized * target_length
    
    if current_length > target_length:
        print(f"   ğŸ“‰ ê±°ë¦¬ ì¶•ì†Œ: {current_length:.2f}mm â†’ {target_length:.2f}mm")
    else:
        print(f"   ğŸ“ˆ ê±°ë¦¬ í™•ëŒ€: {current_length:.2f}mm â†’ {target_length:.2f}mm")
    
    print(f"   ì´ë™ ê³„íš: WELDì› ({weld_center.x:.2f}, {weld_center.y:.2f}) â†’ ({new_weld_center.x:.2f}, {new_weld_center.y:.2f})")
    
    # WELDNO í…ìŠ¤íŠ¸ ì°¾ê¸° (WELD ì› ì£¼ë³€ 3mm ë‚´ë§Œ)
    weldno_texts = []
    weldno_text_search_radius = 3.0
    text_backups = []
    
    for txt in msp.query('TEXT'):
        try:
            txt_pos = Vec2(txt.dxf.insert.x, txt.dxf.insert.y)
            if distance(weld_center, txt_pos) <= weldno_text_search_radius:
                # í…ìŠ¤íŠ¸ ì—”í‹°í‹°ê°€ WDNOë¡œ ìœ íš¨í•œì§€ í™•ì¸ (ë‚´ìš© + ê¸°ìš¸ê¸°)
                if is_valid_wdno_entity(txt):
                    weldno_texts.append(txt)
                    text_backups.append({
                        'text': txt,
                        'original_pos': (txt.dxf.insert.x, txt.dxf.insert.y, txt.dxf.insert.z if hasattr(txt.dxf.insert, 'z') else 0)
                    })
        except Exception:
            continue
    
    print(f"   WELDNO í…ìŠ¤íŠ¸ {len(weldno_texts)}ê°œ ë°œê²¬")
    
    # ì›ë˜ ìœ„ì¹˜ ë°±ì—…
    original_weld_center = Vec2(weld_center.x, weld_center.y)
    
    # ìƒˆ ìœ„ì¹˜ì—ì„œ ê°„ì„­ ì²´í¬ (NL1ì€ ì œì™¸)
    exclude_entities = [weld_circle['entity'], small_circle['entity'], nl1_line] + weldno_texts
    
    # ìƒˆ ìœ„ì¹˜ì—ì„œ TEXT ê°„ì„­ ì²´í¬
    has_text_interference_at_new = check_text_interference_only(new_weld_center, msp, exclude_entities, weld_radius)
    
    # ì›ë˜ ìœ„ì¹˜ì—ì„œ TEXT ê°„ì„­ ì²´í¬
    has_text_interference_at_original = check_text_interference_only(original_weld_center, msp, exclude_entities, weld_radius)
    
    print(f"   TEXT ê°„ì„­ ì²´í¬ ê²°ê³¼:")
    print(f"     ìƒˆ ìœ„ì¹˜(7mm) TEXT ê°„ì„­: {'ìˆìŒ' if has_text_interference_at_new else 'ì—†ìŒ'}")
    print(f"     ì›ë˜ ìœ„ì¹˜ TEXT ê°„ì„­: {'ìˆìŒ' if has_text_interference_at_original else 'ì—†ìŒ'}")
    
    # ê²°ì • ë¡œì§: ë‘ ìœ„ì¹˜ ì¤‘ TEXT ê°„ì„­ì´ ì—†ëŠ” ê³³ìœ¼ë¡œ ì´ë™
    target_center = None
    decision_reason = ""
    
    if not has_text_interference_at_new and not has_text_interference_at_original:
        # ë‘˜ ë‹¤ ê°„ì„­ ì—†ìœ¼ë©´ 7mm ìœ„ì¹˜ë¡œ ì´ë™ (ëª©í‘œ ë‹¬ì„±)
        target_center = new_weld_center
        decision_reason = "ë‘˜ ë‹¤ ê°„ì„­ ì—†ìŒ - 7mm ìœ„ì¹˜ë¡œ ì´ë™"
    elif not has_text_interference_at_new and has_text_interference_at_original:
        # ìƒˆ ìœ„ì¹˜ë§Œ ê°„ì„­ ì—†ìœ¼ë©´ 7mm ìœ„ì¹˜ë¡œ ì´ë™
        target_center = new_weld_center
        decision_reason = "7mm ìœ„ì¹˜ë§Œ ê°„ì„­ ì—†ìŒ - 7mm ìœ„ì¹˜ë¡œ ì´ë™"
    elif has_text_interference_at_new and not has_text_interference_at_original:
        # ì›ë˜ ìœ„ì¹˜ë§Œ ê°„ì„­ ì—†ìœ¼ë©´ ì›ë˜ ìœ„ì¹˜ ìœ ì§€
        target_center = original_weld_center
        decision_reason = "ì›ë˜ ìœ„ì¹˜ë§Œ ê°„ì„­ ì—†ìŒ - ì›ë˜ ìœ„ì¹˜ ìœ ì§€"
    else:
        # ë‘˜ ë‹¤ ê°„ì„­ ìˆìœ¼ë©´ 7mm ìœ„ì¹˜ë¡œ ì´ë™ (ê°•ì œ)
        target_center = new_weld_center
        decision_reason = "ë‘˜ ë‹¤ ê°„ì„­ ìˆìŒ - 7mm ìœ„ì¹˜ë¡œ ê°•ì œ ì´ë™"
    
    print(f"   ê²°ì •: {decision_reason}")
    
    # ì›ë˜ ìœ„ì¹˜ ìœ ì§€í•˜ëŠ” ê²½ìš°
    if target_center == original_weld_center:
        print(f"   âœ… ì›ë˜ ìœ„ì¹˜ ìœ ì§€ - ì¡°ì • ì—†ìŒ")
        return True, "keep_original_position"
    
    # ë‹¤ë¥¸ ì›ë“¤ê³¼ì˜ ê±°ë¦¬ ì²´í¬ (ìµœì†Œ 6mm) - 7mm ìœ„ì¹˜ë¡œ ì´ë™í•˜ëŠ” ê²½ìš°ë§Œ
    for entity in msp.query('CIRCLE'):
        try:
            if (hasattr(entity.dxf, 'color') and entity.dxf.color == 2 and
                entity != weld_circle['entity'] and entity != small_circle['entity']):
                other_center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                dist_to_other = distance(target_center, other_center)
                
                if dist_to_other < 6.0:
                    print(f"   âŒ ë‹¤ë¥¸ ì›ê³¼ì˜ ê±°ë¦¬ ìœ„ë°˜: {dist_to_other:.2f}mm < 6.0mm")
                    print(f"   ì´ë™ ì·¨ì†Œ - ì›ë˜ ìœ„ì¹˜ ìœ ì§€")
                    return False, "circle_collision"
        except Exception:
            continue
    
    # WELD ì› ë° WELDNO í…ìŠ¤íŠ¸ ì´ë™ ì‹¤í–‰
    try:
        move_vec = target_center - weld_center
        
        # WELD ì› ì´ë™
        weld_circle['entity'].dxf.center = (target_center.x, target_center.y, 0)
        weld_circle['center'] = target_center
        
        # WELDNO í…ìŠ¤íŠ¸ë“¤ í•¨ê»˜ ì´ë™
        for txt in weldno_texts:
            try:
                old_pos = txt.dxf.insert
                new_pos = (old_pos.x + move_vec.x, old_pos.y + move_vec.y, old_pos.z if hasattr(old_pos, 'z') else 0)
                txt.dxf.insert = new_pos
            except Exception as e:
                print(f"    WELDNO í…ìŠ¤íŠ¸ ì´ë™ ì˜¤ë¥˜: {e}")
        
        # NL1 ì„  ì—…ë°ì´íŠ¸ (WELD ì› ê²½ê³„ì—ì„œ ì‹œì‘)
        direction_to_small = small_center - target_center
        if direction_to_small.magnitude > 0:
            direction_normalized_final = direction_to_small.normalize()
            new_trim_start = target_center + direction_normalized_final * weld_radius
            nl1_line.dxf.start = (new_trim_start.x, new_trim_start.y, 0)
            
            # ìƒˆë¡œìš´ NL1 ê¸¸ì´ ê³„ì‚°
            final_nl1_length = distance(new_trim_start, small_center)
            
            print(f"   âœ… WELD ì› STRETCH ì„±ê³µ")
            print(f"   WELD ì› ìƒˆ ìœ„ì¹˜: ({target_center.x:.2f}, {target_center.y:.2f})")
            print(f"   NL1 ìƒˆ ê¸¸ì´: {final_nl1_length:.2f}mm")
            print(f"   WELDNO í…ìŠ¤íŠ¸ {len(weldno_texts)}ê°œ í•¨ê»˜ ì´ë™")
        
        return True, "stretch_success"
        
    except Exception as e:
        print(f"   âŒ STRETCH ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}")
        
        # ì˜¤ë¥˜ ë°œìƒ ì‹œ ì›ë˜ ìœ„ì¹˜ë¡œ ë³µêµ¬
        try:
            weld_circle['entity'].dxf.center = (original_weld_center.x, original_weld_center.y, 0)
            weld_circle['center'] = original_weld_center
            for backup in text_backups:
                backup['text'].dxf.insert = backup['original_pos']
            print(f"   ë³µêµ¬ ì™„ë£Œ: ì›ë˜ ìœ„ì¹˜ë¡œ ë˜ëŒë¦¼")
        except Exception as restore_e:
            print(f"   ë³µêµ¬ ì¤‘ ì˜¤ë¥˜: {restore_e}")
        
        return False, "stretch_error"

def process_nl1_length_adjustment(doc):
    """[4ë‹¨ê³„] NL1 ê¸¸ì´ë¥¼ ì •í™•íˆ 7mmë¡œ ì¡°ì • (7mm ì´ìƒ/ì´í•˜ ëª¨ë‘)"""
    msp = doc.modelspace()
    target_length = 7.0
    
    print(f"\n[4ë‹¨ê³„] NL1 ê¸¸ì´ 7mm ì¡°ì • ì‹œì‘")
    
    try:
        # NL1 ì„ ê³¼ ì—°ê²°ëœ WELD ì›ë“¤ ì°¾ê¸°
        nl1_weld_pairs = find_nl1_lines_with_weld_circles(msp)
        
        if not nl1_weld_pairs:
            print("ì¡°ì •í•  NL1-WELD ìŒì´ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        # 7mmì™€ ë‹¤ë¥¸ NL1 í•„í„°ë§ (ì˜¤ì°¨ ë²”ìœ„ 0.1mm)
        adjustment_needed_pairs = []
        for pair in nl1_weld_pairs:
            if abs(pair['current_length'] - target_length) > 0.1:
                adjustment_needed_pairs.append(pair)
                if pair['current_length'] > target_length:
                    print(f"ğŸ“ ì¡°ì • ëŒ€ìƒ: NL1 ê¸¸ì´ {pair['current_length']:.2f}mm > {target_length}mm (ì¶•ì†Œ í•„ìš”)")
                else:
                    print(f"ğŸ“ ì¡°ì • ëŒ€ìƒ: NL1 ê¸¸ì´ {pair['current_length']:.2f}mm < {target_length}mm (í™•ëŒ€ í•„ìš”)")
        
        if not adjustment_needed_pairs:
            print(f"âœ… ëª¨ë“  NL1ì´ ì´ë¯¸ {target_length}mmì…ë‹ˆë‹¤.")
            return
        
        print(f"ğŸ“Š ì¡°ì • ëŒ€ìƒ: {len(adjustment_needed_pairs)}ê°œ NL1")
        
        success_count = 0
        fail_count = 0
        keep_original_count = 0
        
        # ê° NL1ì— ëŒ€í•´ ì¡°ì • ìˆ˜í–‰
        for i, pair in enumerate(adjustment_needed_pairs):
            print(f"\nğŸ”§ [{i+1}/{len(adjustment_needed_pairs)}] NL1 ì¡°ì • ì¤‘...")
            
            success, result_type = adjust_nl1_to_7mm_length(pair, target_length, msp)
            
            if success:
                if result_type == "no_adjustment":
                    print(f"   âœ… ì¡°ì • ë¶ˆí•„ìš”")
                elif result_type == "keep_original_position":
                    keep_original_count += 1
                    print(f"   âœ… ì›ë˜ ìœ„ì¹˜ ìœ ì§€ (TEXT ê°„ì„­ íšŒí”¼)")
                else:
                    success_count += 1
                    print(f"   âœ… 7mm ìœ„ì¹˜ë¡œ ì¡°ì • ì„±ê³µ")
            else:
                fail_count += 1
                print(f"   âŒ ì¡°ì • ì‹¤íŒ¨: {result_type}")
        
        print(f"\nğŸ“Š [4ë‹¨ê³„] ìµœì¢… ê²°ê³¼:")
        print(f"   ğŸ¯ 7mm ìœ„ì¹˜ë¡œ ì¡°ì • ì„±ê³µ: {success_count}ê°œ")
        print(f"   ğŸ  ì›ë˜ ìœ„ì¹˜ ìœ ì§€: {keep_original_count}ê°œ (TEXT ê°„ì„­ íšŒí”¼)")
        print(f"   âŒ ì¡°ì • ì‹¤íŒ¨: {fail_count}ê°œ")
        print(f"   ğŸ“ ëª¨ë“  WELDNOê°€ ì •í™•íˆ 7mm ê±°ë¦¬ë¡œ ì¡°ì •ë¨ (ì´ìƒ/ì´í•˜ ëª¨ë‘)")
        print(f"   ğŸ”§ WELD ì› STRETCH: NL1 ë²¡í„° ë°©í–¥ìœ¼ë¡œ 7mm ìœ„ì¹˜ë¡œ ì´ë™")
        print(f"   ğŸš« TEXT ê°„ì„­ ì²´í¬: ë‘ ìœ„ì¹˜ ì¤‘ ê°„ì„­ ì—†ëŠ” ê³³ìœ¼ë¡œ ì„ íƒ")
        print(f"   ğŸ’¾ WELDNO í…ìŠ¤íŠ¸ë§Œ í•¨ê»˜ ì´ë™ (ë‹¤ë¥¸ TEXT ë³´í˜¸)")
        print(f"   ğŸ†• SFW ì§€ì›: SFW í´ë¦¬ë¼ì¸ë„ SW ì›ê³¼ ë™ì¼í•˜ê²Œ ì²˜ë¦¬")
        print(f"   ğŸ†• WELDNO ì¡°ê±´: ê¸°ìš¸ê¸° 0ë„ + TEXT/INST/< í¬í•¨ ì œì™¸ + ìˆ«ì í¬í•¨ í•„ìˆ˜")
        
        print("[4ë‹¨ê³„] NL1 ê¸¸ì´ 7mm ì¡°ì • ì™„ë£Œ")
        
    except Exception as e:
        print(f"âŒ [4ë‹¨ê³„] NL1 ê¸¸ì´ ì¡°ì • ì¤‘ ì˜¤ë¥˜: {e}")
        print("[4ë‹¨ê³„] NL1 ê¸¸ì´ ì¡°ì • ì‹¤íŒ¨")

### [5ë‹¨ê³„] MWD íšŒì „ ë° ìµœì¢… ì—°ê²° - ìš°ì„ ìˆœìœ„ ê¸°ë°˜ + SFW 7mm ì¡°ì • ###
def get_text_bounding_box(text):
    """TEXT ì—”í‹°í‹°ì˜ ë°”ìš´ë”© ë°•ìŠ¤ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜"""
    try:
        # í…ìŠ¤íŠ¸ì˜ ê¸°ë³¸ ì†ì„±
        insert = Vec2(text.dxf.insert.x, text.dxf.insert.y)
        height = text.dxf.height
        
        # í…ìŠ¤íŠ¸ ë‚´ìš© ê¸¸ì´ (ëŒ€ëµì ì¸ ë„ˆë¹„ ê³„ì‚°)
        text_content = text.dxf.text
        width = len(text_content) * height * 0.7  # ëŒ€ëµì ì¸ ë¬¸ì ë„ˆë¹„ ë¹„ìœ¨
        
        # í…ìŠ¤íŠ¸ ì •ë ¬ ë°©ì‹ í™•ì¸ (ê¸°ë³¸ê°’ì€ LEFT)
        halign = text.dxf.halign if hasattr(text.dxf, 'halign') else 0
        valign = text.dxf.valign if hasattr(text.dxf, 'valign') else 0
        
        # ìˆ˜í‰ ì •ë ¬ì— ë”°ë¥¸ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
        if halign == 0:  # LEFT
            min_x = insert.x
            max_x = insert.x + width
        elif halign == 1:  # CENTER
            min_x = insert.x - width/2
            max_x = insert.x + width/2
        elif halign == 2:  # RIGHT
            min_x = insert.x - width
            max_x = insert.x
        else:
            min_x = insert.x
            max_x = insert.x + width
        
        # ìˆ˜ì§ ì •ë ¬ì— ë”°ë¥¸ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
        if valign == 0:  # BASELINE
            min_y = insert.y
            max_y = insert.y + height
        elif valign == 1:  # BOTTOM
            min_y = insert.y
            max_y = insert.y + height
        elif valign == 2:  # MIDDLE
            min_y = insert.y - height/2
            max_y = insert.y + height/2
        elif valign == 3:  # TOP
            min_y = insert.y - height
            max_y = insert.y
        else:
            min_y = insert.y
            max_y = insert.y + height
        
        # ë°”ìš´ë”© ë°•ìŠ¤ ì¤‘ì‹¬
        center = Vec2((min_x + max_x)/2, (min_y + max_y)/2)
        
        return {
            'center': center,
            'width': width,
            'height': height,
            'min_x': min_x,
            'max_x': max_x,
            'min_y': min_y,
            'max_y': max_y
        }
    except Exception as e:
        print(f"í…ìŠ¤íŠ¸ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚° ì˜¤ë¥˜: {e}")
        return None

def find_pipe_line_angle(sw_center, msp, search_radius=5.0):
    """SW ì› ë‚´ì— ì ‘í•˜ëŠ” PIPE ì´ë¦„ì„ í¬í•¨í•˜ëŠ” ì„ ì˜ ê°ë„ë¥¼ ì°¾ëŠ” í•¨ìˆ˜"""
    try:
        # SW ì› ì£¼ë³€ì˜ LINE ì°¾ê¸°
        for entity in msp.query('LINE'):
            try:
                start = Vec2(entity.dxf.start.x, entity.dxf.start.y)
                end = Vec2(entity.dxf.end.x, entity.dxf.end.y)
                
                # SW ì› ì¤‘ì‹¬ì—ì„œ ì„ ê¹Œì§€ì˜ ê±°ë¦¬ í™•ì¸
                if (distance(sw_center, start) <= search_radius or 
                    distance(sw_center, end) <= search_radius):
                    
                    # ì„ ì˜ ê°ë„ ê³„ì‚°
                    dx = end.x - start.x
                    dy = end.y - start.y
                    angle = math.atan2(dy, dx)
                    return angle
            except Exception:
                continue
        
        # POLYLINE/LWPOLYLINE ì°¾ê¸°
        for poly in msp.query("POLYLINE LWPOLYLINE"):
            try:
                if poly.dxftype() == "POLYLINE":
                    points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                else:
                    points = [Vec2(x, y) for x, y, *_ in poly.get_points()]
                
                # SW ì› ê·¼ì²˜ì˜ ì„ ë¶„ ì°¾ê¸°
                for i in range(len(points) - 1):
                    if (distance(sw_center, points[i]) <= search_radius or 
                        distance(sw_center, points[i+1]) <= search_radius):
                        
                        # ì„ ë¶„ì˜ ê°ë„ ê³„ì‚°
                        dx = points[i+1].x - points[i].x
                        dy = points[i+1].y - points[i].y
                        angle = math.atan2(dy, dx)
                        return angle
            except Exception:
                continue
        
        return None
    except Exception as e:
        print(f"PIPE ì„  ê°ë„ ì°¾ê¸° ì˜¤ë¥˜: {e}")
        return None

def rotate_entity_around_point(entity, center, angle):
    """ì—”í‹°í‹°ë¥¼ íŠ¹ì • ì ì„ ì¤‘ì‹¬ìœ¼ë¡œ íšŒì „ì‹œí‚¤ëŠ” í•¨ìˆ˜"""
    try:
        cos_a = math.cos(angle)
        sin_a = math.sin(angle)
        
        if entity.dxftype() == 'CIRCLE':
            # ì›ì˜ ì¤‘ì‹¬ì  íšŒì „
            old_center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
            dx = old_center.x - center.x
            dy = old_center.y - center.y
            new_x = center.x + dx * cos_a - dy * sin_a
            new_y = center.y + dx * sin_a + dy * cos_a
            entity.dxf.center = (new_x, new_y, 0)
            
        elif entity.dxftype() == 'TEXT':
            # í…ìŠ¤íŠ¸ ì‚½ì…ì  íšŒì „
            old_pos = Vec2(entity.dxf.insert.x, entity.dxf.insert.y)
            dx = old_pos.x - center.x
            dy = old_pos.y - center.y
            new_x = center.x + dx * cos_a - dy * sin_a
            new_y = center.y + dx * sin_a + dy * cos_a
            entity.dxf.insert = (new_x, new_y, 0)
            
        elif entity.dxftype() == 'LINE':
            # ì„ ì˜ ì‹œì‘ì ê³¼ ëì  íšŒì „
            start = Vec2(entity.dxf.start.x, entity.dxf.start.y)
            end = Vec2(entity.dxf.end.x, entity.dxf.end.y)
            
            # ì‹œì‘ì  íšŒì „
            dx = start.x - center.x
            dy = start.y - center.y
            new_start_x = center.x + dx * cos_a - dy * sin_a
            new_start_y = center.y + dx * sin_a + dy * cos_a
            
            # ëì  íšŒì „
            dx = end.x - center.x
            dy = end.y - center.y
            new_end_x = center.x + dx * cos_a - dy * sin_a
            new_end_y = center.y + dx * sin_a + dy * cos_a
            
            entity.dxf.start = (new_start_x, new_start_y, 0)
            entity.dxf.end = (new_end_x, new_end_y, 0)
            
    except Exception as e:
        print(f"ì—”í‹°í‹° íšŒì „ ì˜¤ë¥˜: {e}")

def get_text_start_end_points(text):
    """TEXT ì—”í‹°í‹°ì˜ ì‹œì‘ì ê³¼ ëì ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜"""
    try:
        # í…ìŠ¤íŠ¸ ê¸°ë³¸ ì†ì„±
        insert = Vec2(text.dxf.insert.x, text.dxf.insert.y)
        height = text.dxf.height
        text_content = text.dxf.text
        
        # í…ìŠ¤íŠ¸ ë„ˆë¹„ ê³„ì‚° (ëŒ€ëµì ì¸ ë¹„ìœ¨)
        width = len(text_content) * height * 0.7
        
        # íšŒì „ ê°ë„ (ë¼ë””ì•ˆ)
        rotation = text.dxf.rotation if hasattr(text.dxf, 'rotation') else 0
        rotation_rad = math.radians(rotation)
        
        # ì •ë ¬ ë°©ì‹
        halign = text.dxf.halign if hasattr(text.dxf, 'halign') else 0
        
        # ê¸°ë³¸ ì‹œì‘ì ê³¼ ëì  (íšŒì „ ì „)
        if halign == 0:  # LEFT
            start_x = 0
            end_x = width
        elif halign == 1:  # CENTER
            start_x = -width/2
            end_x = width/2
        elif halign == 2:  # RIGHT
            start_x = -width
            end_x = 0
        else:
            start_x = 0
            end_x = width
        
        # íšŒì „ ì ìš©
        cos_r = math.cos(rotation_rad)
        sin_r = math.sin(rotation_rad)
        
        # ì‹œì‘ì 
        start_rotated_x = start_x * cos_r
        start_rotated_y = start_x * sin_r
        start_point = Vec2(insert.x + start_rotated_x, insert.y + start_rotated_y)
        
        # ëì 
        end_rotated_x = end_x * cos_r
        end_rotated_y = end_x * sin_r
        end_point = Vec2(insert.x + end_rotated_x, insert.y + end_rotated_y)
        
        return start_point, end_point
        
    except Exception as e:
        print(f"í…ìŠ¤íŠ¸ ì‹œì‘/ëì  ê³„ì‚° ì˜¤ë¥˜: {e}")
        return None, None

def check_text_endpoint_interference(text_entity, msp, exclude_entities, min_distance=5.0):
    """TEXT ì—”í‹°í‹°ì˜ ì‹œì‘ì /ëì ì´ ë‹¤ë¥¸ TEXTì˜ ì‹œì‘ì /ëì ì—ì„œ 5mm ì´ë‚´ë©´ ê°„ì„­ìœ¼ë¡œ íŒì •"""
    try:
        # í˜„ì¬ í…ìŠ¤íŠ¸ì˜ ì‹œì‘ì ê³¼ ëì 
        start1, end1 = get_text_start_end_points(text_entity)
        if not start1 or not end1:
            return False
        
        for e in msp:
            if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
                continue
            
            if e.dxftype() == "TEXT":
                # ìƒëŒ€ í…ìŠ¤íŠ¸ì˜ ì‹œì‘ì ê³¼ ëì 
                start2, end2 = get_text_start_end_points(e)
                if not start2 or not end2:
                    continue
                
                # 4ê°œì˜ ì  ê°„ ê±°ë¦¬ ì²´í¬ (ì–´ëŠ í•˜ë‚˜ë¼ë„ 5mm ì´ë‚´ë©´ ê°„ì„­)
                if (distance(start1, start2) < min_distance or
                    distance(start1, end2) < min_distance or
                    distance(end1, start2) < min_distance or
                    distance(end1, end2) < min_distance):
                    return True
        
        return False
    except Exception as e:
        print(f"í…ìŠ¤íŠ¸ ëì  ê°„ì„­ ì²´í¬ ì˜¤ë¥˜: {e}")
        return False

def check_pipe_layer_interference(mwd_entities, msp, exclude_entities):
    """PIPE ë˜ëŠ” ELBOë¥¼ í¬í•¨í•˜ëŠ” ë ˆì´ì–´ì™€ì˜ ê°„ì„­ì„ ì²´í¬"""
    try:
        for mwd_entity in mwd_entities:
            if mwd_entity.dxftype() == 'CIRCLE':
                circle_center = Vec2(mwd_entity.dxf.center.x, mwd_entity.dxf.center.y)
                circle_radius = mwd_entity.dxf.radius
                
                # ëª¨ë“  ì—”í‹°í‹° ê²€ì‚¬
                for e in msp:
                    if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
                        continue
                    
                    # ë ˆì´ì–´ ì´ë¦„ì— PIPE ë˜ëŠ” ELBOê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
                    if hasattr(e.dxf, 'layer'):
                        layer_name = e.dxf.layer.upper()
                        if 'PIPE' in layer_name or 'ELBO' in layer_name:
                            if e.dxftype() in ("LINE", "POLYLINE", "LWPOLYLINE"):
                                # ì„ ë¶„ê³¼ì˜ ê±°ë¦¬ ì²´í¬
                                if e.dxftype() == "LINE":
                                    start = Vec2(e.dxf.start.x, e.dxf.start.y)
                                    end = Vec2(e.dxf.end.x, e.dxf.end.y)
                                    dist = point_to_segment_distance(circle_center, start, end)
                                    if dist < circle_radius:
                                        return True
                                else:
                                    # í´ë¦¬ë¼ì¸
                                    if e.dxftype() == "POLYLINE":
                                        pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
                                    else:
                                        pts = [Vec2(x, y) for x, y, *_ in e.get_points()]
                                    
                                    for i in range(len(pts) - 1):
                                        dist = point_to_segment_distance(circle_center, pts[i], pts[i+1])
                                        if dist < circle_radius:
                                            return True
        
        return False
    except Exception as e:
        print(f"PIPE/ELBO ë ˆì´ì–´ ê°„ì„­ ì²´í¬ ì˜¤ë¥˜: {e}")
        return False

def check_30degree_polyline_interference(mwd_entities, msp, exclude_entities):
    """30ë„ ë‹¨ìœ„ ì •ê°ë„ë¥¼ ê°€ì§„ í´ë¦¬ë¼ì¸/LWí´ë¦¬ë¼ì¸ê³¼ì˜ ê°„ì„­ì„ ì²´í¬"""
    try:
        for mwd_entity in mwd_entities:
            if mwd_entity.dxftype() == 'CIRCLE':
                circle_center = Vec2(mwd_entity.dxf.center.x, mwd_entity.dxf.center.y)
                circle_radius = mwd_entity.dxf.radius
                
                # ëª¨ë“  í´ë¦¬ë¼ì¸ ê²€ì‚¬
                for e in msp.query("POLYLINE LWPOLYLINE"):
                    if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
                        continue
                    
                    # í´ë¦¬ë¼ì¸ì˜ ì ë“¤ ê°€ì ¸ì˜¤ê¸°
                    if e.dxftype() == "POLYLINE":
                        pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
                    else:
                        pts = [Vec2(x, y) for x, y, *_ in e.get_points()]
                    
                    if len(pts) < 2:
                        continue
                    
                    # ê° ì„ ë¶„ì˜ ê°ë„ ì²´í¬
                    for i in range(len(pts) - 1):
                        p1, p2 = pts[i], pts[i+1]
                        
                        # ì„ ë¶„ì˜ ê°ë„ ê³„ì‚° (ë¼ë””ì•ˆ)
                        dx = p2.x - p1.x
                        dy = p2.y - p1.y
                        angle_rad = math.atan2(dy, dx)
                        
                        # ê°ë„ë¥¼ 0~360ë„ë¡œ ë³€í™˜
                        angle_deg = math.degrees(angle_rad) % 360
                        
                        # 30ë„ ë‹¨ìœ„ë¡œ ë°˜ì˜¬ë¦¼
                        nearest_30 = round(angle_deg / 30) * 30
                        
                        # ì •í™•íˆ 30ë„ ë‹¨ìœ„ì¸ì§€ í™•ì¸ (ì˜¤ì°¨ 1ë„ ì´ë‚´)
                        if abs(angle_deg - nearest_30) < 1.0:
                            # ì›ê³¼ ì„ ë¶„ì˜ ê±°ë¦¬ ì²´í¬
                            dist = point_to_segment_distance(circle_center, p1, p2)
                            if dist < circle_radius:
                                return True
        
        return False
    except Exception as e:
        print(f"30ë„ ë‹¨ìœ„ í´ë¦¬ë¼ì¸ ê°„ì„­ ì²´í¬ ì˜¤ë¥˜: {e}")
        return False

def check_mwd_interference_with_priority(mwd_entities, sw_center, rotation_angle, msp, exclude_entities, pipe_lines=None):
    """ìš°ì„ ìˆœìœ„ ê¸°ë°˜ MWD ê°„ì„­ ì²´í¬ - ê° ê°„ì„­ ìœ í˜•ë³„ë¡œ ë³„ë„ ì²´í¬"""
    try:
        # ì„ì‹œë¡œ íšŒì „ì‹œì¼œì„œ ê°„ì„­ ì²´í¬
        temp_positions = []
        
        # ëª¨ë“  ì—”í‹°í‹°ì˜ í˜„ì¬ ìœ„ì¹˜ ë°±ì—…
        for entity in mwd_entities:
            if entity.dxftype() == 'CIRCLE':
                temp_positions.append({
                    'entity': entity,
                    'type': 'CIRCLE',
                    'original': (entity.dxf.center.x, entity.dxf.center.y, 0)
                })
            elif entity.dxftype() == 'TEXT':
                temp_positions.append({
                    'entity': entity,
                    'type': 'TEXT',
                    'original': (entity.dxf.insert.x, entity.dxf.insert.y, 0)
                })
            elif entity.dxftype() == 'LINE':
                temp_positions.append({
                    'entity': entity,
                    'type': 'LINE',
                    'original_start': (entity.dxf.start.x, entity.dxf.start.y, 0),
                    'original_end': (entity.dxf.end.x, entity.dxf.end.y, 0)
                })
        
        # ì„ì‹œë¡œ íšŒì „
        for entity in mwd_entities:
            rotate_entity_around_point(entity, sw_center, rotation_angle)
        
        # íšŒì „ í›„ WELDNO í…ìŠ¤íŠ¸ë¥¼ WDC ì› ì¤‘ì‹¬ìœ¼ë¡œ ì¬ì •ë ¬
        wdc_circle = None
        weldno_texts = []
        
        for entity in mwd_entities:
            if entity.dxftype() == 'CIRCLE' and abs(entity.dxf.radius - 2.8) <= 0.3:
                wdc_circle = entity
            elif entity.dxftype() == 'TEXT':
                # í…ìŠ¤íŠ¸ ì—”í‹°í‹°ê°€ WDNOë¡œ ìœ íš¨í•œì§€ í™•ì¸ (ë‚´ìš© + ê¸°ìš¸ê¸°)
                if is_valid_wdno_entity(entity):
                    weldno_texts.append(entity)
        
        if wdc_circle and weldno_texts:
            wdc_center = Vec2(wdc_circle.dxf.center.x, wdc_circle.dxf.center.y)
            for txt in weldno_texts:
                bbox = get_text_bounding_box(txt)
                if bbox:
                    offset = wdc_center - bbox['center']
                    new_insert = Vec2(txt.dxf.insert.x + offset.x, 
                                    txt.dxf.insert.y + offset.y)
                    txt.dxf.insert = (new_insert.x, new_insert.y, 0)
        
        # ê° ê°„ì„­ ìœ í˜•ë³„ë¡œ ì²´í¬
        has_text_interference = False
        has_pipe_layer_interference = False
        has_pc_circle_interference = False
        has_30degree_polyline_interference = False
        general_interference_score = 0
        
        # 1. TEXT ê°„ì„­ ì²´í¬ (ìµœìš°ì„ )
        for entity in mwd_entities:
            if entity.dxftype() == 'TEXT':
                if check_text_endpoint_interference(entity, msp, exclude_entities + mwd_entities, 5.0):
                    has_text_interference = True
                    break
        
        # 2. PIPE/ELBO ë ˆì´ì–´ ê°„ì„­ ì²´í¬ (ë‘ë²ˆì§¸ ìš°ì„ ìˆœìœ„)
        has_pipe_layer_interference = check_pipe_layer_interference(mwd_entities, msp, exclude_entities + mwd_entities)
        
        # 3. PCì™€ WDC ì› ì‚¬ì´ 2mm ì²´í¬ (ì„¸ë²ˆì§¸ ìš°ì„ ìˆœìœ„)
        if pipe_lines:
            for entity in mwd_entities:
                if entity.dxftype() == 'CIRCLE' and abs(entity.dxf.radius - 2.8) <= 0.3:  # WDC ì›
                    center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                    for pc in pipe_lines:
                        if check_circle_to_segments_distance(center, entity.dxf.radius, pc['segments'], 2.0):
                            has_pc_circle_interference = True
                            break
                    if has_pc_circle_interference:
                        break
        
        # 4. 30ë„ ë‹¨ìœ„ ì •ê°ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ ì²´í¬ (ë„¤ë²ˆì§¸ ìš°ì„ ìˆœìœ„)
        has_30degree_polyline_interference = check_30degree_polyline_interference(mwd_entities, msp, exclude_entities + mwd_entities)
        
        # 5. ì¼ë°˜ ê°„ì„­ ì ìˆ˜ ê³„ì‚° (ìµœí•˜ìœ„ ìš°ì„ ìˆœìœ„)
        for entity in mwd_entities:
            if entity.dxftype() == 'CIRCLE':
                center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                if check_interference_at_position(center, msp, exclude_entities + mwd_entities, entity.dxf.radius):
                    general_interference_score += 1
        
        # ì›ë˜ ìœ„ì¹˜ë¡œ ë³µêµ¬
        for backup in temp_positions:
            if backup['type'] == 'CIRCLE':
                backup['entity'].dxf.center = backup['original']
            elif backup['type'] == 'TEXT':
                backup['entity'].dxf.insert = backup['original']
            elif backup['type'] == 'LINE':
                backup['entity'].dxf.start = backup['original_start']
                backup['entity'].dxf.end = backup['original_end']
        
        return {
            'text_interference': has_text_interference,
            'pipe_layer_interference': has_pipe_layer_interference,
            'pc_circle_interference': has_pc_circle_interference,
            '30degree_polyline_interference': has_30degree_polyline_interference,
            'general_score': general_interference_score
        }
        
    except Exception as e:
        print(f"ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ê°„ì„­ ì²´í¬ ì˜¤ë¥˜: {e}")
        return {
            'text_interference': True,
            'pipe_layer_interference': True,
            'pc_circle_interference': True,
            '30degree_polyline_interference': True,
            'general_score': 999
        }

def find_sfw_polyline(msp, search_center, search_radius=20.0):
    """íŠ¹ì • ìœ„ì¹˜ ê·¼ì²˜ì˜ SFW ë ˆì´ì–´ 6ì  í´ë¦¬ë¼ì¸ì„ ì°¾ëŠ” í•¨ìˆ˜"""
    sfw_polylines = []
    
    for poly in msp.query("POLYLINE LWPOLYLINE"):
        try:
            if hasattr(poly.dxf, 'layer') and poly.dxf.layer == "SFW":
                # ì ë“¤ ê°€ì ¸ì˜¤ê¸°
                if poly.dxftype() == "POLYLINE":
                    points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                else:
                    points = [Vec2(x, y) for x, y, *_ in poly.get_points()]
                
                # 6ê°œ ì ì¸ì§€ í™•ì¸
                if len(points) == 6:
                    # ì¤‘ì‹¬ì  ê³„ì‚°
                    center_x = sum(p.x for p in points) / 6
                    center_y = sum(p.y for p in points) / 6
                    center = Vec2(center_x, center_y)
                    
                    # ê²€ìƒ‰ ì¤‘ì‹¬ì—ì„œì˜ ê±°ë¦¬
                    dist = distance(search_center, center)
                    if dist <= search_radius:
                        sfw_polylines.append({
                            'entity': poly,
                            'center': center,
                            'points': points,
                            'distance': dist
                        })
        except Exception:
            continue
    
    return sfw_polylines

def adjust_wdc_for_sfw_7mm(wdc_circle, wdc_center, sfw_center, msp):
    """SFWì™€ WDC ê±°ë¦¬ê°€ 7mm ì´í•˜ì¼ ë•Œ 7mmë¡œ ì¡°ì •í•˜ëŠ” í•¨ìˆ˜"""
    current_distance = distance(wdc_center, sfw_center)
    
    print(f"   ğŸ” í˜„ì¬ WDC-SFW ê±°ë¦¬: {current_distance:.2f}mm")
    
    if current_distance >= 7.0:
        print(f"   âœ… ê±°ë¦¬ ì¡°ì • ë¶ˆí•„ìš” (í˜„ì¬ {current_distance:.2f}mm >= 7mm)")
        return wdc_center, []
    
    print(f"   ğŸ“ 7mm ê±°ë¦¬ ì¡°ì • í•„ìš”: {current_distance:.2f}mm â†’ 7.0mm")
    
    # ë°©í–¥ ë²¡í„° ê³„ì‚° (SFWì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥)
    direction_vec = wdc_center - sfw_center
    if direction_vec.magnitude == 0:
        print(f"   âŒ WDCì™€ SFWê°€ ê°™ì€ ìœ„ì¹˜ì— ìˆì–´ ì¡°ì • ë¶ˆê°€ëŠ¥")
        return wdc_center, []
    
    direction_normalized = direction_vec.normalize()
    
    # ìƒˆë¡œìš´ WDC ìœ„ì¹˜ ê³„ì‚° (SFWì—ì„œ ì •í™•íˆ 7mm ë–¨ì–´ì§„ ìœ„ì¹˜)
    new_wdc_center = sfw_center + direction_normalized * 7.0
    
    print(f"   ğŸ“ WDC ì´ë™ ê³„íš: ({wdc_center.x:.2f}, {wdc_center.y:.2f}) â†’ ({new_wdc_center.x:.2f}, {new_wdc_center.y:.2f})")
    
    # WELDNO í…ìŠ¤íŠ¸ ì°¾ê¸° (WDC ì› ì£¼ë³€ 3mm ë‚´)
    weldno_texts = []
    weldno_text_search_radius = 3.0
    
    for txt in msp.query('TEXT'):
        try:
            txt_pos = Vec2(txt.dxf.insert.x, txt.dxf.insert.y)
            if distance(wdc_center, txt_pos) <= weldno_text_search_radius:
                # í…ìŠ¤íŠ¸ ì—”í‹°í‹°ê°€ WDNOë¡œ ìœ íš¨í•œì§€ í™•ì¸ (ë‚´ìš© + ê¸°ìš¸ê¸°)
                if is_valid_wdno_entity(txt):
                    weldno_texts.append(txt)
        except Exception:
            continue
    
    print(f"   ğŸ“ WELDNO í…ìŠ¤íŠ¸ {len(weldno_texts)}ê°œ ë°œê²¬")
    
    # WDC ì› ë° WELDNO í…ìŠ¤íŠ¸ ì´ë™
    try:
        move_vec = new_wdc_center - wdc_center
        
        # WDC ì› ì´ë™
        wdc_circle.dxf.center = (new_wdc_center.x, new_wdc_center.y, 0)
        
        # WELDNO í…ìŠ¤íŠ¸ë“¤ í•¨ê»˜ ì´ë™
        for txt in weldno_texts:
            try:
                old_pos = txt.dxf.insert
                new_pos = (old_pos.x + move_vec.x, old_pos.y + move_vec.y, old_pos.z if hasattr(old_pos, 'z') else 0)
                txt.dxf.insert = new_pos
            except Exception as e:
                print(f"   âŒ WELDNO í…ìŠ¤íŠ¸ ì´ë™ ì˜¤ë¥˜: {e}")
        
        final_distance = distance(new_wdc_center, sfw_center)
        print(f"   âœ… WDC 7mm ì¡°ì • ì„±ê³µ: ìµœì¢… ê±°ë¦¬ {final_distance:.2f}mm")
        
        return new_wdc_center, weldno_texts
        
    except Exception as e:
        print(f"   âŒ WDC ì¡°ì • ì¤‘ ì˜¤ë¥˜: {e}")
        return wdc_center, []

def process_mwd_rotation_and_connection(doc):
    """[5ë‹¨ê³„] MWD íšŒì „ ë° ìµœì¢… ì—°ê²° ì²˜ë¦¬ - ìš°ì„ ìˆœìœ„ ê¸°ë°˜ + SFW 7mm ì¡°ì •"""
    msp = doc.modelspace()
    
    # ì‚¬ìš©ëœ SW/SFW ì¶”ì  ë¦¬ìŠ¤íŠ¸
    used_sw_sfw = []
    
    print("\n[5ë‹¨ê³„] MWD íšŒì „ ë° ìµœì¢… ì—°ê²° ì‹œì‘ (ìš°ì„ ìˆœìœ„ ê¸°ë°˜ + SFW 7mm ì¡°ì •)")
    print("ê°„ì„­ íšŒí”¼ ìš°ì„ ìˆœìœ„:")
    print("1. TEXT ê°„ì„­ (ë¬´ì¡°ê±´ í”¼í•¨)")
    print("2. PIPE/ELBO ë ˆì´ì–´ ê°„ì„­")
    print("3. PCì™€ WDC ì› ì‚¬ì´ 2mm ì´í•˜")
    print("4. 30ë„ ë‹¨ìœ„ ì •ê°ë„ í´ë¦¬ë¼ì¸ ê°„ì„­")
    print("5. ì¼ë°˜ ê°„ì„­ ìµœì†Œí™”")
    print("\nğŸ†• SFW ì§€ì›: 6ì  í´ë¦¬ë¼ì¸ì˜ ì¤‘ì‹¬ì„ SW ì›ì²˜ëŸ¼ ì‚¬ìš©")
    print("ğŸ†• SFW 7mm ì¡°ì •: SFW ì¤‘ì‹¬ê³¼ WDC ì¤‘ì‹¬ì´ 7mm ì´í•˜ë©´ 7mmë¡œ ì´ë™ í›„ ê°„ì„­ ì²´í¬")
    print("ğŸ†• SFW PC ê²€ìƒ‰: SFW ì¤‘ì‹¬ì—ì„œ 7mm ë‚´ì˜ PIPE ì„  2ê°œ ì°¾ê¸°")
    print("ğŸš« SW/SFW ì‚¬ìš© ì œí•œ: ê° SW ì› ë˜ëŠ” SFW í´ë¦¬ë¼ì¸ì€ í•œ ë²ˆë§Œ ì‚¬ìš©")
    print("ğŸ—‘ï¸  ê¸°ì¡´ WG ì‚­ì œ: WDC ë° SW/SFW ê·¼ì²˜ì˜ ê¸°ì¡´ WG ì„ ì„ ë¨¼ì € ì‚­ì œ í›„ ìƒˆ ì—°ê²°ì„  ìƒì„±")
    print("ğŸ“ WG ê¸¸ì´ ì œí•œ: 40mm ì´ìƒì´ë©´ ìƒì„±í•˜ì§€ ì•ŠìŒ")
    print("ğŸ¯ WDCë‹¹ WG 1ê°œ: WDC ê·¼ì²˜ì˜ ëª¨ë“  ê¸°ì¡´ WG ì‚­ì œ")
    print("ğŸ†• WELDNO ì¡°ê±´: ê¸°ìš¸ê¸° 0ë„ + TEXT/INST/< í¬í•¨ ì œì™¸ + ìˆ«ì í¬í•¨ í•„ìˆ˜")
    
    try:
        # 1. ëª¨ë“  2.8mm WELD ì›ì— WDC ë ˆì´ì–´ í• ë‹¹ ë° YELLOW ìƒ‰ìƒ ì ìš©
        wdc_circles = []
        for entity in msp.query('CIRCLE'):
            try:
                if (hasattr(entity.dxf, 'color') and entity.dxf.color == 2 and  # ë…¸ë‘ìƒ‰
                    hasattr(entity.dxf, 'radius') and abs(entity.dxf.radius - 2.8) <= 0.3):
                    entity.dxf.layer = "WDC"
                    entity.dxf.color = 2  # YELLOW
                    wdc_circles.append(entity)
                    print(f"WDC ë ˆì´ì–´ í• ë‹¹ ë° YELLOW ìƒ‰ìƒ: ì›({entity.dxf.center.x:.2f}, {entity.dxf.center.y:.2f})")
            except Exception:
                continue
        
        print(f"âœ… WDC ë ˆì´ì–´ í• ë‹¹ ë° YELLOW ìƒ‰ìƒ ì ìš© ì™„ë£Œ: {len(wdc_circles)}ê°œ WELD ì›")
        
        # 2. ê° WDC ì›ì— ëŒ€í•´ MWD ê·¸ë£¹ ìƒì„±
        mwd_groups = []
        for wdc_circle in wdc_circles:
            try:
                wdc_center = Vec2(wdc_circle.dxf.center.x, wdc_circle.dxf.center.y)
                
                # WELDNO í…ìŠ¤íŠ¸ ì°¾ê¸° (3mm ë‚´)
                weldno_texts = []
                text_search_radius = 3.0
                
                for txt in msp.query('TEXT'):
                    try:
                        txt_pos = Vec2(txt.dxf.insert.x, txt.dxf.insert.y)
                        if distance(wdc_center, txt_pos) <= text_search_radius:
                            # í…ìŠ¤íŠ¸ ì—”í‹°í‹°ê°€ WDNOë¡œ ìœ íš¨í•œì§€ í™•ì¸ (ë‚´ìš© + ê¸°ìš¸ê¸°)
                            if is_valid_wdno_entity(txt):
                                txt.dxf.color = 4  # CYAN ìƒ‰ìƒ ì ìš©
                                txt.dxf.layer = "WDNO"  # WDNO ë ˆì´ì–´ ì ìš©
                                weldno_texts.append(txt)
                                # í…ìŠ¤íŠ¸ ë°•ìŠ¤ ì¤‘ì‹¬ì„ WELD ì› ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™
                                bbox = get_text_bounding_box(txt)
                                if bbox:
                                    offset = wdc_center - bbox['center']
                                    new_insert = Vec2(txt.dxf.insert.x + offset.x, 
                                                    txt.dxf.insert.y + offset.y)
                                    txt.dxf.insert = (new_insert.x, new_insert.y, 0)
                    except Exception:
                        continue
                
                # MWD ê·¸ë£¹ ìƒì„± (WDC + WELDNO í…ìŠ¤íŠ¸)
                mwd_group = {
                    'wdc_circle': wdc_circle,
                    'wdc_center': wdc_center,
                    'weldno_texts': weldno_texts,
                    'entities': [wdc_circle] + weldno_texts
                }
                mwd_groups.append(mwd_group)
                
            except Exception as e:
                print(f"MWD ê·¸ë£¹ ìƒì„± ì˜¤ë¥˜: {e}")
                continue
        
        print(f"ğŸ“¦ MWD ê·¸ë£¹ ìƒì„± ì™„ë£Œ: {len(mwd_groups)}ê°œ")
        
        # WDNO í…ìŠ¤íŠ¸ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ MWD ê·¸ë£¹ ì •ë ¬
        def extract_wdno_number(mwd_group):
            """WDNO í…ìŠ¤íŠ¸ì—ì„œ ìˆ«ìë¥¼ ì¶”ì¶œí•˜ëŠ” í•¨ìˆ˜"""
            try:
                for txt in mwd_group['weldno_texts']:
                    text_content = txt.dxf.text.strip()
                    # ìˆ«ìë§Œ ì¶”ì¶œ (ì˜ˆ: "W1", "1", "WELD1" ë“±ì—ì„œ ìˆ«ì ì¶”ì¶œ)
                    numbers = re.findall(r'\d+', text_content)
                    if numbers:
                        return int(numbers[0])
                return 999999  # ìˆ«ìê°€ ì—†ìœ¼ë©´ ë§¨ ë’¤ë¡œ
            except:
                return 999999
        
        # WDNO ê°’ìœ¼ë¡œ ì •ë ¬
        mwd_groups_sorted = sorted(mwd_groups, key=extract_wdno_number)
        
        print(f"ğŸ“‹ WDNO ê°’ ìˆœì„œë¡œ ì •ë ¬ ì™„ë£Œ (INST/TEXT/< í¬í•¨/ìˆ«ìì—†ëŠ” TEXT ì œì™¸):")
        for i, group in enumerate(mwd_groups_sorted):
            wdno_value = extract_wdno_number(group)
            if wdno_value != 999999:
                print(f"   {i+1}. WDNO: {wdno_value}")
            else:
                print(f"   {i+1}. WDNO: ìˆ«ì ì—†ìŒ")
        
        # 3. ì •ë ¬ëœ ìˆœì„œëŒ€ë¡œ ê° MWD ê·¸ë£¹ ì²˜ë¦¬
        processed_count = 0
        skipped_count = 0
        
        for i, mwd_group in enumerate(mwd_groups_sorted):
            try:
                wdc_circle = mwd_group['wdc_circle']
                wdc_center = mwd_group['wdc_center']
                
                print(f"\nğŸ” [{i+1}/{len(mwd_groups)}] MWD ì²˜ë¦¬: ({wdc_center.x:.2f}, {wdc_center.y:.2f})")
                
                # ì—°ê²°ëœ 1mm SW ì› ë˜ëŠ” SFW í´ë¦¬ë¼ì¸ ì°¾ê¸°
                sw_circle = None
                sw_center = None
                sw_layer = None
                sw_type = None  # 'CIRCLE' ë˜ëŠ” 'POLYLINE'
                nl1_exists = False
                
                # 1. ë¨¼ì € ê¸°ì¡´ NL1 ì„ ì„ í†µí•´ ì—°ê²°ëœ 1mm ì› ì°¾ê¸°
                for line in msp.query('LINE'):
                    try:
                        if hasattr(line.dxf, 'color') and line.dxf.color == 4:  # í°ìƒ‰ NL1
                            line_start = Vec2(line.dxf.start.x, line.dxf.start.y)
                            line_end = Vec2(line.dxf.end.x, line.dxf.end.y)
                            
                            # WDC ì›ê³¼ ì—°ê²°ëœ NL1ì¸ì§€ í™•ì¸
                            if distance(wdc_center, line_start) <= 3.5:
                                nl1_exists = True
                                # ë°˜ëŒ€ìª½ ëì— ìˆëŠ” 1mm ì› ì°¾ê¸°
                                for circle in msp.query('CIRCLE'):
                                    if (hasattr(circle.dxf, 'color') and circle.dxf.color == 2 and
                                        abs(circle.dxf.radius - 1.0) <= 0.1):
                                        circle_center = Vec2(circle.dxf.center.x, circle.dxf.center.y)
                                        if distance(circle_center, line_end) <= 1.5:
                                            # ì´ë¯¸ ì‚¬ìš©ëœ SWì¸ì§€ í™•ì¸
                                            if circle not in used_sw_sfw:
                                                sw_circle = circle
                                                sw_center = circle_center
                                                sw_layer = circle.dxf.layer if hasattr(circle.dxf, 'layer') else "0"
                                                sw_type = 'CIRCLE'
                                            break
                                if sw_circle:
                                    break
                    except Exception:
                        continue
                
                # 2. NL1ë¡œ ì—°ê²°ëœ ì›ì„ ì°¾ì§€ ëª»í•œ ê²½ìš°, WDCì— ì ‘í•˜ëŠ” WG ì„  ì°¾ê¸°
                if not sw_circle:
                    print(f"   âš ï¸  NL1 ì—°ê²°ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ - WDCì— ì ‘í•˜ëŠ” WG ì„  ê²€ìƒ‰")
                    
                    # WDCì— ì ‘í•˜ëŠ” WG ì„  ì°¾ê¸°
                    wg_search_radius = 3.5  # WDC ì› ê²½ê³„ ê·¼ì²˜
                    found_wg = False
                    
                    for line in msp.query('LINE'):
                        try:
                            if (hasattr(line.dxf, 'layer') and line.dxf.layer == 'WG' and
                                hasattr(line.dxf, 'color') and line.dxf.color == 7):  # WG ë ˆì´ì–´ + í°ìƒ‰
                                
                                line_start = Vec2(line.dxf.start.x, line.dxf.start.y)
                                line_end = Vec2(line.dxf.end.x, line.dxf.end.y)
                                
                                # WDC ì›ê³¼ ì—°ê²°ëœ WGì¸ì§€ í™•ì¸
                                dist_to_start = distance(wdc_center, line_start)
                                dist_to_end = distance(wdc_center, line_end)
                                
                                if dist_to_start <= wg_search_radius or dist_to_end <= wg_search_radius:
                                    print(f"   ğŸ” WG ì„  ë°œê²¬: ì‹œì‘({line_start.x:.2f}, {line_start.y:.2f}) - ë({line_end.x:.2f}, {line_end.y:.2f})")
                                    
                                    # WDCë¡œë¶€í„° ë¨¼ ìª½ ëì  ì°¾ê¸°
                                    far_point = line_end if dist_to_start < dist_to_end else line_start
                                    print(f"   ğŸ“ WDCë¡œë¶€í„° ë¨¼ ì : ({far_point.x:.2f}, {far_point.y:.2f})")
                                    
                                    # ë¨¼ ì  ê·¼ì²˜ì˜ SW ì› ì°¾ê¸°
                                    sw_search_radius = 2.0  # SW ì› ê²€ìƒ‰ ë°˜ê²½
                                    
                                    for circle in msp.query('CIRCLE'):
                                        try:
                                            if (hasattr(circle.dxf, 'color') and circle.dxf.color == 2 and
                                                abs(circle.dxf.radius - 1.0) <= 0.1):
                                                
                                                circle_layer = circle.dxf.layer if hasattr(circle.dxf, 'layer') else "0"
                                                circle_center = Vec2(circle.dxf.center.x, circle.dxf.center.y)
                                                
                                                # SW ë ˆì´ì–´ì´ê³  ë¨¼ ì  ê·¼ì²˜ì— ìˆìœ¼ë©° ë¯¸ì‚¬ìš©ì¸ ê²½ìš°
                                                if (circle_layer == "SW" and 
                                                    distance(far_point, circle_center) <= sw_search_radius and
                                                    circle not in used_sw_sfw):
                                                    
                                                    sw_circle = circle
                                                    sw_center = circle_center
                                                    sw_layer = circle_layer
                                                    sw_type = 'CIRCLE'
                                                    found_wg = True
                                                    print(f"   âœ… WG ëì  ê·¼ì²˜ì˜ SW ì› ë°œê²¬: ({sw_center.x:.2f}, {sw_center.y:.2f})")
                                                    break
                                        except Exception:
                                            continue
                                    
                                    if found_wg:
                                        break
                                    
                                    # SW ì›ì„ ëª» ì°¾ì•˜ìœ¼ë©´ SFW í´ë¦¬ë¼ì¸ë„ í™•ì¸
                                    sfw_polylines = find_sfw_polyline(msp, far_point, sw_search_radius)
                                    for sfw in sfw_polylines:
                                        if sfw['entity'] not in used_sw_sfw:
                                            sw_circle = sfw['entity']
                                            sw_center = sfw['center']
                                            sw_layer = "SFW"
                                            sw_type = 'POLYLINE'
                                            found_wg = True
                                            print(f"   âœ… WG ëì  ê·¼ì²˜ì˜ SFW í´ë¦¬ë¼ì¸ ë°œê²¬: ì¤‘ì‹¬({sw_center.x:.2f}, {sw_center.y:.2f})")
                                            break
                                    
                                    if found_wg:
                                        break
                        except Exception:
                            continue
                    
                    if not found_wg:
                        print(f"   ğŸ’¡ WG ì—°ê²°ì„ í†µí•œ SW/SFWë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                
                # 3. WGë¡œë„ ì—°ê²°ì„ ì°¾ì§€ ëª»í•œ ê²½ìš°, WDCì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ SW/SFW ì°¾ê¸°
                if not sw_circle:
                    print(f"   ğŸ” ìµœí›„ ìˆ˜ë‹¨: WDCì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ SW/SFW ê²€ìƒ‰")
                    
                    min_distance = float('inf')
                    closest_sw = None
                    closest_center = None
                    closest_layer = None
                    closest_type = None
                    
                    # SW ì› ì°¾ê¸°
                    for circle in msp.query('CIRCLE'):
                        try:
                            if (hasattr(circle.dxf, 'color') and circle.dxf.color == 2 and
                                abs(circle.dxf.radius - 1.0) <= 0.1):
                                
                                circle_layer = circle.dxf.layer if hasattr(circle.dxf, 'layer') else "0"
                                
                                # SW ë ˆì´ì–´ì´ê³  ì•„ì§ ì‚¬ìš©ë˜ì§€ ì•Šì€ ê²½ìš°
                                if circle_layer == "SW" and circle not in used_sw_sfw:
                                    circle_center = Vec2(circle.dxf.center.x, circle.dxf.center.y)
                                    dist = distance(wdc_center, circle_center)
                                    
                                    if dist < min_distance:
                                        min_distance = dist
                                        closest_sw = circle
                                        closest_center = circle_center
                                        closest_layer = circle_layer
                                        closest_type = 'CIRCLE'
                        except Exception:
                            continue
                    
                    # SFW í´ë¦¬ë¼ì¸ ì°¾ê¸°
                    sfw_polylines = find_sfw_polyline(msp, wdc_center, search_radius=50.0)
                    for sfw in sfw_polylines:
                        if sfw['entity'] not in used_sw_sfw and sfw['distance'] < min_distance:
                            min_distance = sfw['distance']
                            closest_sw = sfw['entity']
                            closest_center = sfw['center']
                            closest_layer = "SFW"
                            closest_type = 'POLYLINE'
                    
                    if closest_sw:
                        sw_circle = closest_sw
                        sw_center = closest_center
                        sw_layer = closest_layer
                        sw_type = closest_type
                        print(f"   ğŸ” ê°€ì¥ ê°€ê¹Œìš´ {sw_type} ë°œê²¬: {sw_layer} ë ˆì´ì–´, ì¤‘ì‹¬({sw_center.x:.2f}, {sw_center.y:.2f}), ê±°ë¦¬: {min_distance:.2f}mm")
                    else:
                        print(f"   âŒ ì‚¬ìš© ê°€ëŠ¥í•œ SW/SFWë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ - SKIP")
                        continue
                
                if not sw_circle:
                    print(f"   âŒ ì—°ê²°í•  SW/SFWë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ - SKIP")
                    continue
                
                print(f"   ğŸ”— {sw_type} ë°œê²¬: ({sw_center.x:.2f}, {sw_center.y:.2f}), ë ˆì´ì–´: {sw_layer}")
                
                # SW/SFW ì‚¬ìš© í‘œì‹œ
                used_sw_sfw.append(sw_circle)
                print(f"   âœ… {sw_type} ì‚¬ìš© í‘œì‹œ ì™„ë£Œ (ì¤‘ë³µ ì‚¬ìš© ë°©ì§€)")
                
                # SW ë˜ëŠ” SFW ì²˜ë¦¬
                if sw_layer in ["SW", "SFW"]:
                    print(f"   ğŸ¨ WDC: YELLOW, WELDNO: CYAN ìƒ‰ìƒ í™•ì¸")
                    print(f"   ğŸ”— {sw_layer} ë ˆì´ì–´ í™•ì¸")
                    
                    # SFWì™€ WDC ê±°ë¦¬ê°€ 7mm ì´í•˜ì¸ ê²½ìš° ì¡°ì •
                    if sw_type == 'POLYLINE' and sw_layer == "SFW":
                        original_wdc_center = Vec2(wdc_center.x, wdc_center.y)
                        wdc_center, moved_texts = adjust_wdc_for_sfw_7mm(wdc_circle, wdc_center, sw_center, msp)
                        
                        # WDCê°€ ì´ë™í–ˆìœ¼ë©´ MWD ê·¸ë£¹ì˜ ëª¨ë“  ì—”í‹°í‹° ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                        if wdc_center != original_wdc_center:
                            # ì´ë™ ë²¡í„° ê³„ì‚°
                            move_vec = wdc_center - original_wdc_center
                            
                            # MWD ê·¸ë£¹ì˜ wdc_center ì—…ë°ì´íŠ¸
                            mwd_group['wdc_center'] = wdc_center
                            
                            # entities ë¦¬ìŠ¤íŠ¸ì—ì„œ ì´ë™ëœ í…ìŠ¤íŠ¸ë“¤ì˜ ìœ„ì¹˜ í™•ì¸
                            # (ì´ë¯¸ adjust_wdc_for_sfw_7mmì—ì„œ ì´ë™ë¨)
                    
                    # SW/SFW ê·¼ì²˜ì˜ PC(PIPE ê´€ë ¨ ì„ ) ì°¾ê¸° - ê°œì„ ëœ í•¨ìˆ˜ ì‚¬ìš©
                    pipe_lines = find_pipe_lines_near_sw_improved(sw_circle, sw_center, sw_type, msp, 1.0)
                    if pipe_lines:
                        print(f"   ğŸ”§ PC(PIPE ê´€ë ¨ ì„ ) {len(pipe_lines)}ê°œ ë°œê²¬ (ìµœëŒ€ 2ê°œ)")
                        for j, pc in enumerate(pipe_lines):
                            print(f"      - PC{j+1}: {pc['type']} ë ˆì´ì–´, ìµœì†Œê±°ë¦¬ {pc['min_distance']:.2f}mm")
                    
                    # ê°„ì„­ ì²´í¬ë¥¼ ìœ„í•œ ì œì™¸ ì—”í‹°í‹°
                    exclude_entities = [sw_circle] + mwd_group['entities']
                    
                    # ëª¨ë“  íšŒì „ ê°ë„ì—ì„œ ê°„ì„­ ì •ë³´ ìˆ˜ì§‘
                    rotation_candidates = []
                    
                    # í˜„ì¬ ìœ„ì¹˜(0ë„) ì²´í¬
                    interference_info = check_mwd_interference_with_priority(
                        mwd_group['entities'], sw_center, 0, msp, exclude_entities, pipe_lines
                    )
                    rotation_candidates.append({
                        'angle': 0,
                        'degree': 0,
                        'interference': interference_info
                    })
                    
                    # 30ë„ ë‹¨ìœ„ë¡œ 360ë„ íšŒì „í•˜ë©° ê°„ì„­ ì²´í¬
                    for degree in range(30, 360, 30):
                        angle = math.radians(degree)
                        interference_info = check_mwd_interference_with_priority(
                            mwd_group['entities'], sw_center, angle, msp, exclude_entities, pipe_lines
                        )
                        rotation_candidates.append({
                            'angle': angle,
                            'degree': degree,
                            'interference': interference_info
                        })
                    
                    # ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ìµœì  ìœ„ì¹˜ ì„ íƒ
                    best_candidate = None
                    
                    # 1ìˆœìœ„: TEXT ê°„ì„­ì´ ì—†ëŠ” ìœ„ì¹˜ ì°¾ê¸°
                    text_free_candidates = [c for c in rotation_candidates if not c['interference']['text_interference']]
                    
                    if text_free_candidates:
                        print(f"   TEXT ê°„ì„­ ì—†ëŠ” ìœ„ì¹˜: {len(text_free_candidates)}ê°œ")
                        
                        # 2ìˆœìœ„: TEXT ê°„ì„­ ì—†ëŠ” ìœ„ì¹˜ ì¤‘ PIPE/ELBO ë ˆì´ì–´ ê°„ì„­ì´ ì—†ëŠ” ìœ„ì¹˜
                        pipe_free_candidates = [c for c in text_free_candidates if not c['interference']['pipe_layer_interference']]
                        
                        if pipe_free_candidates:
                            print(f"   PIPE/ELBO ë ˆì´ì–´ ê°„ì„­ë„ ì—†ëŠ” ìœ„ì¹˜: {len(pipe_free_candidates)}ê°œ")
                            
                            # 3ìˆœìœ„: PCì™€ WDC ì› ì‚¬ì´ 2mm ì´ìƒì¸ ìœ„ì¹˜
                            pc_free_candidates = [c for c in pipe_free_candidates if not c['interference']['pc_circle_interference']]
                            
                            if pc_free_candidates:
                                print(f"   PC-WDC ê±°ë¦¬ë„ 2mm ì´ìƒì¸ ìœ„ì¹˜: {len(pc_free_candidates)}ê°œ")
                                
                                # 4ìˆœìœ„: 30ë„ ë‹¨ìœ„ í´ë¦¬ë¼ì¸ ê°„ì„­ì´ ì—†ëŠ” ìœ„ì¹˜
                                polyline_free_candidates = [c for c in pc_free_candidates if not c['interference']['30degree_polyline_interference']]
                                
                                if polyline_free_candidates:
                                    print(f"   30ë„ ë‹¨ìœ„ í´ë¦¬ë¼ì¸ ê°„ì„­ë„ ì—†ëŠ” ìœ„ì¹˜: {len(polyline_free_candidates)}ê°œ")
                                    
                                    # 5ìˆœìœ„: ì¼ë°˜ ê°„ì„­ì´ ê°€ì¥ ì ì€ ìœ„ì¹˜
                                    best_candidate = min(polyline_free_candidates, key=lambda x: x['interference']['general_score'])
                                    print(f"   ìµœì  ìœ„ì¹˜: {best_candidate['degree']}ë„ (ì¼ë°˜ ê°„ì„­ ì ìˆ˜: {best_candidate['interference']['general_score']})")
                                else:
                                    # 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ì´ ëª¨ë‘ ìˆìœ¼ë©´ ì¼ë°˜ ê°„ì„­ì´ ê°€ì¥ ì ì€ ìœ„ì¹˜
                                    best_candidate = min(pc_free_candidates, key=lambda x: x['interference']['general_score'])
                                    print(f"   30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ì€ í”¼í•  ìˆ˜ ì—†ìŒ - ì¼ë°˜ ê°„ì„­ ìµœì†Œ ìœ„ì¹˜: {best_candidate['degree']}ë„")
                            else:
                                # PC ê°„ì„­ì´ ëª¨ë‘ ìˆìœ¼ë©´ 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ í™•ì¸
                                polyline_free_candidates = [c for c in pipe_free_candidates if not c['interference']['30degree_polyline_interference']]
                                
                                if polyline_free_candidates:
                                    best_candidate = min(polyline_free_candidates, key=lambda x: x['interference']['general_score'])
                                    print(f"   PC ê°„ì„­ì€ í”¼í•  ìˆ˜ ì—†ìŒ - 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ ì—†ê³  ì¼ë°˜ ê°„ì„­ ìµœì†Œ ìœ„ì¹˜: {best_candidate['degree']}ë„")
                                else:
                                    # PCì™€ 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ì´ ëª¨ë‘ ìˆìœ¼ë©´ ì¼ë°˜ ê°„ì„­ì´ ê°€ì¥ ì ì€ ìœ„ì¹˜
                                    best_candidate = min(pipe_free_candidates, key=lambda x: x['interference']['general_score'])
                                    print(f"   PCì™€ 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ ëª¨ë‘ í”¼í•  ìˆ˜ ì—†ìŒ - ì¼ë°˜ ê°„ì„­ ìµœì†Œ ìœ„ì¹˜: {best_candidate['degree']}ë„")
                        else:
                            # PIPE/ELBO ë ˆì´ì–´ ê°„ì„­ì´ ëª¨ë‘ ìˆìœ¼ë©´ PC ê°„ì„­ í™•ì¸
                            pc_free_candidates = [c for c in text_free_candidates if not c['interference']['pc_circle_interference']]
                            
                            if pc_free_candidates:
                                # 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ í™•ì¸
                                polyline_free_candidates = [c for c in pc_free_candidates if not c['interference']['30degree_polyline_interference']]
                                
                                if polyline_free_candidates:
                                    best_candidate = min(polyline_free_candidates, key=lambda x: x['interference']['general_score'])
                                    print(f"   PIPE/ELBO ê°„ì„­ì€ í”¼í•  ìˆ˜ ì—†ìŒ - PC ê°„ì„­ ì—†ê³  30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ ì—†ëŠ” ìœ„ì¹˜: {best_candidate['degree']}ë„")
                                else:
                                    best_candidate = min(pc_free_candidates, key=lambda x: x['interference']['general_score'])
                                    print(f"   PIPE/ELBOì™€ 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ì€ í”¼í•  ìˆ˜ ì—†ìŒ - PC ê°„ì„­ ì—†ëŠ” ìœ„ì¹˜: {best_candidate['degree']}ë„")
                            else:
                                # ëª¨ë“  ìš°ì„ ìˆœìœ„ ê°„ì„­ì´ ìˆìœ¼ë©´ ì¼ë°˜ ê°„ì„­ì´ ê°€ì¥ ì ì€ ìœ„ì¹˜
                                best_candidate = min(text_free_candidates, key=lambda x: x['interference']['general_score'])
                                print(f"   ëª¨ë“  ìš°ì„ ìˆœìœ„ ê°„ì„­ ì¡´ì¬ - ì¼ë°˜ ê°„ì„­ ìµœì†Œ ìœ„ì¹˜: {best_candidate['degree']}ë„")
                    else:
                        # TEXT ê°„ì„­ì„ í”¼í•  ìˆ˜ ì—†ëŠ” ê²½ìš° (ìµœì•…ì˜ ê²½ìš°)
                        print(f"   âš ï¸  ëª¨ë“  ìœ„ì¹˜ì—ì„œ TEXT ê°„ì„­ ë°œìƒ!")
                        best_candidate = min(rotation_candidates, key=lambda x: x['interference']['general_score'])
                        print(f"   TEXT ê°„ì„­ì„ í”¼í•  ìˆ˜ ì—†ìŒ - ìµœì†Œ ê°„ì„­ ìœ„ì¹˜: {best_candidate['degree']}ë„")
                    
                    if not best_candidate:
                        print(f"   âŒ ì ì ˆí•œ ìœ„ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ - SKIP")
                        continue
                    
                    # ì„ íƒëœ ê°ë„ë¡œ íšŒì „
                    final_angle = best_candidate['angle']
                    final_degree = best_candidate['degree']
                    
                    # ê°„ì„­ ìƒíƒœ ì¶œë ¥
                    print(f"   ğŸ“Š ì„ íƒëœ ìœ„ì¹˜ì˜ ê°„ì„­ ìƒíƒœ:")
                    print(f"      TEXT ê°„ì„­: {'ìˆìŒ' if best_candidate['interference']['text_interference'] else 'ì—†ìŒ'}")
                    print(f"      PIPE/ELBO ë ˆì´ì–´ ê°„ì„­: {'ìˆìŒ' if best_candidate['interference']['pipe_layer_interference'] else 'ì—†ìŒ'}")
                    print(f"      PC-WDC 2mm ì´í•˜: {'ìˆìŒ' if best_candidate['interference']['pc_circle_interference'] else 'ì—†ìŒ'}")
                    print(f"      30ë„ ë‹¨ìœ„ í´ë¦¬ë¼ì¸ ê°„ì„­: {'ìˆìŒ' if best_candidate['interference']['30degree_polyline_interference'] else 'ì—†ìŒ'}")
                    print(f"      ì¼ë°˜ ê°„ì„­ ì ìˆ˜: {best_candidate['interference']['general_score']}")
                    
                    # MWD íšŒì „ ì‹¤í–‰ (íšŒì „ì´ í•„ìš”í•œ ê²½ìš°ë§Œ)
                    if final_angle != 0:
                        for entity in mwd_group['entities']:
                            rotate_entity_around_point(entity, sw_center, final_angle)
                        
                        # íšŒì „ í›„ WELDNO í…ìŠ¤íŠ¸ë¥¼ WDC ì› ì¤‘ì‹¬ìœ¼ë¡œ ì¬ì •ë ¬
                        wdc_center_after_rotation = Vec2(wdc_circle.dxf.center.x, wdc_circle.dxf.center.y)
                        for txt in mwd_group['weldno_texts']:
                            # weldno_texts ë¦¬ìŠ¤íŠ¸ì—ëŠ” ì´ë¯¸ ê²€ì¦ëœ í…ìŠ¤íŠ¸ë§Œ ìˆìŒ
                            bbox = get_text_bounding_box(txt)
                            if bbox:
                                offset = wdc_center_after_rotation - bbox['center']
                                new_insert = Vec2(txt.dxf.insert.x + offset.x, 
                                                txt.dxf.insert.y + offset.y)
                                txt.dxf.insert = (new_insert.x, new_insert.y, 0)
                        print(f"   ğŸ”„ MWDë¥¼ {final_degree}ë„ íšŒì „ ì™„ë£Œ")
                    else:
                        print(f"   âœ… í˜„ì¬ ìœ„ì¹˜ê°€ ìµœì  - íšŒì „ ë¶ˆí•„ìš”")
                    
                    # íšŒì „ëœ WDC ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    rotated_wdc_center = Vec2(wdc_circle.dxf.center.x, wdc_circle.dxf.center.y)
                    
                    # ê¸°ì¡´ NL1 ì‚­ì œ (NL1ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš°ë§Œ)
                    if nl1_exists:
                        nl1_deleted = False
                        for line in list(msp.query('LINE')):
                            try:
                                if hasattr(line.dxf, 'color') and line.dxf.color == 4:  # í°ìƒ‰
                                    line_start = Vec2(line.dxf.start.x, line.dxf.start.y)
                                    line_end = Vec2(line.dxf.end.x, line.dxf.end.y)
                                    
                                    # ì´ MWDì™€ ì—°ê²°ëœ NL1ì¸ì§€ í™•ì¸ (íšŒì „ ì „ ìœ„ì¹˜ ê¸°ì¤€)
                                    if (distance(wdc_center, line_start) <= 3.5 or
                                        distance(rotated_wdc_center, line_start) <= 3.5):
                                        msp.delete_entity(line)
                                        nl1_deleted = True
                                        print(f"   ğŸ—‘ï¸  ê¸°ì¡´ NL1 ì‚­ì œ")
                                        break
                            except Exception:
                                continue
                    else:
                        print(f"   ğŸ’¡ NL1ì´ ì—†ì–´ ìƒˆë¡œìš´ WG ì—°ê²° ìƒì„±")
                    
                    # WDC ê·¼ì²˜ì˜ ê¸°ì¡´ WG ì„  ì‚­ì œ (WDCë‹¹ 1ê°œë§Œ ìœ ì§€)
                    print(f"   ğŸ” WDC ì¤‘ì‹¬ ê·¼ì²˜ì˜ ê¸°ì¡´ WG ì„  í™•ì¸ ì¤‘...")
                    wdc_wg_deleted = 0
                    wdc_wg_search_radius = 3.5  # WDC ì›ì—ì„œ 3.5mm ì´ë‚´ì˜ WG ì„  ì°¾ê¸°
                    
                    for line in list(msp.query('LINE')):
                        try:
                            if (hasattr(line.dxf, 'layer') and line.dxf.layer == 'WG' and
                                hasattr(line.dxf, 'color') and line.dxf.color == 7):  # WG ë ˆì´ì–´ + í°ìƒ‰
                                
                                line_start = Vec2(line.dxf.start.x, line.dxf.start.y)
                                line_end = Vec2(line.dxf.end.x, line.dxf.end.y)
                                
                                # WDC ì¤‘ì‹¬ì—ì„œ ì„ ì˜ ì–‘ ëì ê¹Œì§€ì˜ ê±°ë¦¬ í™•ì¸
                                dist_to_start = distance(rotated_wdc_center, line_start)
                                dist_to_end = distance(rotated_wdc_center, line_end)
                                
                                # ì–´ëŠ í•œ ëì ì´ë¼ë„ WDC ê·¼ì²˜ì— ìˆìœ¼ë©´ ì‚­ì œ
                                if dist_to_start <= wdc_wg_search_radius or dist_to_end <= wdc_wg_search_radius:
                                    msp.delete_entity(line)
                                    wdc_wg_deleted += 1
                                    print(f"      ğŸ—‘ï¸  ê¸°ì¡´ WG ì„  ì‚­ì œ: ì‹œì‘({line_start.x:.2f}, {line_start.y:.2f}) - ë({line_end.x:.2f}, {line_end.y:.2f})")
                        except Exception as e:
                            continue
                    
                    if wdc_wg_deleted > 0:
                        print(f"   âœ… WDC ê·¼ì²˜ì˜ ê¸°ì¡´ WG ì„  {wdc_wg_deleted}ê°œ ì‚­ì œ ì™„ë£Œ")
                    
                    # SW ì›ì— ì ‘í•˜ëŠ” ê¸°ì¡´ WG ì„  ì‚­ì œ
                    print(f"   ğŸ” SW/SFW ì¤‘ì‹¬ ê·¼ì²˜ì˜ ê¸°ì¡´ WG ì„  í™•ì¸ ì¤‘...")
                    existing_wg_deleted = 0
                    wg_search_radius = 2.0  # SW ì›ì—ì„œ 2mm ì´ë‚´ì˜ WG ì„  ì°¾ê¸°
                    
                    for line in list(msp.query('LINE')):
                        try:
                            if (hasattr(line.dxf, 'layer') and line.dxf.layer == 'WG' and
                                hasattr(line.dxf, 'color') and line.dxf.color == 7):  # WG ë ˆì´ì–´ + í°ìƒ‰
                                
                                line_start = Vec2(line.dxf.start.x, line.dxf.start.y)
                                line_end = Vec2(line.dxf.end.x, line.dxf.end.y)
                                
                                # SW/SFW ì¤‘ì‹¬ì—ì„œ ì„ ì˜ ì–‘ ëì ê¹Œì§€ì˜ ê±°ë¦¬ í™•ì¸
                                dist_to_start = distance(sw_center, line_start)
                                dist_to_end = distance(sw_center, line_end)
                                
                                # ì–´ëŠ í•œ ëì ì´ë¼ë„ SW/SFW ê·¼ì²˜ì— ìˆìœ¼ë©´ ì‚­ì œ
                                if dist_to_start <= wg_search_radius or dist_to_end <= wg_search_radius:
                                    msp.delete_entity(line)
                                    existing_wg_deleted += 1
                                    print(f"      ğŸ—‘ï¸  ê¸°ì¡´ WG ì„  ì‚­ì œ: ì‹œì‘({line_start.x:.2f}, {line_start.y:.2f}) - ë({line_end.x:.2f}, {line_end.y:.2f})")
                        except Exception as e:
                            continue
                    
                    if existing_wg_deleted > 0:
                        print(f"   âœ… SW/SFW ê·¼ì²˜ì˜ ê¸°ì¡´ WG ì„  {existing_wg_deleted}ê°œ ì‚­ì œ ì™„ë£Œ")
                    else:
                        print(f"   ğŸ’¡ SW/SFW ê·¼ì²˜ì— ê¸°ì¡´ WG ì„  ì—†ìŒ")
                    
                    # ìƒˆë¡œìš´ WG ì„ ì˜ ê¸¸ì´ ì²´í¬ (40mm ì´ìƒì´ë©´ ìƒì„±í•˜ì§€ ì•ŠìŒ)
                    wg_length = distance(sw_center, rotated_wdc_center)
                    if wg_length >= 40.0:
                        print(f"   âš ï¸  WG ì„  ê¸¸ì´ {wg_length:.2f}mm >= 40mm - WG ìƒì„± ê±´ë„ˆëœ€")
                        processed_count += 1
                        continue
                    
                    # ìƒˆë¡œìš´ í°ìƒ‰ ì„  ìƒì„± (SW/SFW ì¤‘ì‹¬ - WDC ì¤‘ì‹¬) + WG ë ˆì´ì–´
                    new_line = msp.add_line(
                        start=(sw_center.x, sw_center.y),
                        end=(rotated_wdc_center.x, rotated_wdc_center.y),
                        dxfattribs={'color': 7, 'layer': 'WG'}  # í°ìƒ‰ + WG ë ˆì´ì–´
                    )
                    print(f"   âœ… WG ì„  ìƒì„±: ê¸¸ì´ {wg_length:.2f}mm < 40mm")
                    
                    # WDC ì› ì•ˆì˜ ì„  TRIM
                    try:
                        # ì„ ì˜ ë°©í–¥ ë²¡í„°
                        direction = rotated_wdc_center - sw_center
                        if direction.magnitude > 0:
                            direction_normalized = direction.normalize()
                            # WDC ì› ê²½ê³„ì—ì„œ ì‹œì‘í•˜ë„ë¡ TRIM
                            trim_end = rotated_wdc_center - direction_normalized * wdc_circle.dxf.radius
                            new_line.dxf.end = (trim_end.x, trim_end.y, 0)
                            print(f"   âœ‚ï¸  WDC ì› ì•ˆì˜ ì„  TRIM ì™„ë£Œ")
                    except Exception as trim_e:
                        print(f"   âŒ TRIM ì˜¤ë¥˜: {trim_e}")
                    
                    processed_count += 1
                    print(f"   âœ… MWD íšŒì „ ë° ì—°ê²° ì™„ë£Œ ({sw_layer} ì‚¬ìš©)")
                    
            except Exception as e:
                print(f"âŒ MWD ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
                continue
        
        print(f"\nğŸ“Š [5ë‹¨ê³„] ìµœì¢… ê²°ê³¼:")
        print(f"   ğŸ“ ì²˜ë¦¬ëœ MWD: {processed_count}ê°œ")
        print(f"   â­ï¸  SKIPëœ MWD: {skipped_count}ê°œ")
        print(f"   ğŸ¨ ìƒ‰ìƒ: WDC(YELLOW), WELDNO(CYAN)")
        print(f"   ğŸ“ ë ˆì´ì–´: WDC(WDC), WELDNO(WDNO), ì—°ê²°ì„ (WG)")
        print(f"   ğŸ”„ íšŒì „: 30ë„ ë‹¨ìœ„ë¡œ 360ë„ ì‹œê³„ë°©í–¥ íšŒì „")
        print(f"   ğŸ†• WDNO í•„í„°ë§: INST/TEXT/< í¬í•¨, ìˆ«ì ì—†ëŠ” TEXT ì œì™¸")
        print(f"   ğŸ†• ê¸°ìš¸ê¸° 0ë„ í•„ìˆ˜: rotationì´ 0ì´ ì•„ë‹Œ TEXTëŠ” WELDNOì—ì„œ ì œì™¸")
        print(f"   ğŸ—‘ï¸  ê¸°ì¡´ WG ì‚­ì œ: WDC ë° SW/SFW ê·¼ì²˜ì˜ ê¸°ì¡´ WG ì„  ì œê±° í›„ ìƒˆ ì—°ê²°ì„  ìƒì„±")
        print(f"   ğŸ”— ìƒˆ ì—°ê²°ì„ : SW/SFW-WDC í°ìƒ‰ ì„  + WG ë ˆì´ì–´")
        print(f"   ğŸ“ WG ê¸¸ì´ ì œí•œ: 40mm ì´ìƒì´ë©´ ìƒì„± ì•ˆí•¨")
        print(f"   ğŸ¯ WDCë‹¹ WG 1ê°œ: WDC ê·¼ì²˜ì˜ ê¸°ì¡´ WG ëª¨ë‘ ì‚­ì œ í›„ ìƒˆë¡œ ìƒì„±")
        print(f"   âœ‚ï¸  TRIM ì™„ë£Œ: WDC ì› ë‚´ë¶€ ì„  ì œê±°")
        print(f"   ğŸ“ WELDNO ì¤‘ì‹¬ ì •ë ¬: íšŒì „ í›„ í•­ìƒ WDC ì¤‘ì‹¬ìœ¼ë¡œ ì¬ì •ë ¬")
        print(f"   ğŸ†• SFW ì§€ì›: 6ì  í´ë¦¬ë¼ì¸ ì¤‘ì‹¬ì„ SW ì›ì²˜ëŸ¼ ì‚¬ìš©")
        print(f"   ğŸ†• SFW 7mm ì¡°ì •: SFWì™€ WDC ê±°ë¦¬ê°€ 7mm ì´í•˜ë©´ 7mmë¡œ ì´ë™ í›„ ê°„ì„­ ì²´í¬")
        print(f"   ğŸ†• SFW PC ê²€ìƒ‰: SFW ì¤‘ì‹¬ì—ì„œ 7mm ë‚´ ê°€ì¥ ê°€ê¹Œìš´ PIPE ì„  2ê°œ")
        print(f"   ğŸš« SW/SFW í•œë²ˆë§Œ ì‚¬ìš©: ê° SW ì› ë˜ëŠ” SFW í´ë¦¬ë¼ì¸ì€ WDCë‹¹ í•œë²ˆë§Œ ì—°ê²°")
        print(f"   ğŸ†• NL1 ì—†ëŠ” ê²½ìš°: WDCì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë¯¸ì‚¬ìš© SW/SFW ìë™ ì—°ê²°")
        print(f"\n   ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ê°„ì„­ íšŒí”¼:")
        print(f"   1ï¸âƒ£ TEXT ê°„ì„­: í…ìŠ¤íŠ¸ ì‹œì‘ì /ëì  ê°„ ê±°ë¦¬ 5mm ì´ìƒ í™•ë³´")
        print(f"   2ï¸âƒ£ PIPE/ELBO ë ˆì´ì–´ ê°„ì„­: PIPE ë˜ëŠ” ELBO ì´ë¦„ í¬í•¨ ë ˆì´ì–´ì™€ ê²¹ì¹¨ ë°©ì§€")
        print(f"   3ï¸âƒ£ PC ê°„ì„­: WDC ì›ê³¼ PC ì„ ë¶„ ì‚¬ì´ 2mm ì´ìƒ ê±°ë¦¬ í™•ë³´")
        print(f"   4ï¸âƒ£ 30ë„ ë‹¨ìœ„ í´ë¦¬ë¼ì¸ ê°„ì„­: 0Â°, 30Â°, 60Â°... ê°ë„ì˜ í´ë¦¬ë¼ì¸ê³¼ ê²¹ì¹¨ ë°©ì§€")
        print(f"   5ï¸âƒ£ ì¼ë°˜ ê°„ì„­: ê¸°íƒ€ ëª¨ë“  ê°„ì„­ ìµœì†Œí™”")
        
        print("[5ë‹¨ê³„] MWD íšŒì „ ë° ìµœì¢… ì—°ê²° ì™„ë£Œ")
        
    except Exception as e:
        print(f"âŒ [5ë‹¨ê³„] ì²˜ë¦¬ ì¤‘ ì „ì²´ ì˜¤ë¥˜: {e}")
        print("[5ë‹¨ê³„] MWD íšŒì „ ë° ìµœì¢… ì—°ê²° ì‹¤íŒ¨")

### ë©”ì¸ ì‹¤í–‰ ###
if __name__ == "__main__":
    filepaths = select_dxf_files()
    for filepath in filepaths:
        doc = ezdxf.readfile(filepath)
        print(f"\nğŸ“‚ ì„ íƒëœ íŒŒì¼: {filepath}")

        print("\n[1ë‹¨ê³„] WELDNOEDIT ì‘ì—… ì‹œì‘ (í•„í„°ë§ ì ìš©)")
        process_weldnoedit(doc)
        print("[1ë‹¨ê³„] ì™„ë£Œ")

        print("\n[2ë‹¨ê³„] WELDSYMBOL ì‘ì—… ì‹œì‘ (í…ìŠ¤íŠ¸ ìˆ˜ì§‘ ì œê±°)")
        process_weldsymbol(doc)
        print("[2ë‹¨ê³„] ì™„ë£Œ")

        print("\n[3ë‹¨ê³„] NL1 ìƒì„± ë° 6mm ì§ì„ ê±°ë¦¬ ì œì–´ ì‹œì‘")
        process_nl1_distance_control(doc)
        print("[3ë‹¨ê³„] ì™„ë£Œ")

        print("\n[4ë‹¨ê³„] NL1 ê¸¸ì´ 7mm ì¡°ì • ì‹œì‘")
        process_nl1_length_adjustment(doc)
        print("[4ë‹¨ê³„] ì™„ë£Œ")
        
        print("\n[5ë‹¨ê³„] MWD íšŒì „ ë° ìµœì¢… ì—°ê²° ì‹œì‘")
        process_mwd_rotation_and_connection(doc)
        print("[5ë‹¨ê³„] ì™„ë£Œ")

        basename = os.path.splitext(os.path.basename(filepath))[0]
        output_dir = os.path.dirname(filepath)
        output_path = os.path.join(output_dir, basename + "_WDSYM.dxf")
        
        # íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ê±°ë‚˜ ê¶Œí•œì´ ì—†ëŠ” ê²½ìš° ë‹¤ë¥¸ ê²½ë¡œ ì‹œë„
        try:
            doc.saveas(output_path)
            print(f"\nâœ” ìµœì¢… ì €ì¥: {output_path}")
        except PermissionError:
            # ë°”íƒ•í™”ë©´ì— ì €ì¥ ì‹œë„
            import getpass
            username = getpass.getuser()
            desktop_path = f"C:/Users/{username}/Desktop/{basename}_WDSYM.dxf"
            try:
                doc.saveas(desktop_path)
                print(f"\nâœ” ê¶Œí•œ ì˜¤ë¥˜ë¡œ ë°”íƒ•í™”ë©´ì— ì €ì¥: {desktop_path}")
            except Exception as e:
                # í˜„ì¬ ë””ë ‰í† ë¦¬ì— ì €ì¥ ì‹œë„
                current_dir_path = f"./{basename}_WDSYM.dxf"
                try:
                    doc.saveas(current_dir_path)
                    print(f"\nâœ” í˜„ì¬ ë””ë ‰í† ë¦¬ì— ì €ì¥: {current_dir_path}")
                except Exception as e2:
                    print(f"\nâŒ ì €ì¥ ì‹¤íŒ¨: {e2}")