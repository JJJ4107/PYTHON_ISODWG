import ezdxf
import os
import math
from ezdxf.math import Vec2
from tkinter import Tk, filedialog

def distance(p1, p2):
    return math.hypot(p2.x - p1.x, p2.y - p1.y)

def point_to_segment_distance(p: Vec2, a: Vec2, b: Vec2) -> float:
    ap = p - a
    ab = b - a
    ab_len_squared = ab.dot(ab)
    if ab_len_squared == 0:
        return distance(p, a)
    t = max(0, min(1, ap.dot(ab) / ab_len_squared))
    projection = a + ab * t
    return distance(p, projection)

def get_line_angle(p1: Vec2, p2: Vec2) -> float:
    """ë‘ ì  ì‚¬ì´ì˜ ê°ë„ë¥¼ ë¼ë””ì•ˆìœ¼ë¡œ ë°˜í™˜"""
    return math.atan2(p2.y - p1.y, p2.x - p1.x)

def is_horizontal_text(text) -> bool:
    """í…ìŠ¤íŠ¸ê°€ ìˆ˜í‰(ê¸°ìš¸ê¸° 0)ì¸ì§€ í™•ì¸"""
    if hasattr(text.dxf, 'rotation'):
        return abs(text.dxf.rotation) < 0.1  # ì•½ê°„ì˜ ì˜¤ì°¨ í—ˆìš©
    return True

def get_text_bounding_box(text):
    """TEXT ì—”í‹°í‹°ì˜ ë°”ìš´ë”© ë°•ìŠ¤ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜"""
    try:
        # í…ìŠ¤íŠ¸ì˜ ê¸°ë³¸ ì†ì„±
        insert = Vec2(text.dxf.insert.x, text.dxf.insert.y)
        height = text.dxf.height
        
        # í…ìŠ¤íŠ¸ ë‚´ìš© ê¸¸ì´ (ëŒ€ëµì ì¸ ë„ˆë¹„ ê³„ì‚°)
        text_content = text.dxf.text
        width = len(text_content) * height * 0.7  # ëŒ€ëµì ì¸ ë¬¸ì ë„ˆë¹„ ë¹„ìœ¨
        
        # í…ìŠ¤íŠ¸ ì •ë ¬ ë°©ì‹ í™•ì¸ (ê¸°ë³¸ê°’ì€ LEFT)
        halign = text.dxf.halign if hasattr(text.dxf, 'halign') else 0
        valign = text.dxf.valign if hasattr(text.dxf, 'valign') else 0
        
        # ìˆ˜í‰ ì •ë ¬ì— ë”°ë¥¸ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
        if halign == 0:  # LEFT
            min_x = insert.x
            max_x = insert.x + width
        elif halign == 1:  # CENTER
            min_x = insert.x - width/2
            max_x = insert.x + width/2
        elif halign == 2:  # RIGHT
            min_x = insert.x - width
            max_x = insert.x
        else:
            min_x = insert.x
            max_x = insert.x + width
        
        # ìˆ˜ì§ ì •ë ¬ì— ë”°ë¥¸ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
        if valign == 0:  # BASELINE
            min_y = insert.y
            max_y = insert.y + height
        elif valign == 1:  # BOTTOM
            min_y = insert.y
            max_y = insert.y + height
        elif valign == 2:  # MIDDLE
            min_y = insert.y - height/2
            max_y = insert.y + height/2
        elif valign == 3:  # TOP
            min_y = insert.y - height
            max_y = insert.y
        else:
            min_y = insert.y
            max_y = insert.y + height
        
        # ë°”ìš´ë”© ë°•ìŠ¤ ì¤‘ì‹¬
        center = Vec2((min_x + max_x)/2, (min_y + max_y)/2)
        
        return {
            'center': center,
            'width': width,
            'height': height,
            'min_x': min_x,
            'max_x': max_x,
            'min_y': min_y,
            'max_y': max_y
        }
    except Exception as e:
        print(f"í…ìŠ¤íŠ¸ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚° ì˜¤ë¥˜: {e}")
        return None

def get_text_start_end_points(text):
    """TEXT ì—”í‹°í‹°ì˜ ì‹œì‘ì ê³¼ ëì ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜"""
    try:
        # í…ìŠ¤íŠ¸ ê¸°ë³¸ ì†ì„±
        insert = Vec2(text.dxf.insert.x, text.dxf.insert.y)
        height = text.dxf.height
        text_content = text.dxf.text
        
        # í…ìŠ¤íŠ¸ ë„ˆë¹„ ê³„ì‚° (ëŒ€ëµì ì¸ ë¹„ìœ¨)
        width = len(text_content) * height * 0.7
        
        # íšŒì „ ê°ë„ (ë¼ë””ì•ˆ)
        rotation = text.dxf.rotation if hasattr(text.dxf, 'rotation') else 0
        rotation_rad = math.radians(rotation)
        
        # ì •ë ¬ ë°©ì‹
        halign = text.dxf.halign if hasattr(text.dxf, 'halign') else 0
        
        # ê¸°ë³¸ ì‹œì‘ì ê³¼ ëì  (íšŒì „ ì „)
        if halign == 0:  # LEFT
            start_x = 0
            end_x = width
        elif halign == 1:  # CENTER
            start_x = -width/2
            end_x = width/2
        elif halign == 2:  # RIGHT
            start_x = -width
            end_x = 0
        else:
            start_x = 0
            end_x = width
        
        # íšŒì „ ì ìš©
        cos_r = math.cos(rotation_rad)
        sin_r = math.sin(rotation_rad)
        
        # ì‹œì‘ì 
        start_rotated_x = start_x * cos_r
        start_rotated_y = start_x * sin_r
        start_point = Vec2(insert.x + start_rotated_x, insert.y + start_rotated_y)
        
        # ëì 
        end_rotated_x = end_x * cos_r
        end_rotated_y = end_x * sin_r
        end_point = Vec2(insert.x + end_rotated_x, insert.y + end_rotated_y)
        
        return start_point, end_point
        
    except Exception as e:
        print(f"í…ìŠ¤íŠ¸ ì‹œì‘/ëì  ê³„ì‚° ì˜¤ë¥˜: {e}")
        return None, None

def check_text_endpoint_interference(text_entity, msp, exclude_entities, min_distance=5.0, check_center=None, check_radius=25.0):
    """TEXT ì—”í‹°í‹°ì˜ ì‹œì‘ì /ëì ì´ ë‹¤ë¥¸ TEXTì˜ ì‹œì‘ì /ëì ì—ì„œ 5mm ì´ë‚´ë©´ ê°„ì„­ìœ¼ë¡œ íŒì • - ëª¨ë“  ë ˆì´ì–´ í¬í•¨"""
    try:
        # í˜„ì¬ í…ìŠ¤íŠ¸ì˜ ì‹œì‘ì ê³¼ ëì 
        start1, end1 = get_text_start_end_points(text_entity)
        if not start1 or not end1:
            return False
        
        # ì²´í¬ ì¤‘ì‹¬ì´ ì£¼ì–´ì§„ ê²½ìš°, í…ìŠ¤íŠ¸ê°€ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
        text_center = Vec2((start1.x + end1.x) / 2, (start1.y + end1.y) / 2)
        if check_center and distance(text_center, check_center) > check_radius:
            return False
        
        # í˜„ì¬ í…ìŠ¤íŠ¸ì˜ ë°”ìš´ë”© ë°•ìŠ¤ë„ ê°€ì ¸ì˜¤ê¸°
        bbox1 = get_text_bounding_box(text_entity)
        if not bbox1:
            return False
        
        for e in msp:
            if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
                continue
            
            # ëª¨ë“  TEXT/MTEXT ì²´í¬ - ë ˆì´ì–´ êµ¬ë¶„ ì—†ìŒ
            if e.dxftype() in ("TEXT", "MTEXT"):
                # ìƒëŒ€ í…ìŠ¤íŠ¸ë„ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                if e.dxftype() == "TEXT":
                    start2, end2 = get_text_start_end_points(e)
                    if not start2 or not end2:
                        continue
                    bbox2 = get_text_bounding_box(e)
                else:  # MTEXT
                    # MTEXTì˜ ê²½ìš° insert pointë§Œ ì²´í¬
                    insert_pos = Vec2(e.dxf.insert.x, e.dxf.insert.y)
                    start2 = end2 = insert_pos
                    bbox2 = None
                
                other_center = Vec2((start2.x + end2.x) / 2, (start2.y + end2.y) / 2)
                if check_center and distance(other_center, check_center) > check_radius:
                    continue
                
                # 1. ëì  ê°„ ê±°ë¦¬ ì²´í¬ (ê¸°ì¡´ ë°©ì‹)
                endpoints_too_close = (
                    distance(start1, start2) < min_distance or
                    distance(start1, end2) < min_distance or
                    distance(end1, start2) < min_distance or
                    distance(end1, end2) < min_distance
                )
                
                # 2. ë°”ìš´ë”© ë°•ìŠ¤ ì¤‘ì‹¬ ê°„ ê±°ë¦¬ ì²´í¬ (ì¶”ê°€)
                bbox_too_close = False
                if bbox1 and bbox2:
                    center_distance = distance(bbox1['center'], bbox2['center'])
                    # ë‘ í…ìŠ¤íŠ¸ì˜ í¬ê¸°ë¥¼ ê³ ë ¤í•œ ìµœì†Œ ê±°ë¦¬
                    # í…ìŠ¤íŠ¸ ë†’ì´ ê¸°ì¤€ìœ¼ë¡œ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
                    min_center_distance = max(bbox1['height'], bbox2['height']) * 1.5
                    bbox_too_close = center_distance < min_center_distance
                
                if endpoints_too_close or bbox_too_close:
                    return True
        
        return False
    except Exception as e:
        print(f"í…ìŠ¤íŠ¸ ëì  ê°„ì„­ ì²´í¬ ì˜¤ë¥˜: {e}")
        return False

def check_pipe_layer_interference(wd_entities, msp, exclude_entities, check_radius=25.0):
    """PIPE ë˜ëŠ” ELBOë¥¼ í¬í•¨í•˜ëŠ” ë ˆì´ì–´ì™€ì˜ ê°„ì„­ì„ ì²´í¬ (25mm ë²”ìœ„ ë‚´ë§Œ)"""
    try:
        # WDC ì› ì°¾ê¸°
        wdc_center = None
        for wd_entity in wd_entities:
            if wd_entity.dxftype() == 'CIRCLE' and 1.5 <= wd_entity.dxf.radius <= 3.2:  # ì§€ë¦„ 3~6.4mm
                wdc_center = Vec2(wd_entity.dxf.center.x, wd_entity.dxf.center.y)
                break
        
        if not wdc_center:
            return False
        
        for wd_entity in wd_entities:
            if wd_entity.dxftype() == 'CIRCLE':
                circle_center = Vec2(wd_entity.dxf.center.x, wd_entity.dxf.center.y)
                circle_radius = wd_entity.dxf.radius
                
                # ëª¨ë“  ì—”í‹°í‹° ê²€ì‚¬
                for e in msp:
                    if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
                        continue
                    
                    # ë ˆì´ì–´ ì´ë¦„ì— PIPE, ELBO, ë˜ëŠ” ë‹¤ë¥¸ ì¤‘ìš” í‚¤ì›Œë“œê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
                    if hasattr(e.dxf, 'layer'):
                        layer_name = e.dxf.layer.upper()
                        # ë” ë§ì€ ë ˆì´ì–´ íƒ€ì… ì²´í¬
                        if any(keyword in layer_name for keyword in ['PIPE', 'ELBO', 'FITTING', 'VALVE', 'FLANGE']):
                            if e.dxftype() in ("LINE", "POLYLINE", "LWPOLYLINE", "ARC", "CIRCLE"):
                                # ì„ ë¶„ê³¼ì˜ ê±°ë¦¬ ì²´í¬
                                if e.dxftype() == "LINE":
                                    start = Vec2(e.dxf.start.x, e.dxf.start.y)
                                    end = Vec2(e.dxf.end.x, e.dxf.end.y)
                                    
                                    # 25mm ë²”ìœ„ ë‚´ì¸ì§€ í™•ì¸
                                    if (distance(wdc_center, start) > check_radius and 
                                        distance(wdc_center, end) > check_radius):
                                        continue
                                    
                                    dist = point_to_segment_distance(circle_center, start, end)
                                    if dist < circle_radius:
                                        return True
                                elif e.dxftype() == "ARC":
                                    arc_center = Vec2(e.dxf.center.x, e.dxf.center.y)
                                    if distance(wdc_center, arc_center) <= check_radius:
                                        if distance(circle_center, arc_center) < (e.dxf.radius + circle_radius):
                                            return True
                                elif e.dxftype() == "CIRCLE":
                                    entity_center = Vec2(e.dxf.center.x, e.dxf.center.y)
                                    if distance(wdc_center, entity_center) <= check_radius:
                                        if distance(circle_center, entity_center) < (e.dxf.radius + circle_radius):
                                            return True
                                else:
                                    # í´ë¦¬ë¼ì¸
                                    if e.dxftype() == "POLYLINE":
                                        pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
                                    else:
                                        pts = [Vec2(x, y) for x, y, *_ in e.get_points()]
                                    
                                    # 25mm ë²”ìœ„ ë‚´ì— ì ì´ ìˆëŠ”ì§€ í™•ì¸
                                    in_range = False
                                    for pt in pts:
                                        if distance(wdc_center, pt) <= check_radius:
                                            in_range = True
                                            break
                                    
                                    if in_range:
                                        for i in range(len(pts) - 1):
                                            dist = point_to_segment_distance(circle_center, pts[i], pts[i+1])
                                            if dist < circle_radius:
                                                return True
        
        return False
    except Exception as e:
        print(f"PIPE/ELBO ë ˆì´ì–´ ê°„ì„­ ì²´í¬ ì˜¤ë¥˜: {e}")
        return False

def check_30degree_polyline_interference(wd_entities, msp, exclude_entities, check_radius=25.0):
    """30ë„ ë‹¨ìœ„ ì •ê°ë„ë¥¼ ê°€ì§„ í´ë¦¬ë¼ì¸/LWí´ë¦¬ë¼ì¸ê³¼ì˜ ê°„ì„­ì„ ì²´í¬ (25mm ë²”ìœ„ ë‚´ë§Œ)"""
    try:
        # WDC ì› ì°¾ê¸°
        wdc_center = None
        for wd_entity in wd_entities:
            if wd_entity.dxftype() == 'CIRCLE' and 1.5 <= wd_entity.dxf.radius <= 3.2:  # ì§€ë¦„ 3~6.4mm
                wdc_center = Vec2(wd_entity.dxf.center.x, wd_entity.dxf.center.y)
                break
        
        if not wdc_center:
            return False
        
        for wd_entity in wd_entities:
            if wd_entity.dxftype() == 'CIRCLE':
                circle_center = Vec2(wd_entity.dxf.center.x, wd_entity.dxf.center.y)
                circle_radius = wd_entity.dxf.radius
                
                # ëª¨ë“  í´ë¦¬ë¼ì¸ ê²€ì‚¬
                for e in msp.query("POLYLINE LWPOLYLINE"):
                    if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
                        continue
                    
                    # í´ë¦¬ë¼ì¸ì˜ ì ë“¤ ê°€ì ¸ì˜¤ê¸°
                    if e.dxftype() == "POLYLINE":
                        pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
                    else:
                        pts = [Vec2(x, y) for x, y, *_ in e.get_points()]
                    
                    if len(pts) < 2:
                        continue
                    
                    # 25mm ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                    in_range = False
                    for pt in pts:
                        if distance(wdc_center, pt) <= check_radius:
                            in_range = True
                            break
                    
                    if not in_range:
                        continue
                    
                    # ê° ì„ ë¶„ì˜ ê°ë„ ì²´í¬
                    for i in range(len(pts) - 1):
                        p1, p2 = pts[i], pts[i+1]
                        
                        # ì„ ë¶„ì˜ ê°ë„ ê³„ì‚° (ë¼ë””ì•ˆ)
                        dx = p2.x - p1.x
                        dy = p2.y - p1.y
                        angle_rad = math.atan2(dy, dx)
                        
                        # ê°ë„ë¥¼ 0~360ë„ë¡œ ë³€í™˜
                        angle_deg = math.degrees(angle_rad) % 360
                        
                        # 30ë„ ë‹¨ìœ„ë¡œ ë°˜ì˜¬ë¦¼
                        nearest_30 = round(angle_deg / 30) * 30
                        
                        # ì •í™•íˆ 30ë„ ë‹¨ìœ„ì¸ì§€ í™•ì¸ (ì˜¤ì°¨ 1ë„ ì´ë‚´)
                        if abs(angle_deg - nearest_30) < 1.0:
                            # ì›ê³¼ ì„ ë¶„ì˜ ê±°ë¦¬ ì²´í¬
                            dist = point_to_segment_distance(circle_center, p1, p2)
                            if dist < circle_radius:
                                return True
        
        return False
    except Exception as e:
        print(f"30ë„ ë‹¨ìœ„ í´ë¦¬ë¼ì¸ ê°„ì„­ ì²´í¬ ì˜¤ë¥˜: {e}")
        return False

def check_circle_to_segments_distance(circle_center, circle_radius, segments, min_distance=1.0):
    """ì›ê³¼ ì„ ë¶„ë“¤ ì‚¬ì´ì˜ ìµœì†Œ ê±°ë¦¬ê°€ min_distance ì´í•˜ì¸ì§€ í™•ì¸"""
    for start, end in segments:
        # ì›ì˜ ì¤‘ì‹¬ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬
        dist_to_segment = point_to_segment_distance(circle_center, start, end)
        
        # ì›ì˜ ì™¸ê³½ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬ = ì¤‘ì‹¬ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬ - ë°˜ì§€ë¦„
        dist_from_circle_edge = dist_to_segment - circle_radius
        
        # ì„ ë¶„ì´ ì› ë‚´ë¶€ë¥¼ í†µê³¼í•˜ëŠ” ê²½ìš°ë„ ê°„ì„­ìœ¼ë¡œ ì²˜ë¦¬
        if dist_to_segment < circle_radius:
            return True
        
        # ì›ì˜ ì™¸ê³½ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬ê°€ min_distance ì´í•˜ë©´ ê°„ì„­
        if dist_from_circle_edge <= min_distance:
            return True
    
    return False

def get_iso_orthogonal_angle(wa_angle_deg):
    """ISO ë„ë©´ì—ì„œ WA ê°ë„ì— ëŒ€í•œ ì§êµ ê°ë„ë¥¼ ë°˜í™˜
    ë°°ê´€ ISO ë„ë©´ì˜ í‘œì¤€ ì§êµ ê´€ê³„:
    - 30Â° â†” 330Â° (ì„œë¡œ ì§êµ)
    - 90Â° â†” 270Â° (ì„œë¡œ ì§êµ)
    - 150Â° â†” 210Â° (ì„œë¡œ ì§êµ)
    """
    
    # WA ê°ë„ë¥¼ 0-360 ë²”ìœ„ë¡œ ì •ê·œí™”
    wa_angle_norm = wa_angle_deg % 360
    
    # ê°€ì¥ ê°€ê¹Œìš´ 30ë„ ë‹¨ìœ„ ê°ë„ë¡œ ë°˜ì˜¬ë¦¼
    nearest_30 = round(wa_angle_norm / 30) * 30
    nearest_30 = nearest_30 % 360
    
    # ë°°ê´€ ISO ë„ë©´ì˜ ì§êµ ê´€ê³„ ë§¤í•‘
    # ê° WA ê°ë„ì— ëŒ€í•´ ê°€ëŠ¥í•œ PIPE ì§êµ ê°ë„ë“¤
    iso_orthogonal_map = {
        0: [90, 270],      # 0Â° (ìˆ˜í‰) â†’ 90Â°, 270Â° (ìˆ˜ì§)
        30: [330],         # 30Â° â†’ 330Â° (ISO í‘œì¤€ ì§êµ)
        60: [150, 330],    # 60Â° â†’ 150Â°, 330Â°
        90: [270],         # 90Â° â†’ 270Â° (ISO í‘œì¤€ ì§êµ)
        120: [30, 210],    # 120Â° â†’ 30Â°, 210Â°
        150: [210],        # 150Â° â†’ 210Â° (ISO í‘œì¤€ ì§êµ)
        180: [90, 270],    # 180Â° (ìˆ˜í‰) â†’ 90Â°, 270Â° (ìˆ˜ì§)
        210: [150],        # 210Â° â†’ 150Â° (ISO í‘œì¤€ ì§êµ)
        240: [150, 330],   # 240Â° â†’ 150Â°, 330Â°
        270: [90],         # 270Â° â†’ 90Â° (ISO í‘œì¤€ ì§êµ)
        300: [30, 210],    # 300Â° â†’ 30Â°, 210Â°
        330: [30],         # 330Â° â†’ 30Â° (ISO í‘œì¤€ ì§êµ)
    }
    
    if nearest_30 in iso_orthogonal_map:
        return iso_orthogonal_map[nearest_30]
    else:
        # ê¸°ë³¸ê°’: 90Â°, 270Â° (ìˆ˜ì§ ë°©í–¥)
        return [90, 270]

def calculate_wa_line_to_pipe_angle(wa_angle, pipe_lines):
    """WA ë¼ì¸ê³¼ PIPE ë¼ì¸ ì‚¬ì´ì˜ ê°ë„ ì°¨ì´ë¥¼ ê³„ì‚°í•˜ê³  ISO ë„ë©´ ì§êµì„±ì„ í‰ê°€
    ë°°ê´€ ISO ë„ë©´ì˜ í‘œì¤€ ì§êµ ê´€ê³„ ì‚¬ìš©:
    - 30Â° â†” 330Â°
    - 90Â° â†” 270Â°
    - 150Â° â†” 210Â°
    """
    if not pipe_lines:
        return None
    
    orthogonality_score = float('inf')  # 0ì´ ì™„ë²½í•œ ì§êµ
    best_pipe_angle = 0
    best_target_angle = 0
    
    # WA ë¼ì¸ì˜ ê°ë„ (ë„ ë‹¨ìœ„)
    wa_angle_deg = math.degrees(wa_angle) % 360
    
    # WA ê°ë„ì— ëŒ€í•œ ISO ì§êµ ê°ë„ë“¤ ê°€ì ¸ì˜¤ê¸°
    orthogonal_angles = get_iso_orthogonal_angle(wa_angle_deg)
    
    for pipe in pipe_lines:
        for segment in pipe['segments']:
            start, end = segment
            pipe_angle = math.atan2(end.y - start.y, end.x - start.x)
            pipe_angle_deg = math.degrees(pipe_angle) % 360
            
            # PIPE ê°ë„ì™€ ê° ì§êµ ê°ë„ì™€ì˜ ì°¨ì´ ê³„ì‚°
            for ortho_angle in orthogonal_angles:
                diff = abs(pipe_angle_deg - ortho_angle)
                if diff > 180:
                    diff = 360 - diff
                
                if diff < orthogonality_score:
                    orthogonality_score = diff
                    best_pipe_angle = pipe_angle_deg
                    best_target_angle = ortho_angle
    
    return {
        'orthogonality_score': orthogonality_score,  # 0ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ì§êµì— ê°€ê¹Œì›€
        'pipe_angle': best_pipe_angle,
        'target_angle': best_target_angle,  # ëª©í‘œ ì§êµ ê°ë„
        'wa_angle': wa_angle_deg,
        'orthogonal_angles': orthogonal_angles  # ê°€ëŠ¥í•œ ì§êµ ê°ë„ë“¤
    }

def check_interference_at_position_detailed(test_center, msp, exclude_entities, weld_radius=3.0, check_radius=25.0):
    """íŠ¹ì • ìœ„ì¹˜ì—ì„œì˜ ê°„ì„­ì„ ì²´í¬í•˜ëŠ” í•¨ìˆ˜ (ìƒì„¸ ì •ë³´ í¬í•¨)"""
    interference_count = 0
    interference_details = []
    
    for e in msp:
        if e in exclude_entities or not hasattr(e, "dxf") or e.dxf is None:
            continue
        
        # ë ˆì´ì–´ë³„ ì œì™¸ ì—†ìŒ - DIMLINES í¬í•¨ ëª¨ë“  ë ˆì´ì–´ ì²´í¬
        
        # ì—”í‹°í‹°ê°€ 25mm ë²”ìœ„ ë°–ì´ë©´ ê±´ë„ˆë›°ê¸° (ë¹ ë¥¸ í•„í„°ë§)
        if hasattr(e, 'dxf'):
            entity_pos = None
            max_entity_radius = 0
            
            if e.dxftype() == "CIRCLE":
                entity_pos = Vec2(e.dxf.center.x, e.dxf.center.y)
                max_entity_radius = e.dxf.radius
            elif e.dxftype() in ("TEXT", "MTEXT"):
                entity_pos = Vec2(e.dxf.insert.x, e.dxf.insert.y)
            elif e.dxftype() == "LINE":
                # ì„ ë¶„ì˜ ì¤‘ì 
                start = Vec2(e.dxf.start.x, e.dxf.start.y)
                end = Vec2(e.dxf.end.x, e.dxf.end.y)
                entity_pos = Vec2((start.x + end.x) / 2, (start.y + end.y) / 2)
                max_entity_radius = distance(start, end) / 2
            elif e.dxftype() == "INSERT":  # ë¸”ë¡ ì°¸ì¡°
                entity_pos = Vec2(e.dxf.insert.x, e.dxf.insert.y)
            elif e.dxftype() == "DIMENSION":  # ì¹˜ìˆ˜ì„ 
                if hasattr(e.dxf, 'defpoint'):
                    entity_pos = Vec2(e.dxf.defpoint.x, e.dxf.defpoint.y)
            
            # ëŒ€ëµì ì¸ ê±°ë¦¬ë¡œ ë²”ìœ„ ë°– ì—”í‹°í‹° í•„í„°ë§
            if entity_pos and distance(test_center, entity_pos) > check_radius + max_entity_radius + weld_radius:
                continue
        
        layer_name = e.dxf.layer if hasattr(e.dxf, 'layer') else 'NO_LAYER'
        interference_found = False
        
        if e.dxftype() in ("TEXT", "MTEXT"):
            # ì›ê³¼ í…ìŠ¤íŠ¸ ê°„ì˜ ê±°ë¦¬ ì²´í¬
            text_pos = Vec2(e.dxf.insert.x, e.dxf.insert.y)
            if distance(test_center, text_pos) < weld_radius:
                interference_count += 1
                interference_found = True
                
        elif e.dxftype() == "LINE":
            # LINE ì—”í‹°í‹°ì™€ì˜ ê°„ì„­ ì²´í¬ - DIMLINES ë ˆì´ì–´ í¬í•¨
            start = Vec2(e.dxf.start.x, e.dxf.start.y)
            end = Vec2(e.dxf.end.x, e.dxf.end.y)
            
            # 20mm ë²”ìœ„ ë‚´ì¸ì§€ í™•ì¸
            if (distance(test_center, start) <= check_radius or 
                distance(test_center, end) <= check_radius or
                point_to_segment_distance(test_center, start, end) <= check_radius):
                
                # ì„ ë¶„ê³¼ì˜ ê±°ë¦¬ê°€ weld_radius ì´ë‚´ë©´ ê°„ì„­
                if point_to_segment_distance(test_center, start, end) < weld_radius:
                    interference_count += 1
                    interference_found = True
                
        elif e.dxftype() in ("POLYLINE", "LWPOLYLINE"):
            if e.dxftype() == "POLYLINE":
                pts = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
            else:
                pts = [Vec2(x, y) for x, y, *_ in e.get_points()]
            
            # í´ë¦¬ë¼ì¸ì´ 20mm ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
            in_range = False
            for pt in pts:
                if distance(test_center, pt) <= check_radius:
                    in_range = True
                    break
            
            if in_range:
                for i in range(len(pts) - 1):
                    if point_to_segment_distance(test_center, pts[i], pts[i+1]) < weld_radius:
                        interference_count += 1
                        interference_found = True
                        break
                    
        elif e.dxftype() == "CIRCLE":
            circle_center = Vec2(e.dxf.center.x, e.dxf.center.y)
            if distance(circle_center, test_center) < (e.dxf.radius + weld_radius):
                interference_count += 1
                interference_found = True
                
        elif e.dxftype() == "ARC":
            # ARC ì—”í‹°í‹° ì²´í¬
            arc_center = Vec2(e.dxf.center.x, e.dxf.center.y)
            if distance(arc_center, test_center) < (e.dxf.radius + weld_radius):
                interference_count += 1
                interference_found = True
                
        elif e.dxftype() == "INSERT":
            # ë¸”ë¡ ì°¸ì¡° ì²´í¬
            insert_pos = Vec2(e.dxf.insert.x, e.dxf.insert.y)
            if distance(test_center, insert_pos) < weld_radius:
                interference_count += 1
                interference_found = True
                
        elif e.dxftype() == "DIMENSION":
            # ì¹˜ìˆ˜ì„  ì²´í¬
            try:
                # ì¹˜ìˆ˜ì„ ì˜ ì—¬ëŸ¬ ì ë“¤ ì²´í¬
                if hasattr(e.dxf, 'defpoint'):
                    defpoint = Vec2(e.dxf.defpoint.x, e.dxf.defpoint.y)
                    if distance(test_center, defpoint) < weld_radius:
                        interference_count += 1
                        interference_found = True
                if not interference_found and hasattr(e.dxf, 'defpoint2'):
                    defpoint2 = Vec2(e.dxf.defpoint2.x, e.dxf.defpoint2.y)
                    if distance(test_center, defpoint2) < weld_radius:
                        interference_count += 1
                        interference_found = True
                if not interference_found and hasattr(e.dxf, 'defpoint3'):
                    defpoint3 = Vec2(e.dxf.defpoint3.x, e.dxf.defpoint3.y)
                    if distance(test_center, defpoint3) < weld_radius:
                        interference_count += 1
                        interference_found = True
            except:
                pass
                
        elif e.dxftype() == "LEADER":
            # ì§€ì‹œì„  ì²´í¬
            try:
                if hasattr(e, 'vertices'):
                    for vertex in e.vertices:
                        vertex_pos = Vec2(vertex[0], vertex[1])
                        if distance(test_center, vertex_pos) < weld_radius:
                            interference_count += 1
                            interference_found = True
                            break
            except:
                pass
                
        elif e.dxftype() == "SPLINE":
            # ìŠ¤í”Œë¼ì¸ ì²´í¬
            try:
                if hasattr(e, 'control_points'):
                    for cp in e.control_points:
                        cp_pos = Vec2(cp[0], cp[1])
                        if distance(test_center, cp_pos) < weld_radius:
                            interference_count += 1
                            interference_found = True
                            break
            except:
                pass
                
        elif e.dxftype() == "ELLIPSE":
            # íƒ€ì› ì²´í¬
            try:
                ellipse_center = Vec2(e.dxf.center.x, e.dxf.center.y)
                if distance(test_center, ellipse_center) < weld_radius:
                    interference_count += 1
                    interference_found = True
            except:
                pass
        
        if interference_found:
            interference_details.append(f"{e.dxftype()}/{layer_name}")
    
    return interference_count, interference_details

def check_interference_at_position(test_center, msp, exclude_entities, weld_radius=3.0, check_radius=25.0):
    """íŠ¹ì • ìœ„ì¹˜ì—ì„œì˜ ê°„ì„­ì„ ì²´í¬í•˜ëŠ” í•¨ìˆ˜ (ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ ìœ ì§€)"""
    count, _ = check_interference_at_position_detailed(test_center, msp, exclude_entities, weld_radius, check_radius)
    return count > 0

def find_welds_along_line(start_point, end_point, msp, used_welds_circles, max_search_distance=50.0):
    """A1 ì„ ì„ ë”°ë¼ WELDSë¥¼ ì°¾ëŠ” í•¨ìˆ˜"""
    best_welds = None
    best_distance = float('inf')
    
    # ì„ ì˜ ë°©í–¥ ë²¡í„°
    direction = end_point - start_point
    line_length = direction.magnitude
    
    if line_length > 0:
        direction_normalized = direction.normalize()
        
        # WELDS ê²€ìƒ‰
        for circle in msp.query('CIRCLE'):
            if (hasattr(circle.dxf, 'layer') and circle.dxf.layer == 'WELDS' and
                0.75 <= circle.dxf.radius <= 1.0):  # ë°˜ì§€ë¦„ 0.75-1.0 = ì§€ë¦„ 1.5-2mm
                
                circle_center = Vec2(circle.dxf.center.x, circle.dxf.center.y)
                
                # 1. ì„ ì˜ ì—°ì¥ì„ ìƒì— ìˆëŠ”ì§€ í™•ì¸
                # ì‹œì‘ì ì—ì„œ ì›ê¹Œì§€ì˜ ë²¡í„°
                to_circle = circle_center - start_point
                
                # ì„ ì˜ ë°©í–¥ìœ¼ë¡œì˜ íˆ¬ì˜ ê±°ë¦¬
                projection_distance = to_circle.dot(direction_normalized)
                
                # íˆ¬ì˜ì  ê³„ì‚°
                projection_point = start_point + direction_normalized * projection_distance
                
                # ì›ê³¼ íˆ¬ì˜ì  ì‚¬ì´ì˜ ê±°ë¦¬ (ì„ ì—ì„œ ë²—ì–´ë‚œ ì •ë„)
                perpendicular_distance = distance(circle_center, projection_point)
                
                # ì„ ìƒ ë˜ëŠ” ê°€ê¹Œìš´ ìœ„ì¹˜ì— ìˆëŠ”ì§€ í™•ì¸ (2mm í—ˆìš©)
                if perpendicular_distance <= 2.0:
                    # ì‹œì‘ì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬
                    distance_from_start = distance(start_point, circle_center)
                    
                    # ìµœëŒ€ ê²€ìƒ‰ ê±°ë¦¬ ë‚´ì— ìˆê³ , ê°€ì¥ ê°€ê¹Œìš´ WELDS ì„ íƒ
                    if distance_from_start <= max_search_distance and distance_from_start < best_distance:
                        if circle not in used_welds_circles:
                            best_welds = circle
                            best_distance = distance_from_start
    
    return best_welds, best_distance

def find_pipe_lines_near_sw(sw_center, msp, search_radius=5.0):
    """SW ê·¼ì²˜ì˜ PIPE ì„ ì„ ì°¾ëŠ” í•¨ìˆ˜"""
    pipe_lines = []
    
    try:
        # LINE ê²€ìƒ‰
        for entity in msp.query('LINE'):
            try:
                if hasattr(entity.dxf, 'layer'):
                    layer_name = entity.dxf.layer.upper()
                    if 'PIPE' in layer_name:
                        start = Vec2(entity.dxf.start.x, entity.dxf.start.y)
                        end = Vec2(entity.dxf.end.x, entity.dxf.end.y)
                        
                        # SW ì¤‘ì‹¬ì—ì„œì˜ ê±°ë¦¬
                        dist_to_start = distance(sw_center, start)
                        dist_to_end = distance(sw_center, end)
                        min_dist = min(dist_to_start, dist_to_end)
                        
                        if min_dist <= search_radius:
                            pipe_lines.append({
                                'entity': entity,
                                'type': 'LINE',
                                'segments': [(start, end)],
                                'min_distance': min_dist
                            })
            except Exception:
                continue
        
        # POLYLINE/LWPOLYLINE ê²€ìƒ‰
        for poly in msp.query("POLYLINE LWPOLYLINE"):
            try:
                if hasattr(poly.dxf, 'layer'):
                    layer_name = poly.dxf.layer.upper()
                    if 'PIPE' in layer_name:
                        if poly.dxftype() == "POLYLINE":
                            points = [Vec2(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                        else:
                            points = [Vec2(x, y) for x, y, *_ in poly.get_points()]
                        
                        if len(points) >= 2:
                            # ëª¨ë“  ì ë“¤ì— ëŒ€í•´ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
                            min_dist = float('inf')
                            for pt in points:
                                dist = distance(sw_center, pt)
                                min_dist = min(min_dist, dist)
                            
                            if min_dist <= search_radius:
                                segments = []
                                for i in range(len(points) - 1):
                                    segments.append((points[i], points[i+1]))
                                
                                pipe_lines.append({
                                    'entity': poly,
                                    'type': poly.dxftype(),
                                    'segments': segments,
                                    'min_distance': min_dist
                                })
            except Exception:
                continue
        
        # ê±°ë¦¬ê°€ ê°€ê¹Œìš´ ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ìƒìœ„ 2ê°œë§Œ ì„ íƒ
        pipe_lines.sort(key=lambda x: x['min_distance'])
        pipe_lines = pipe_lines[:2]
        
        print(f"   ğŸ”§ SW ê·¼ì²˜ PC ê²€ìƒ‰ ì™„ë£Œ: {len(pipe_lines)}ê°œ ë°œê²¬")
        
    except Exception as e:
        print(f"PIPE ì„  ì°¾ê¸° ì˜¤ë¥˜: {e}")
        pipe_lines = []
    
    return pipe_lines

def check_wd_interference_with_priority(wd_entities, sw_center, rotation_angle, msp, exclude_entities, pipe_lines=None):
    """ìš°ì„ ìˆœìœ„ ê¸°ë°˜ WD ê°„ì„­ ì²´í¬ - ê° ê°„ì„­ ìœ í˜•ë³„ë¡œ ë³„ë„ ì²´í¬"""
    try:
        # ì„ì‹œë¡œ íšŒì „ì‹œì¼œì„œ ê°„ì„­ ì²´í¬
        temp_positions = []
        
        # ëª¨ë“  ì—”í‹°í‹°ì˜ í˜„ì¬ ìœ„ì¹˜ ë°±ì—…
        for entity in wd_entities:
            if entity.dxftype() == 'CIRCLE':
                temp_positions.append({
                    'entity': entity,
                    'type': 'CIRCLE',
                    'original': (entity.dxf.center.x, entity.dxf.center.y, 0)
                })
            elif entity.dxftype() == 'TEXT':
                temp_positions.append({
                    'entity': entity,
                    'type': 'TEXT',
                    'original': (entity.dxf.insert.x, entity.dxf.insert.y, 0)
                })
            elif entity.dxftype() == 'LINE':
                temp_positions.append({
                    'entity': entity,
                    'type': 'LINE',
                    'original_start': (entity.dxf.start.x, entity.dxf.start.y, 0),
                    'original_end': (entity.dxf.end.x, entity.dxf.end.y, 0)
                })
        
        # ì„ì‹œë¡œ íšŒì „
        for entity in wd_entities:
            rotate_entity_around_point(entity, sw_center, rotation_angle)
        
        # íšŒì „ í›„ WELDNO í…ìŠ¤íŠ¸ë¥¼ WDC ì› ì¤‘ì‹¬ìœ¼ë¡œ ì¬ì •ë ¬
        wdc_circle = None
        weldno_texts = []
        
        for entity in wd_entities:
            if entity.dxftype() == 'CIRCLE' and 1.5 <= entity.dxf.radius <= 3.2:  # ì§€ë¦„ 3~6.4mm
                wdc_circle = entity
            elif entity.dxftype() == 'TEXT':
                # í…ìŠ¤íŠ¸ê°€ ìˆ˜í‰ì¸ì§€ í™•ì¸
                if is_horizontal_text(entity):
                    weldno_texts.append(entity)
        
        if wdc_circle and weldno_texts:
            wdc_center = Vec2(wdc_circle.dxf.center.x, wdc_circle.dxf.center.y)
            for txt in weldno_texts:
                bbox = get_text_bounding_box(txt)
                if bbox:
                    offset = wdc_center - bbox['center']
                    new_insert = Vec2(txt.dxf.insert.x + offset.x, 
                                    txt.dxf.insert.y + offset.y)
                    txt.dxf.insert = (new_insert.x, new_insert.y, 0)
        
        # íšŒì „ í›„ WDC ì¤‘ì‹¬ ìœ„ì¹˜
        wdc_center_for_check = Vec2(wdc_circle.dxf.center.x, wdc_circle.dxf.center.y) if wdc_circle else sw_center
        
        # WA ë¼ì¸ì˜ ê°ë„ ê³„ì‚° (SWì—ì„œ WDCë¡œì˜ ë°©í–¥)
        wa_angle = math.atan2(wdc_center_for_check.y - sw_center.y, 
                             wdc_center_for_check.x - sw_center.x)
        
        # PIPEì™€ì˜ ì§êµì„± ê³„ì‚°
        pipe_angle_info = calculate_wa_line_to_pipe_angle(wa_angle, pipe_lines)
        
        # ê° ê°„ì„­ ìœ í˜•ë³„ë¡œ ì²´í¬
        has_text_interference = False
        has_pipe_layer_interference = False
        has_pc_circle_interference = False
        has_30degree_polyline_interference = False
        general_interference_score = 0
        
        # 1. TEXT ê°„ì„­ ì²´í¬ (ìµœìš°ì„ ) - 25mm ë²”ìœ„ ë‚´ë§Œ
        for entity in wd_entities:
            if entity.dxftype() == 'TEXT':
                if check_text_endpoint_interference(entity, msp, exclude_entities + wd_entities, 5.0, wdc_center_for_check, 25.0):
                    has_text_interference = True
                    break
        
        # 2. PIPE/ELBO ë ˆì´ì–´ ê°„ì„­ ì²´í¬ (ë‘ë²ˆì§¸ ìš°ì„ ìˆœìœ„) - 25mm ë²”ìœ„ ë‚´ë§Œ
        has_pipe_layer_interference = check_pipe_layer_interference(wd_entities, msp, exclude_entities + wd_entities, 25.0)
        
        # 3. PCì™€ WDC ì› ì‚¬ì´ 1mm ì²´í¬ (ì„¸ë²ˆì§¸ ìš°ì„ ìˆœìœ„)
        if pipe_lines:
            for entity in wd_entities:
                if entity.dxftype() == 'CIRCLE' and 1.5 <= entity.dxf.radius <= 3.2:  # WDC ì› (ì§€ë¦„ 3~6.4mm)
                    center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                    for pc in pipe_lines:
                        if check_circle_to_segments_distance(center, entity.dxf.radius, pc['segments'], 1.0):  # 2mm â†’ 1mmë¡œ ì™„í™”
                            has_pc_circle_interference = True
                            break
                    if has_pc_circle_interference:
                        break
        
        # 4. 30ë„ ë‹¨ìœ„ ì •ê°ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ ì²´í¬ (ë„¤ë²ˆì§¸ ìš°ì„ ìˆœìœ„) - 25mm ë²”ìœ„ ë‚´ë§Œ
        has_30degree_polyline_interference = check_30degree_polyline_interference(wd_entities, msp, exclude_entities + wd_entities, 25.0)
        
        # 5. ì¼ë°˜ ê°„ì„­ ì ìˆ˜ ê³„ì‚° (ìµœí•˜ìœ„ ìš°ì„ ìˆœìœ„) - 25mm ë²”ìœ„ ë‚´ë§Œ
        general_interference_details = []
        for entity in wd_entities:
            if entity.dxftype() == 'CIRCLE':
                center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                # WDC ì›ì˜ ê²½ìš° ë°˜ì§€ë¦„ì„ ì•½ê°„ ëŠ˜ë ¤ì„œ ì²´í¬ (ì—¬ìœ  ê³µê°„ í™•ë³´)
                check_radius_adjusted = entity.dxf.radius + 1.0  # 1mm ì—¬ìœ 
                interference_count, details = check_interference_at_position_detailed(center, msp, exclude_entities + wd_entities, check_radius_adjusted, 25.0)
                general_interference_score += interference_count
                if details:
                    general_interference_details.extend(details)
        
        # ì›ë˜ ìœ„ì¹˜ë¡œ ë³µêµ¬
        for backup in temp_positions:
            if backup['type'] == 'CIRCLE':
                backup['entity'].dxf.center = backup['original']
            elif backup['type'] == 'TEXT':
                backup['entity'].dxf.insert = backup['original']
            elif backup['type'] == 'LINE':
                backup['entity'].dxf.start = backup['original_start']
                backup['entity'].dxf.end = backup['original_end']
        
        return {
            'text_interference': has_text_interference,
            'pipe_layer_interference': has_pipe_layer_interference,
            'pc_circle_interference': has_pc_circle_interference,
            '30degree_polyline_interference': has_30degree_polyline_interference,
            'general_score': general_interference_score,
            'general_details': general_interference_details,
            'pipe_angle_info': pipe_angle_info
        }
        
    except Exception as e:
        print(f"ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ê°„ì„­ ì²´í¬ ì˜¤ë¥˜: {e}")
        return {
            'text_interference': True,
            'pipe_layer_interference': True,
            'pc_circle_interference': True,
            '30degree_polyline_interference': True,
            'general_score': 999,
            'general_details': [],
            'pipe_angle_info': None
        }

def rotate_entity_around_point(entity, center, angle):
    """ì—”í‹°í‹°ë¥¼ íŠ¹ì • ì ì„ ì¤‘ì‹¬ìœ¼ë¡œ íšŒì „ì‹œí‚¤ëŠ” í•¨ìˆ˜"""
    try:
        cos_a = math.cos(angle)
        sin_a = math.sin(angle)
        
        if entity.dxftype() == 'CIRCLE':
            # ì›ì˜ ì¤‘ì‹¬ì  íšŒì „
            old_center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
            dx = old_center.x - center.x
            dy = old_center.y - center.y
            new_x = center.x + dx * cos_a - dy * sin_a
            new_y = center.y + dx * sin_a + dy * cos_a
            entity.dxf.center = (new_x, new_y, 0)
            
        elif entity.dxftype() == 'TEXT':
            # í…ìŠ¤íŠ¸ ì‚½ì…ì  íšŒì „
            old_pos = Vec2(entity.dxf.insert.x, entity.dxf.insert.y)
            dx = old_pos.x - center.x
            dy = old_pos.y - center.y
            new_x = center.x + dx * cos_a - dy * sin_a
            new_y = center.y + dx * sin_a + dy * cos_a
            entity.dxf.insert = (new_x, new_y, 0)
            
        elif entity.dxftype() == 'LINE':
            # ì„ ì˜ ì‹œì‘ì ê³¼ ëì  íšŒì „
            start = Vec2(entity.dxf.start.x, entity.dxf.start.y)
            end = Vec2(entity.dxf.end.x, entity.dxf.end.y)
            
            # ì‹œì‘ì  íšŒì „
            dx = start.x - center.x
            dy = start.y - center.y
            new_start_x = center.x + dx * cos_a - dy * sin_a
            new_start_y = center.y + dx * sin_a + dy * cos_a
            
            # ëì  íšŒì „
            dx = end.x - center.x
            dy = end.y - center.y
            new_end_x = center.x + dx * cos_a - dy * sin_a
            new_end_y = center.y + dx * sin_a + dy * cos_a
            
            entity.dxf.start = (new_start_x, new_start_y, 0)
            entity.dxf.end = (new_end_x, new_end_y, 0)
            
    except Exception as e:
        print(f"ì—”í‹°í‹° íšŒì „ ì˜¤ë¥˜: {e}")

def delete_isotext_entities(msp, wd_group):
    """WD ê·¸ë£¹ê³¼ ê´€ë ¨ëœ ISOTEXT ë ˆì´ì–´ì˜ ì—”í‹°í‹°ë“¤ì„ ì‚­ì œ"""
    deleted_count = 0
    
    try:
        # ì‚­ì œí•  ì—”í‹°í‹° ëª©ë¡
        entities_to_delete = []
        
        # WDC ì› ì¤‘ì‹¬ ì°¾ê¸°
        wdc_center = None
        for entity in wd_group['entities']:
            if entity.dxftype() == 'CIRCLE' and 1.5 <= entity.dxf.radius <= 3.2:
                wdc_center = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                break
        
        if not wdc_center:
            return deleted_count
        
        # ISOTEXT ë ˆì´ì–´ì˜ ì—”í‹°í‹°ë“¤ ì¤‘ WDC ê·¼ì²˜(10mm ì´ë‚´)ì˜ ì—”í‹°í‹° ì°¾ê¸°
        for entity in msp:
            if hasattr(entity.dxf, 'layer') and entity.dxf.layer == 'ISOTEXT':
                # ì—”í‹°í‹°ê°€ ì´ë¯¸ WD ê·¸ë£¹ì— í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                if entity in wd_group['entities']:
                    continue
                
                # ì—”í‹°í‹°ì™€ WDC ì¤‘ì‹¬ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
                entity_pos = None
                if entity.dxftype() == 'CIRCLE':
                    entity_pos = Vec2(entity.dxf.center.x, entity.dxf.center.y)
                elif entity.dxftype() in ('TEXT', 'MTEXT'):
                    entity_pos = Vec2(entity.dxf.insert.x, entity.dxf.insert.y)
                elif entity.dxftype() == 'LINE':
                    start = Vec2(entity.dxf.start.x, entity.dxf.start.y)
                    end = Vec2(entity.dxf.end.x, entity.dxf.end.y)
                    # ì„ ë¶„ì˜ í•œ ëì ì´ë¼ë„ WDC ê·¼ì²˜ì— ìˆìœ¼ë©´ ì‚­ì œ
                    if distance(start, wdc_center) <= 10.0 or distance(end, wdc_center) <= 10.0:
                        entities_to_delete.append(entity)
                        continue
                
                if entity_pos and distance(entity_pos, wdc_center) <= 10.0:
                    entities_to_delete.append(entity)
        
        # ì—”í‹°í‹° ì‚­ì œ
        for entity in entities_to_delete:
            try:
                msp.delete_entity(entity)
                deleted_count += 1
            except Exception as e:
                print(f"   â— ISOTEXT ì—”í‹°í‹° ì‚­ì œ ì˜¤ë¥˜: {e}")
        
        if deleted_count > 0:
            print(f"   ğŸ—‘ï¸  ISOTEXT ë ˆì´ì–´ì—ì„œ {deleted_count}ê°œ ì—”í‹°í‹° ì‚­ì œ")
    
    except Exception as e:
        print(f"   â— ISOTEXT ì‚­ì œ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    return deleted_count

if __name__ == "__main__":
    # ë””ë²„ê¹…ì„ ìœ„í•œ ì •ë³´ ì¶œë ¥
    import sys
    print("=" * 50)
    print("ì‹¤í–‰ íŒŒì¼:", sys.argv[0])
    print("Python ë²„ì „:", sys.version)
    print("í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬:", os.getcwd())
    print("=" * 50)
    
    # íŒŒì¼ ì„ íƒ ì°½ì´ ëª‡ ë²ˆ ì—´ë¦¬ëŠ”ì§€ í™•ì¸
    print("\n[ë””ë²„ê¹…] íŒŒì¼ ì„ íƒ ì°½ì„ ì—¬ëŠ” ì¤‘... (ì´ ë©”ì‹œì§€ê°€ ë‘ ë²ˆ ë‚˜ì˜¤ë©´ ë¬¸ì œ)")
    
    # Tkinter ì´ˆê¸°í™” ë° íŒŒì¼ ì„ íƒ
    try:
        root = Tk()
        root.withdraw()
        print("[ë””ë²„ê¹…] Tkinter ì´ˆê¸°í™” ì™„ë£Œ")
        
        filepaths = filedialog.askopenfilenames(
            title="DXF íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”",
            filetypes=[("DXF Files", "*.dxf")]
        )
        
        root.destroy()  # Tkinter ì°½ ì™„ì „íˆ ì¢…ë£Œ
        print(f"[ë””ë²„ê¹…] íŒŒì¼ ì„ íƒ ì™„ë£Œ - ì„ íƒëœ íŒŒì¼: {len(filepaths)}ê°œ")
        
        # ì„ íƒëœ íŒŒì¼ ëª©ë¡ ì¶œë ¥
        print("\n[ë””ë²„ê¹…] ì„ íƒëœ íŒŒì¼ ëª©ë¡:")
        for i, fp in enumerate(filepaths):
            print(f"  {i+1}. {fp}")
        
        # ì¤‘ë³µ íŒŒì¼ ì œê±°
        unique_filepaths = list(set(filepaths))
        if len(unique_filepaths) != len(filepaths):
            print(f"\n[ê²½ê³ ] ì¤‘ë³µ íŒŒì¼ ë°œê²¬! {len(filepaths)}ê°œ â†’ {len(unique_filepaths)}ê°œë¡œ ì •ë¦¬")
            filepaths = unique_filepaths
        
    except Exception as e:
        print(f"[ì˜¤ë¥˜] íŒŒì¼ ì„ íƒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        exit()
    
    if not filepaths:
        print("âŒ ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        exit()

    print("\n=== íŒŒì¼ ì²˜ë¦¬ ì‹œì‘ ===")
    print(f"ì´ {len(filepaths)}ê°œ íŒŒì¼ ì²˜ë¦¬ ì˜ˆì •\n")
    
    # ê° íŒŒì¼ ì²˜ë¦¬
    processed_files = []  # ì²˜ë¦¬ëœ íŒŒì¼ ì¶”ì 
    
    for idx, filepath in enumerate(filepaths):
        print(f"\n{'='*60}")
        print(f"[{idx+1}/{len(filepaths)}] íŒŒì¼ ì²˜ë¦¬ ì‹œì‘")
        print(f"íŒŒì¼ ê²½ë¡œ: {filepath}")
        print(f"{'='*60}")
        
        # ì´ë¯¸ ì²˜ë¦¬ëœ íŒŒì¼ì¸ì§€ í™•ì¸
        if filepath in processed_files:
            print(f"âš ï¸  ì´ë¯¸ ì²˜ë¦¬ëœ íŒŒì¼ì…ë‹ˆë‹¤. ê±´ë„ˆëœë‹ˆë‹¤.")
            continue
        
        processed_files.append(filepath)
        print(f"\nğŸ“‚ ì²˜ë¦¬ ì¤‘: {os.path.basename(filepath)}")
        
        try:
            doc = ezdxf.readfile(filepath)
            msp = doc.modelspace()
        except Exception as e:
            print(f"âŒ íŒŒì¼ ì½ê¸° ì˜¤ë¥˜: {e}")
            continue
    
        # íŒŒë¼ë¯¸í„° ì„¤ì •
        min_radius = 1.5  # ìµœì†Œ ë°˜ì§€ë¦„ (ì§€ë¦„ 3mm)
        max_radius = 3.2  # ìµœëŒ€ ë°˜ì§€ë¦„ (ì§€ë¦„ 6.4mm)
        text_search_radius = 4.0
        a1_search_radius = 3.0  # WDC ì¤‘ì‹¬ì—ì„œ A1 ë¼ì¸ ì°¾ê¸° ìœ„í•œ ë°˜ê²½
        interference_check_radius = 25.0  # ê°„ì„­ ì²´í¬ ë²”ìœ„ (20mm â†’ 25mmë¡œ í™•ëŒ€)
        
        # ì‚¬ìš©ëœ WELDS ì› ì¶”ì  ë¦¬ìŠ¤íŠ¸
        used_welds_circles = []
        
        wdc_blocks = []  # WDC (ì›) ì €ì¥
        wd_groups = []   # WD (WDC + WDT) ê·¸ë£¹ ì €ì¥
        
        # 1. WDC ì°¾ê¸°: ISOTEXT ë ˆì´ì–´ì˜ ì› (ì§€ë¦„ 3~6.4mm)
        for circle in msp.query("CIRCLE"):
            if circle.dxf.layer == "ISOTEXT" and min_radius <= circle.dxf.radius <= max_radius:
                center = Vec2(circle.dxf.center.x, circle.dxf.center.y)
                circle.dxf.layer = "WDC"
                circle.dxf.color = 4  # CYAN
                
                # 2. WDT ì°¾ê¸°: WDC ë°˜ê²½ 4.0 ì´ë‚´ì˜ ê¸°ìš¸ê¸° 0ì¸ TEXT
                wdt_texts = []
                for txt in msp.query("TEXT"):
                    if is_horizontal_text(txt):
                        pos = Vec2(txt.dxf.insert.x, txt.dxf.insert.y)
                        if distance(pos, center) <= text_search_radius:
                            txt.dxf.layer = "WDT"
                            wdt_texts.append(txt)
                
                wdc_blocks.append({
                    "circle": circle,
                    "center": center,
                    "radius": circle.dxf.radius,
                    "texts": wdt_texts
                })
        
        print(f"âœ… WDC ë¸”ë¡ ìˆ˜: {len(wdc_blocks)}")
        
        # 3. ê° WDCì— ëŒ€í•´ A1 (ì ‘í•˜ëŠ” ë¼ì¸) ì°¾ê¸° ë° ì²˜ë¦¬
        for wdc in wdc_blocks:
            circle = wdc["circle"]
            center = wdc["center"]
            radius = wdc["radius"]
            texts = wdc["texts"]
            
            # A1 ì°¾ê¸°: WDC ì¤‘ì‹¬ì—ì„œ 3mm ì´ë‚´ì˜ ê°€ì¥ ê°€ê¹Œìš´ ISOTEXT ë ˆì´ì–´ì˜ LINE
            closest_line = None
            closest_distance = float('inf')
            closest_ap1 = None
            closest_ap2 = None
            
            for line in msp.query("LINE"):
                if line.dxf.layer == "ISOTEXT":
                    start = Vec2(line.dxf.start.x, line.dxf.start.y)
                    end = Vec2(line.dxf.end.x, line.dxf.end.y)
                    
                    # ê° ëì ê³¼ ì› ì¤‘ì‹¬ê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
                    dist_start = distance(start, center)
                    dist_end = distance(end, center)
                    
                    # ë” ê°€ê¹Œìš´ ì  ì°¾ê¸°
                    if dist_start < dist_end:
                        if dist_start <= 3.0:  # WDC ì¤‘ì‹¬ì—ì„œ 3mm ì´ë‚´
                            if dist_start < closest_distance:
                                closest_distance = dist_start
                                closest_line = line
                                closest_ap1 = start
                                closest_ap2 = end
                    else:
                        if dist_end <= 3.0:  # WDC ì¤‘ì‹¬ì—ì„œ 3mm ì´ë‚´
                            if dist_end < closest_distance:
                                closest_distance = dist_end
                                closest_line = line
                                closest_ap1 = end
                                closest_ap2 = start
            
            if closest_line:
                # ê°€ì¥ ê°€ê¹Œìš´ ë¼ì¸ì„ A1ìœ¼ë¡œ ì„¤ì •
                closest_line.dxf.color = 7  # í°ìƒ‰
                
                # A1ì˜ ê¸°ìš¸ê¸° ê³„ì‚°
                angle = get_line_angle(closest_ap1, closest_ap2)
                
                # WD = WDC + WDT
                wd_entities = [circle] + texts
                
                # A1 ë¼ì¸ì€ ë‚˜ì¤‘ì— ì‚­ì œí•˜ê¸° ìœ„í•´ ì €ì¥
                # (WAê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ëœ ê²½ìš°ì—ë§Œ ì‚­ì œ)
                
                # WD ê·¸ë£¹ ì €ì¥ (íšŒì „ì— ì‚¬ìš©) - ì´ë™ì€ ë‚˜ì¤‘ì— WELDSë¥¼ ì°¾ì€ í›„ì— ìˆ˜í–‰
                wd_groups.append({
                    'wdc_circle': circle,
                    'wdc_center': center,  # ì›ë˜ ìœ„ì¹˜ ì €ì¥
                    'wdt_texts': texts,
                    'entities': wd_entities,
                    'ap2': closest_ap2,  # AP2 ìœ„ì¹˜ ì €ì¥
                    'a1_angle': angle,  # A1 ë¼ì¸ì˜ ê°ë„ ì €ì¥
                    'radius': radius,  # WDC ë°˜ì§€ë¦„ ì €ì¥
                    'a1_line': closest_line,  # A1 ë¼ì¸ ì°¸ì¡° ì €ì¥ (ë‚˜ì¤‘ì— ì‚­ì œìš©)
                    'wa_created': False  # WA ìƒì„± ì—¬ë¶€ í”Œë˜ê·¸
                })
        
        print(f"âœ… WD ê·¸ë£¹ ìƒì„±: {len(wd_groups)}ê°œ")
        print(f"\nğŸ”„ WD íšŒì „ ì²˜ë¦¬ ì‹œì‘ - ì´ {len(wd_groups)}ê°œ ê·¸ë£¹")
        
        # ê° WD ê·¸ë£¹ì— ëŒ€í•´ íšŒì „ ì²˜ë¦¬
        failed_wd_count = 0
        long_wa_count = 0
        
        for i, wd_group in enumerate(wd_groups):
            try:
                wdc_circle = wd_group['wdc_circle']
                original_wdc_center = wd_group['wdc_center']  # ì›ë˜ ìœ„ì¹˜
                ap2 = wd_group['ap2']  # AP2 ìœ„ì¹˜
                a1_angle = wd_group['a1_angle']  # A1 ì„ ì˜ ê°ë„
                
                print(f"\n[{i+1}/{len(wd_groups)}] WD ì²˜ë¦¬: ({original_wdc_center.x:.2f}, {original_wdc_center.y:.2f})")
                
                # 1. ë¨¼ì € A1 ì„ ì„ ë”°ë¼ WELDS ì°¾ê¸° (A1 ì„ ì˜ ì—°ì¥ì„ ìƒ)
                # A1 ë°©í–¥ìœ¼ë¡œ ì—°ì¥ëœ ì„ ìƒì—ì„œ WELDS ì°¾ê¸°
                direction = Vec2(math.cos(a1_angle), math.sin(a1_angle))
                search_start = original_wdc_center
                search_end = ap2 + direction * 50.0  # AP2ì—ì„œ 50mm ë” ì—°ì¥
                
                welds_circle, welds_distance = find_welds_along_line(
                    search_start, search_end, msp, used_welds_circles, 50.0
                )
                
                if welds_circle:
                    welds_center = Vec2(welds_circle.dxf.center.x, welds_circle.dxf.center.y)
                    print(f"   âœ… A1 ì—°ì¥ì„ ìƒì—ì„œ WELDS ë°œê²¬: ê±°ë¦¬ {welds_distance:.1f}mm")
                    used_welds_circles.append(welds_circle)
                else:
                    # 2. A1 ì„ ìƒì—ì„œ ëª» ì°¾ìœ¼ë©´ AP2 ê·¼ì²˜ì—ì„œ ì°¾ê¸° (ì ì§„ì  í™•ëŒ€)
                    print(f"   âš ï¸  A1 ì„ ìƒì—ì„œ WELDSë¥¼ ì°¾ì§€ ëª»í•¨, AP2 ê·¼ì²˜ ê²€ìƒ‰")
                    
                    search_radii = [5.0, 10.0, 15.0, 20.0, 30.0]
                    for search_radius in search_radii:
                        # WELDS ë ˆì´ì–´ì˜ 1.5-2mm ì› ì°¾ê¸° (AP2 ê·¼ì²˜)
                        for circle in msp.query('CIRCLE'):
                            if (hasattr(circle.dxf, 'layer') and circle.dxf.layer == 'WELDS' and
                                0.75 <= circle.dxf.radius <= 1.0):  # ë°˜ì§€ë¦„ 0.75-1.0 = ì§€ë¦„ 1.5-2mm
                                circle_center = Vec2(circle.dxf.center.x, circle.dxf.center.y)
                                if distance(circle_center, ap2) <= search_radius:
                                    # ì´ë¯¸ ì‚¬ìš©ëœ WELDSì¸ì§€ í™•ì¸
                                    if circle not in used_welds_circles:
                                        welds_circle = circle
                                        welds_center = circle_center
                                        welds_distance = distance(circle_center, ap2)
                                        used_welds_circles.append(circle)
                                        print(f"   âœ… {search_radius:.0f}mm ë²”ìœ„ì—ì„œ WELDS ë°œê²¬")
                                        break
                        if welds_circle:
                            break
                
                # 3. ê·¸ë˜ë„ ëª» ì°¾ìœ¼ë©´ ì´ë¯¸ ì‚¬ìš©ëœ WELDS ì¤‘ì—ì„œë¼ë„ ì°¾ê¸°
                if not welds_circle:
                    print(f"   âš ï¸  ë¯¸ì‚¬ìš© WELDSë¥¼ ì°¾ì§€ ëª»í•¨, ì‚¬ìš©ëœ WELDS ì¬ê²€ìƒ‰")
                    min_distance = float('inf')
                    for circle in msp.query('CIRCLE'):
                        if (hasattr(circle.dxf, 'layer') and circle.dxf.layer == 'WELDS' and
                            0.75 <= circle.dxf.radius <= 1.0):
                            circle_center = Vec2(circle.dxf.center.x, circle.dxf.center.y)
                            dist = distance(circle_center, ap2)
                            if dist < min_distance and dist <= 30.0:
                                welds_circle = circle
                                welds_center = circle_center
                                welds_distance = dist
                                min_distance = dist
                    
                    if welds_circle:
                        print(f"   âš ï¸  ê¸°ì¡´ ì‚¬ìš© WELDS ì¬ì‚¬ìš© (ê±°ë¦¬: {min_distance:.1f}mm)")
                
                if not welds_circle:
                    print(f"   âŒ WELDSë¥¼ ì „í˜€ ì°¾ì„ ìˆ˜ ì—†ìŒ - WA ì„  ì—†ì´ ì§„í–‰")
                    failed_wd_count += 1
                    # WDC ìƒ‰ìƒì„ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ë¬¸ì œ í‘œì‹œ
                    wdc_circle.dxf.color = 1  # RED
                    continue
                
                print(f"   ğŸ”— WELDS ì› ë°œê²¬: ({welds_center.x:.2f}, {welds_center.y:.2f})")
                
                # WDë¥¼ WELDSë¡œë¶€í„° (WDC ë°˜ì§€ë¦„ + 2.8mm) ê±°ë¦¬ë¡œ ì´ë™
                # A1ì˜ ë°©í–¥ì„ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •
                radius = wd_group['radius']
                move_distance = radius + 2.8
                
                # WELDSì—ì„œ AP2 ë°©í–¥ìœ¼ë¡œ ì´ë™ (ë§Œì•½ AP2ê°€ WELDSë³´ë‹¤ ê°€ê¹Œìš°ë©´ ë°˜ëŒ€ ë°©í–¥)
                if distance(welds_center, original_wdc_center) < distance(welds_center, ap2):
                    # WDCê°€ AP2ë³´ë‹¤ WELDSì— ê°€ê¹Œìš´ ê²½ìš° (ì •ìƒì ì¸ ê²½ìš°)
                    direction = original_wdc_center - welds_center
                else:
                    # AP2ê°€ WELDSì— ë” ê°€ê¹Œìš´ ê²½ìš°
                    direction = ap2 - welds_center
                
                if direction.magnitude > 0:
                    direction_normalized = direction.normalize()
                    new_wdc_center = welds_center + direction_normalized * move_distance
                    
                    # WD ì—”í‹°í‹°ë“¤ ì´ë™
                    move_vec = new_wdc_center - original_wdc_center
                    
                    # WDC ì´ë™
                    wdc_circle.dxf.center = (new_wdc_center.x, new_wdc_center.y, 0)
                    
                    # WDT í…ìŠ¤íŠ¸ë“¤ ì´ë™
                    for txt in wd_group['wdt_texts']:
                        pos = Vec2(txt.dxf.insert.x, txt.dxf.insert.y)
                        new_pos = pos + move_vec
                        txt.dxf.insert = (new_pos.x, new_pos.y, 0)
                    
                    # ì´ë™ëœ WDC ì¤‘ì‹¬ ì—…ë°ì´íŠ¸
                    wdc_center = new_wdc_center
                    
                    # WA ê±°ë¦¬ í™•ì¸ ë° ê²½ê³ 
                    actual_wa_distance = distance(welds_center, wdc_center)
                    if actual_wa_distance > 10.0:  # 10mm ì´ìƒì´ë©´ ê²½ê³ 
                        print(f"   âš ï¸  WA ê±°ë¦¬ê°€ ë¹„ì •ìƒì ìœ¼ë¡œ ê¹ë‹ˆë‹¤: {actual_wa_distance:.1f}mm")
                        long_wa_count += 1
                        # WDC ìƒ‰ìƒì„ ë…¸ë€ìƒ‰ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ê²½ê³  í‘œì‹œ
                        wdc_circle.dxf.color = 2  # YELLOW
                else:
                    print(f"   âš ï¸  ë°©í–¥ ê³„ì‚° ì˜¤ë¥˜ - ê¸°ì¡´ ìœ„ì¹˜ ìœ ì§€")
                    wdc_center = original_wdc_center
                    failed_wd_count += 1
                    # WDC ìƒ‰ìƒì„ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ë³€ê²½
                    wdc_circle.dxf.color = 1  # RED
                    continue
                
                # WELDS ê·¼ì²˜ì˜ PIPE ì„  ì°¾ê¸°
                pipe_lines = find_pipe_lines_near_sw(welds_center, msp, 5.0)
                
                # ë””ë²„ê¹…: PIPE ì„  ì •ë³´ ì¶œë ¥
                if pipe_lines:
                    print(f"   PIPE ì •ë³´:")
                    for i, pipe in enumerate(pipe_lines):
                        if pipe['segments']:
                            start, end = pipe['segments'][0]
                            angle = math.degrees(math.atan2(end.y - start.y, end.x - start.x)) % 360
                            # PIPEì— ëŒ€í•œ ISO ì§êµ ê°ë„
                            iso_angles = get_iso_orthogonal_angle(angle)
                            print(f"     - PIPE{i+1} ê°ë„: {angle:.1f}Â° (ISO ì§êµ: {iso_angles})")
                
                # ê°„ì„­ ì²´í¬ë¥¼ ìœ„í•œ ì œì™¸ ì—”í‹°í‹°
                exclude_entities = [welds_circle] + wd_group['entities']
                
                print(f"   ğŸ” ê°„ì„­ ì²´í¬ ì‹œì‘ (25mm ë²”ìœ„ ë‚´)")
                
                # ë””ë²„ê¹…: WDC ì› ì •ë³´ ì¶œë ¥
                wdc_info = f"ì¤‘ì‹¬=({wdc_center.x:.1f}, {wdc_center.y:.1f}), ë°˜ì§€ë¦„={radius:.1f}mm"
                print(f"   WDC ì›: {wdc_info}")
                print(f"   WELDSì™€ì˜ ê±°ë¦¬: {distance(welds_center, wdc_center):.1f}mm (ëª©í‘œ: {move_distance:.1f}mm)")
                
                # ë¨¼ì € í˜„ì¬ ìœ„ì¹˜(0ë„)ì—ì„œ ê°„ì„­ ì²´í¬
                current_interference = check_wd_interference_with_priority(
                    wd_group['entities'], welds_center, 0, msp, exclude_entities, pipe_lines
                )
                
                print(f"   í˜„ì¬ ìœ„ì¹˜ ê°„ì„­ ìƒíƒœ:")
                print(f"   - TEXT ê°„ì„­: {current_interference['text_interference']}")
                print(f"   - PIPE/ELBO ë ˆì´ì–´ ê°„ì„­: {current_interference['pipe_layer_interference']}")
                print(f"   - PC-WDC ê±°ë¦¬ ë¬¸ì œ: {current_interference['pc_circle_interference']}")
                print(f"   - 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­: {current_interference['30degree_polyline_interference']}")
                print(f"   - ì¼ë°˜ ê°„ì„­ ì ìˆ˜: {current_interference['general_score']}")
                if current_interference['pipe_angle_info']:
                    ortho_info = current_interference['pipe_angle_info']
                    print(f"   - PIPEì™€ì˜ ì§êµì„±: {ortho_info['orthogonality_score']:.1f}ë„ (ëª©í‘œê°ë„: {ortho_info.get('target_angle', 'N/A')}Â°)")
                
                # ëª¨ë“  íšŒì „ ê°ë„ì—ì„œ ê°„ì„­ ì •ë³´ ìˆ˜ì§‘ (0ë„ í¬í•¨)
                rotation_candidates = []
                for degree in range(0, 360, 30):
                    angle = math.radians(degree)
                    interference_info = check_wd_interference_with_priority(
                        wd_group['entities'], welds_center, angle, msp, exclude_entities, pipe_lines
                    )
                    rotation_candidates.append({
                        'angle': angle,
                        'degree': degree,
                        'interference': interference_info
                    })
                
                # ìµœì  ìœ„ì¹˜ ì„ íƒ - ISO ì§êµ ì ˆëŒ€ ìš°ì„ 
                best_candidate = None
                
                # 1. ISO ì§êµ ê°ë„ë“¤ì„ ìš°ì„  ì²´í¬
                print(f"\n   ğŸ¯ ISO ì§êµ ìœ„ì¹˜ ìš°ì„  ì²´í¬")
                
                # í˜„ì¬ WA ë¼ì¸ì˜ ê°ë„ ê³„ì‚°
                wa_angle = math.atan2(wdc_center.y - welds_center.y, wdc_center.x - welds_center.x)
                wa_angle_deg = math.degrees(wa_angle) % 360
                
                # ISO ì§êµ ê°ë„ë“¤ ê°€ì ¸ì˜¤ê¸°
                iso_orthogonal_angles = get_iso_orthogonal_angle(wa_angle_deg)
                print(f"   WA ê°ë„: {wa_angle_deg:.1f}Â°, ISO ì§êµ ëª©í‘œ: {iso_orthogonal_angles}")
                
                # ê° íšŒì „ ê°ë„ë¥¼ ISO ì§êµì™€ì˜ ì°¨ì´ë¡œ ì •ë ¬
                rotation_candidates_sorted = []
                for candidate in rotation_candidates:
                    degree = candidate['degree']
                    # ê° ISO ì§êµ ê°ë„ì™€ì˜ ìµœì†Œ ì°¨ì´ ê³„ì‚°
                    min_diff_from_ortho = float('inf')
                    for ortho_angle in iso_orthogonal_angles:
                        # WAê°€ íšŒì „í•œ í›„ì˜ ê°ë„
                        rotated_wa_angle = (wa_angle_deg + degree) % 360
                        diff = abs(rotated_wa_angle - ortho_angle)
                        if diff > 180:
                            diff = 360 - diff
                        min_diff_from_ortho = min(min_diff_from_ortho, diff)
                    
                    rotation_candidates_sorted.append({
                        'candidate': candidate,
                        'ortho_diff': min_diff_from_ortho
                    })
                
                # ISO ì§êµì— ê°€ê¹Œìš´ ìˆœìœ¼ë¡œ ì •ë ¬
                rotation_candidates_sorted.sort(key=lambda x: (x['ortho_diff'], x['candidate']['degree']))
                
                # ì •ë ¬ëœ ìˆœì„œëŒ€ë¡œ ê°„ì„­ ì²´í¬
                for sorted_item in rotation_candidates_sorted:
                    candidate = sorted_item['candidate']
                    interference = candidate['interference']
                    
                    # ê°„ì„­ì´ ì—†ìœ¼ë©´ ì¦‰ì‹œ ì„ íƒ
                    if (not interference['text_interference'] and
                        not interference['pipe_layer_interference'] and
                        not interference['pc_circle_interference'] and
                        not interference['30degree_polyline_interference'] and
                        interference['general_score'] == 0):
                        
                        best_candidate = candidate
                        print(f"   âœ… {candidate['degree']}ë„ì—ì„œ ê°„ì„­ ì—†ìŒ (ì§êµ ì°¨ì´: {sorted_item['ortho_diff']:.1f}ë„)")
                        break
                    else:
                        # ê°„ì„­ ì •ë³´ ì¶œë ¥
                        interference_types = []
                        if interference['text_interference']:
                            interference_types.append("TEXT")
                        if interference['pipe_layer_interference']:
                            interference_types.append("PIPEì¸µ")
                        if interference['pc_circle_interference']:
                            interference_types.append("PCê±°ë¦¬")
                        if interference['30degree_polyline_interference']:
                            interference_types.append("30ë„ì„ ")
                        if interference['general_score'] > 0:
                            interference_types.append(f"ì¼ë°˜({interference['general_score']})")
                        
                        print(f"   âŒ {candidate['degree']}ë„: ê°„ì„­={', '.join(interference_types)} (ì§êµ ì°¨ì´: {sorted_item['ortho_diff']:.1f}ë„)")
                
                # ê°„ì„­ ì—†ëŠ” ìœ„ì¹˜ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° - ê°„ì„­ì´ ê°€ì¥ ì ì€ ìœ„ì¹˜ ì„ íƒ
                if not best_candidate:
                    print(f"\n   âš ï¸  ëª¨ë“  ìœ„ì¹˜ì—ì„œ ê°„ì„­ ë°œìƒ - ê°„ì„­ì´ ê°€ì¥ ì ì€ ìœ„ì¹˜ ì„ íƒ")
                    
                    # ìš°ì„ ìˆœìœ„ë³„ë¡œ ìµœì  ìœ„ì¹˜ ì°¾ê¸°
                    # 1. TEXT ê°„ì„­ì´ ì—†ëŠ” ìœ„ì¹˜ë“¤
                    candidates_no_text = [c for c in rotation_candidates_sorted 
                                        if not c['candidate']['interference']['text_interference']]
                    
                    if candidates_no_text:
                        # 2. PIPE ë ˆì´ì–´ ê°„ì„­ì´ ì—†ëŠ” ìœ„ì¹˜ë“¤
                        candidates_no_pipe = [c for c in candidates_no_text 
                                            if not c['candidate']['interference']['pipe_layer_interference']]
                        
                        if candidates_no_pipe:
                            # 3. PC ê±°ë¦¬ ë¬¸ì œê°€ ì—†ëŠ” ìœ„ì¹˜ë“¤
                            candidates_no_pc = [c for c in candidates_no_pipe 
                                              if not c['candidate']['interference']['pc_circle_interference']]
                            
                            if candidates_no_pc:
                                # 4. 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­ì´ ì—†ëŠ” ìœ„ì¹˜ë“¤
                                candidates_no_30deg = [c for c in candidates_no_pc 
                                                     if not c['candidate']['interference']['30degree_polyline_interference']]
                                
                                if candidates_no_30deg:
                                    # 5. ì¼ë°˜ ê°„ì„­ ì ìˆ˜ê°€ ê°€ì¥ ë‚®ì€ ìœ„ì¹˜
                                    candidates_no_30deg.sort(key=lambda x: x['candidate']['interference']['general_score'])
                                    best_candidate = candidates_no_30deg[0]['candidate']
                                else:
                                    # ì¼ë°˜ ê°„ì„­ ì ìˆ˜ê°€ ê°€ì¥ ë‚®ì€ ìœ„ì¹˜
                                    candidates_no_pc.sort(key=lambda x: x['candidate']['interference']['general_score'])
                                    best_candidate = candidates_no_pc[0]['candidate']
                            else:
                                # ì¼ë°˜ ê°„ì„­ ì ìˆ˜ê°€ ê°€ì¥ ë‚®ì€ ìœ„ì¹˜
                                candidates_no_pipe.sort(key=lambda x: x['candidate']['interference']['general_score'])
                                best_candidate = candidates_no_pipe[0]['candidate']
                        else:
                            # ì¼ë°˜ ê°„ì„­ ì ìˆ˜ê°€ ê°€ì¥ ë‚®ì€ ìœ„ì¹˜
                            candidates_no_text.sort(key=lambda x: x['candidate']['interference']['general_score'])
                            best_candidate = candidates_no_text[0]['candidate']
                    else:
                        # ëª¨ë“  ìœ„ì¹˜ì—ì„œ TEXT ê°„ì„­ì´ ìˆëŠ” ê²½ìš° - ì „ì²´ ì¤‘ ìµœì„  ì„ íƒ
                        rotation_candidates_sorted.sort(key=lambda x: (
                            x['candidate']['interference']['text_interference'],
                            x['candidate']['interference']['pipe_layer_interference'],
                            x['candidate']['interference']['pc_circle_interference'],
                            x['candidate']['interference']['30degree_polyline_interference'],
                            x['candidate']['interference']['general_score'],
                            x['ortho_diff']
                        ))
                        best_candidate = rotation_candidates_sorted[0]['candidate']
                    
                    print(f"   ğŸ“Œ ì°¨ì„ ì±…: {best_candidate['degree']}ë„ ì„ íƒ")
                
                if not best_candidate:
                    print(f"   âŒ ì ì ˆí•œ ìœ„ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ - SKIP")
                    continue
                
                # ì„ íƒëœ ê°ë„ë¡œ íšŒì „
                final_angle = best_candidate['angle']
                final_degree = best_candidate['degree']
                
                # ê°„ì„­ ìƒíƒœ ì¶œë ¥
                final_interference = best_candidate['interference']
                print(f"\n   ğŸ“Œ ìµœì¢… ì„ íƒ: {final_degree}ë„")
                
                # ìµœì¢… WA ê°ë„ì™€ ISO ì§êµ ì°¨ì´ ê³„ì‚°
                final_wa_angle = math.atan2(wdc_circle.dxf.center.y - welds_center.y, 
                                           wdc_circle.dxf.center.x - welds_center.x)
                final_wa_angle_deg = (math.degrees(final_wa_angle) + final_degree) % 360
                final_iso_angles = get_iso_orthogonal_angle(final_wa_angle_deg)
                
                min_ortho_diff = float('inf')
                closest_ortho = None
                for ortho_angle in final_iso_angles:
                    diff = abs(final_wa_angle_deg - ortho_angle)
                    if diff > 180:
                        diff = 360 - diff
                    if diff < min_ortho_diff:
                        min_ortho_diff = diff
                        closest_ortho = ortho_angle
                
                print(f"   - ìµœì¢… WA ê°ë„: {final_wa_angle_deg:.1f}Â° (ISO ì§êµ {closest_ortho}Â°ì™€ {min_ortho_diff:.1f}Â° ì°¨ì´)")
                print(f"   - TEXT ê°„ì„­: {final_interference['text_interference']}")
                print(f"   - PIPE/ELBO ê°„ì„­: {final_interference['pipe_layer_interference']}")
                print(f"   - PC-WDC ê±°ë¦¬ ë¬¸ì œ: {final_interference['pc_circle_interference']}")
                print(f"   - 30ë„ í´ë¦¬ë¼ì¸ ê°„ì„­: {final_interference['30degree_polyline_interference']}")
                print(f"   - ì¼ë°˜ ê°„ì„­ ì ìˆ˜: {final_interference['general_score']}")
                if final_interference.get('general_details'):
                    print(f"   - ì¼ë°˜ ê°„ì„­ í•­ëª©: {', '.join(final_interference['general_details'])}")
                
                # WD íšŒì „ ì‹¤í–‰ (íšŒì „ì´ í•„ìš”í•œ ê²½ìš°ë§Œ)
                if final_angle != 0:
                    for entity in wd_group['entities']:
                        rotate_entity_around_point(entity, welds_center, final_angle)
                    
                    # íšŒì „ í›„ í…ìŠ¤íŠ¸ë¥¼ WDC ì› ì¤‘ì‹¬ìœ¼ë¡œ ì¬ì •ë ¬
                    wdc_center_after_rotation = Vec2(wdc_circle.dxf.center.x, wdc_circle.dxf.center.y)
                    for txt in wd_group['wdt_texts']:
                        if is_horizontal_text(txt):
                            bbox = get_text_bounding_box(txt)
                            if bbox:
                                offset = wdc_center_after_rotation - bbox['center']
                                new_insert = Vec2(txt.dxf.insert.x + offset.x, 
                                                txt.dxf.insert.y + offset.y)
                                txt.dxf.insert = (new_insert.x, new_insert.y, 0)
                    print(f"   ğŸ”„ WDë¥¼ {final_degree}ë„ íšŒì „ ì™„ë£Œ")
                else:
                    print(f"   âœ… í˜„ì¬ ìœ„ì¹˜ê°€ ìµœì  - íšŒì „ ë¶ˆí•„ìš”")
                
                # íšŒì „ëœ WDC ìœ„ì¹˜
                rotated_wdc_center = Vec2(wdc_circle.dxf.center.x, wdc_circle.dxf.center.y)
                
                # ìƒˆë¡œìš´ WA ì„  ìƒì„± (WELDSì—ì„œ WDCë¡œ)
                new_wa_line = msp.add_line(
                    start=(welds_center.x, welds_center.y),
                    end=(rotated_wdc_center.x, rotated_wdc_center.y),
                    dxfattribs={'layer': 'WA'}
                )
                
                # ìƒˆë¡œ ìƒì„±í•œ WA ë¼ì¸ë§Œ WDC ì› ì•ˆì—ì„œ TRIM
                try:
                    direction = rotated_wdc_center - welds_center
                    if direction.magnitude > 0:
                        direction_normalized = direction.normalize()
                        # WDC ì›ì˜ ê°€ì¥ìë¦¬ê¹Œì§€ë§Œ ê·¸ë¦¬ê¸°
                        trim_distance = direction.magnitude - wdc_circle.dxf.radius
                        if trim_distance > 0:
                            trim_end = welds_center + direction_normalized * trim_distance
                            new_wa_line.dxf.end = (trim_end.x, trim_end.y, 0)
                            print(f"   âœ‚ï¸  WA ë¼ì¸ì„ WDC ì› ê°€ì¥ìë¦¬ì—ì„œ TRIM ì™„ë£Œ")
                    
                    # ìµœì¢… ê±°ë¦¬ í™•ì¸
                    final_distance = distance(welds_center, rotated_wdc_center)
                    print(f"   ğŸ“ ìµœì¢… WELDS-WDC ê±°ë¦¬: {final_distance:.2f}mm (ëª©í‘œ: {move_distance:.1f}mm)")
                    
                    # ìµœì¢… ê±°ë¦¬ê°€ ëª©í‘œì™€ 1mm ì´ìƒ ì°¨ì´ë‚˜ë©´ ê²½ê³ 
                    if abs(final_distance - move_distance) > 1.0:
                        print(f"   âš ï¸  ìµœì¢… ê±°ë¦¬ê°€ ëª©í‘œì™€ ì°¨ì´ë‚¨: {abs(final_distance - move_distance):.2f}mm")
                        # WDC ìƒ‰ìƒì„ ì£¼í™©ìƒ‰ìœ¼ë¡œ ë³€ê²½
                        wdc_circle.dxf.color = 30  # ORANGE
                    
                    # WA ìƒì„± ì„±ê³µ í‘œì‹œ
                    wd_group['wa_created'] = True
                    print(f"   âœ… WD íšŒì „ ë° WA ì¬ìƒì„± ì™„ë£Œ")
                    
                    # WAê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìœ¼ë¯€ë¡œ A1 ë¼ì¸ ì‚­ì œ
                    if 'a1_line' in wd_group and wd_group['a1_line']:
                        try:
                            msp.delete_entity(wd_group['a1_line'])
                            print(f"   ğŸ—‘ï¸  A1 ë¼ì¸ ì‚­ì œ ì™„ë£Œ")
                        except Exception as del_e:
                            print(f"   â— A1 ë¼ì¸ ì‚­ì œ ì˜¤ë¥˜: {del_e}")
                    
                    # ISOTEXT ë ˆì´ì–´ì˜ ê´€ë ¨ ì—”í‹°í‹°ë“¤ ì‚­ì œ
                    delete_isotext_entities(msp, wd_group)
                    
                except Exception as trim_e:
                    print(f"   âŒ WA ë¼ì¸ TRIM ì˜¤ë¥˜: {trim_e}")
                
            except Exception as e:
                print(f"âŒ WD ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
                continue
        
        # íŒŒì¼ ì €ì¥
        output_path = os.path.splitext(filepath)[0] + "_wno.dxf"
        doc.saveas(output_path)
        print(f"ğŸ“ ì €ì¥ëœ íŒŒì¼: {output_path}")
        
        # ì²˜ë¦¬ ê²°ê³¼ ìš”ì•½
        successful_wa_count = sum(1 for wd in wd_groups if wd.get('wa_created', False))
        print(f"\nğŸ“Š ì²˜ë¦¬ ê²°ê³¼ ìš”ì•½:")
        print(f"   - ì „ì²´ WD ê·¸ë£¹: {len(wd_groups)}ê°œ")
        print(f"   - ì²˜ë¦¬ ì‹¤íŒ¨: {failed_wd_count}ê°œ")
        print(f"   - ê¸´ WA ê±°ë¦¬ (10mm ì´ìƒ): {long_wa_count}ê°œ")
        print(f"   - WA ìƒì„± ì„±ê³µ: {successful_wa_count}ê°œ")
        print(f"   - WA ìƒì„± ì‹¤íŒ¨: {len(wd_groups) - successful_wa_count}ê°œ")