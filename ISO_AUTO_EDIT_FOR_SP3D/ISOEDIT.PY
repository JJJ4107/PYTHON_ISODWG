import os
import sys
import subprocess
import tkinter as tk
from tkinter import filedialog, messagebox
import glob
import time
import json
import shutil
import tempfile
import threading

# DXF íŒŒì¼ ì²˜ë¦¬ë¥¼ ìœ„í•œ ezdxf ë¼ì´ë¸ŒëŸ¬ë¦¬
try:
    import ezdxf
    EZDXF_AVAILABLE = True
except ImportError:
    EZDXF_AVAILABLE = False
    print("ezdxf ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤. ì„¤ì¹˜í•˜ì„¸ìš”: pip install ezdxf")

class DXFAutoProcessor:
    def __init__(self):
        # ì‹¤í–‰í•  Python ìŠ¤í¬ë¦½íŠ¸ ìˆœì„œ
        self.scripts = [
            "PLTONEWLINE_1.PY",
            "DIMEDIT_2.PY",
            "WELDEDIT_3.PY",
            "WELDTABLE_4.PY",
            "SUPPTAG_5.PY",
            "SPOOLNEDIT_6.PY",
            "ELBOEDIT_7.PY",
            "FALLEDIT_8.PY",
            "ITEMNOEDIT_9.PY",
            "OLETDIMDEL_10.PY",
            "POSDELETE_11.PY",
            "ISODWGNOSET_12.PY",
            "ISODWGNOFIX_13.PY"
        ]
        
        self.current_dir = os.path.dirname(os.path.abspath(__file__))
        self.config_file = os.path.join(self.current_dir, "dxf_automation_config.json")
        self.last_dxf_dir = self.load_last_directory()
        self.temp_dir = None
        self.temp_files = set()  # ì„ì‹œ íŒŒì¼ ì¶”ì 
        
        # ìë™í™” ì½”ë“œ í…œí”Œë¦¿
        self.wrapper_code = '''
import os
import sys
import types
import io

# ===== ìë™í™” ë˜í¼ ì‹œì‘ =====
# UTF-8 ì¸ì½”ë”© ì„¤ì •
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

# ìë™ ëª¨ë“œ í™•ì¸
if os.environ.get('AUTO_MODE') == 'TRUE':
    selected_file = os.environ.get('SELECTED_DXF_FILE')
    
    if selected_file and os.path.exists(selected_file):
        print(f"[ìë™í™”] íŒŒì¼ ì²˜ë¦¬: {os.path.basename(selected_file)}")
        
        # ì „ì—­ ë³€ìˆ˜ë¡œ ì„¤ì •
        import builtins
        setattr(builtins, 'SELECTED_FILE', selected_file)
        setattr(builtins, 'AUTO_MODE', True)
        
        # print í•¨ìˆ˜ ì˜¤ë²„ë¼ì´ë“œ
        original_print = print
        
        def safe_print(*args, **kwargs):
            try:
                original_print(*args, **kwargs)
            except UnicodeEncodeError:
                safe_args = []
                for arg in args:
                    if isinstance(arg, str):
                        safe_arg = arg.encode('cp949', errors='replace').decode('cp949')
                        safe_args.append(safe_arg)
                    else:
                        safe_args.append(arg)
                original_print(*safe_args, **kwargs)
        
        builtins.print = safe_print
        
        # Mock pyautogui ëª¨ë“ˆ
        mock_pyautogui = types.ModuleType('pyautogui')
        mock_pyautogui.click = lambda *args, **kwargs: None
        mock_pyautogui.moveTo = lambda *args, **kwargs: None
        mock_pyautogui.press = lambda *args, **kwargs: None
        mock_pyautogui.keyDown = lambda *args, **kwargs: None
        mock_pyautogui.keyUp = lambda *args, **kwargs: None
        mock_pyautogui.hotkey = lambda *args, **kwargs: None
        mock_pyautogui.typewrite = lambda *args, **kwargs: None
        mock_pyautogui.screenshot = lambda *args, **kwargs: None
        mock_pyautogui.locateOnScreen = lambda *args, **kwargs: None
        mock_pyautogui.locateCenterOnScreen = lambda *args, **kwargs: None
        mock_pyautogui.position = lambda: (0, 0)
        mock_pyautogui.size = lambda: (1920, 1080)
        mock_pyautogui.FAILSAFE = False
        mock_pyautogui.PAUSE = 0.1
        
        # Mock pymsgbox ëª¨ë“ˆ
        mock_pymsgbox = types.ModuleType('pymsgbox')
        mock_pymsgbox.alert = lambda *args, **kwargs: print(f"[ìë™í™”] Alert: {args}")
        mock_pymsgbox.confirm = lambda *args, **kwargs: 'OK'
        mock_pymsgbox.prompt = lambda *args, **kwargs: ''
        mock_pymsgbox.password = lambda *args, **kwargs: ''
        
        # Mock pygetwindow ëª¨ë“ˆ
        mock_pygetwindow = types.ModuleType('pygetwindow')
        
        # ëª¨ë“ˆ ë“±ë¡
        sys.modules['pyautogui'] = mock_pyautogui
        sys.modules['pymsgbox'] = mock_pymsgbox
        sys.modules['pygetwindow'] = mock_pygetwindow
        
        # tkinter ëª¨ë“ˆ ì™„ì „ ëŒ€ì²´
        class MockTk:
            def __init__(self, *args, **kwargs):
                self.mock = True
            def withdraw(self):
                pass
            def destroy(self):
                pass
            def mainloop(self):
                pass
            def quit(self):
                pass
            def deiconify(self):
                pass
            def title(self, *args):
                pass
            def geometry(self, *args):
                pass
            def protocol(self, *args):
                pass
            def bind(self, *args):
                pass
            def update(self):
                pass
            def update_idletasks(self):
                pass
            def configure(self, *args, **kwargs):
                pass
            def winfo_exists(self):
                return True
            def __getattr__(self, name):
                return lambda *args, **kwargs: None
        
        class MockToplevel(MockTk):
            pass
        
        class MockFiledialog:
            @staticmethod
            def askopenfilename(*args, **kwargs):
                print(f"[ìë™í™”] íŒŒì¼ ì„ íƒ ëŒ€í™”ìƒì í˜¸ì¶œ ì°¨ë‹¨ â†’ {os.path.basename(selected_file)} ë°˜í™˜")
                return selected_file
            
            @staticmethod
            def askopenfilenames(*args, **kwargs):
                print(f"[ìë™í™”] íŒŒì¼ ì„ íƒ ëŒ€í™”ìƒì í˜¸ì¶œ ì°¨ë‹¨ â†’ [{os.path.basename(selected_file)}] ë°˜í™˜")
                return (selected_file,)
            
            @staticmethod
            def asksaveasfilename(*args, **kwargs):
                base, ext = os.path.splitext(selected_file)
                save_file = base + "_result" + ext
                print(f"[ìë™í™”] ì €ì¥ ëŒ€í™”ìƒì í˜¸ì¶œ ì°¨ë‹¨ â†’ {os.path.basename(save_file)} ë°˜í™˜")
                return save_file
            
            @staticmethod
            def askdirectory(*args, **kwargs):
                return os.path.dirname(selected_file)
        
        # tkinter ëª¨ë“ˆ ëŒ€ì²´
        mock_tk = types.ModuleType('tkinter')
        mock_tk.Tk = MockTk
        mock_tk.Toplevel = MockToplevel
        mock_tk.Frame = MockTk
        mock_tk.Label = MockTk
        mock_tk.Button = MockTk
        mock_tk.Entry = MockTk
        mock_tk.Text = MockTk
        mock_tk.Canvas = MockTk
        mock_tk.Listbox = MockTk
        mock_tk.Menu = MockTk
        mock_tk.StringVar = lambda: types.SimpleNamespace(get=lambda: "", set=lambda x: None)
        mock_tk.IntVar = lambda: types.SimpleNamespace(get=lambda: 0, set=lambda x: None)
        mock_tk.BooleanVar = lambda: types.SimpleNamespace(get=lambda: False, set=lambda x: None)
        mock_tk.messagebox = types.SimpleNamespace(
            showinfo=lambda *args, **kwargs: print(f"[ìë™í™”] ë©”ì‹œì§€: {args}"),
            showerror=lambda *args, **kwargs: print(f"[ìë™í™”] ì˜¤ë¥˜: {args}"),
            showwarning=lambda *args, **kwargs: print(f"[ìë™í™”] ê²½ê³ : {args}"),
            askyesno=lambda *args, **kwargs: True,
            askokcancel=lambda *args, **kwargs: True
        )
        
        mock_filedialog = types.ModuleType('tkinter.filedialog')
        for attr in dir(MockFiledialog):
            if not attr.startswith('_'):
                setattr(mock_filedialog, attr, getattr(MockFiledialog, attr))
        
        # ì‹œìŠ¤í…œ ëª¨ë“ˆ ëŒ€ì²´
        sys.modules['tkinter'] = mock_tk
        sys.modules['tkinter.filedialog'] = mock_filedialog
        sys.modules['Tkinter'] = mock_tk
        
        # ë‹¤ë¥¸ ê°€ëŠ¥í•œ import ë°©ì‹ë„ ì°¨ë‹¨
        original_import = builtins.__import__
        
        def custom_import(name, *args, **kwargs):
            if name in ['tkinter', 'Tkinter', 'pyautogui', 'pymsgbox', 'pygetwindow']:
                if name == 'tkinter' or name == 'Tkinter':
                    return mock_tk
                elif name == 'pyautogui':
                    return mock_pyautogui
                elif name == 'pymsgbox':
                    return mock_pymsgbox
                elif name == 'pygetwindow':
                    return mock_pygetwindow
            elif name.startswith('tkinter.'):
                if name == 'tkinter.filedialog':
                    return mock_filedialog
                else:
                    return types.SimpleNamespace()
            return original_import(name, *args, **kwargs)
        
        builtins.__import__ = custom_import
        
        print("[ìë™í™”] GUI ëª¨ë“ˆ ëŒ€ì²´ ì™„ë£Œ")

# ===== ìë™í™” ë˜í¼ ë =====

'''
    
    def load_last_directory(self):
        """ë§ˆì§€ë§‰ìœ¼ë¡œ ì‚¬ìš©í•œ ë””ë ‰í† ë¦¬ ë¡œë“œ"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                    return config.get('last_dxf_dir', self.current_dir)
        except:
            pass
        return self.current_dir
    
    def save_last_directory(self, directory):
        """ë§ˆì§€ë§‰ ì‚¬ìš© ë””ë ‰í† ë¦¬ ì €ì¥"""
        try:
            config = {'last_dxf_dir': directory}
            with open(self.config_file, 'w') as f:
                json.dump(config, f)
        except:
            pass
    
    def select_dxf_files(self):
        """DXF íŒŒì¼ ì„ íƒ ëŒ€í™”ìƒì"""
        root = tk.Tk()
        root.withdraw()
        
        initial_dir = self.last_dxf_dir if os.path.exists(self.last_dxf_dir) else self.current_dir
        
        files = filedialog.askopenfilenames(
            title="ì²˜ë¦¬í•  DXF íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš” (ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥)",
            filetypes=[("DXF files", "*.dxf"), ("All files", "*.*")],
            initialdir=initial_dir
        )
        
        root.destroy()
        
        if files:
            self.last_dxf_dir = os.path.dirname(files[0])
            self.save_last_directory(self.last_dxf_dir)
        
        return list(files)
    
    def get_clean_filename(self, original_file):
        """íŒŒì¼ëª…ì—ì„œ _ ë’¤ì˜ ë‚´ìš©ì„ ì œê±°í•˜ê³  ACEPLANTë¥¼ ì¶”ê°€í•œ ì´ë¦„ ë°˜í™˜"""
        dir_name = os.path.dirname(original_file)
        base_name = os.path.splitext(os.path.basename(original_file))[0]
        
        # _ ë¬¸ìê°€ ìˆìœ¼ë©´ ê·¸ ì•ê¹Œì§€ë§Œ ì‚¬ìš©
        if '_' in base_name:
            base_name = base_name.split('_')[0]
        
        # ë¹ˆ ë¬¸ìì—´ì´ ë˜ë©´ ì›ë³¸ ì´ë¦„ ì‚¬ìš©
        if not base_name:
            base_name = os.path.splitext(os.path.basename(original_file))[0]
        
        # ACEPLANT ì¶”ê°€
        clean_name = base_name + 'ACEPLANT.dxf'
        return os.path.join(dir_name, clean_name)
    
    def create_wrapped_script(self, original_script_path):
        """ì›ë³¸ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ë˜í•‘í•œ ì„ì‹œ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±"""
        try:
            with open(original_script_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
        except UnicodeDecodeError:
            try:
                with open(original_script_path, 'r', encoding='cp949') as f:
                    original_content = f.read()
            except:
                with open(original_script_path, 'r', encoding='latin-1') as f:
                    original_content = f.read()
        
        wrapped_content = self.wrapper_code + original_content
        
        temp_script = os.path.join(self.temp_dir, f"wrapped_{os.path.basename(original_script_path)}")
        with open(temp_script, 'w', encoding='utf-8') as f:
            f.write(wrapped_content)
        
        return temp_script
    
    def find_newly_created_dxf(self, work_dir, before_time, exclude_files=None):
        """ìƒˆë¡œ ìƒì„±ëœ DXF íŒŒì¼ ì°¾ê¸°"""
        dxf_files = glob.glob(os.path.join(work_dir, "*.dxf"))
        
        if exclude_files is None:
            exclude_files = []
        
        new_files = []
        for f in dxf_files:
            skip = False
            for exclude in exclude_files:
                try:
                    if os.path.samefile(f, exclude):
                        skip = True
                        break
                except:
                    if os.path.abspath(f) == os.path.abspath(exclude):
                        skip = True
                        break
            
            if skip:
                continue
                
            if os.path.getmtime(f) > before_time:
                new_files.append(f)
        
        if new_files:
            return max(new_files, key=os.path.getmtime)
        
        return None
    
    def wait_for_file_ready(self, file_path, timeout=30):
        """íŒŒì¼ì´ ì™„ì „íˆ ìƒì„±ë˜ê³  ì“°ê¸°ê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°"""
        if not os.path.exists(file_path):
            return False
        
        start_time = time.time()
        last_size = -1
        stable_count = 0
        
        while time.time() - start_time < timeout:
            try:
                current_size = os.path.getsize(file_path)
                
                if current_size == last_size and current_size > 0:
                    stable_count += 1
                    if stable_count >= 3:
                        try:
                            with open(file_path, 'rb') as f:
                                f.read(1)
                            return True
                        except:
                            pass
                else:
                    stable_count = 0
                
                last_size = current_size
                time.sleep(0.5)
                
            except Exception:
                time.sleep(0.5)
        
        return False
    
    def process_single_file(self, original_file):
        """í•˜ë‚˜ì˜ DXF íŒŒì¼ì„ ëª¨ë“  ìŠ¤í¬ë¦½íŠ¸ë¡œ ì²˜ë¦¬"""
        current_file = original_file
        work_dir = os.path.dirname(original_file)
        processed_files = [original_file]  # ì²˜ë¦¬ ê³¼ì •ì—ì„œ ìƒì„±ëœ íŒŒì¼ë“¤
        
        print(f"\níŒŒì¼ ì²˜ë¦¬ ì‹œì‘: {os.path.basename(original_file)}")
        print("=" * 60)
        
        for script_idx, script in enumerate(self.scripts):
            print(f"  [{script_idx+1}/{len(self.scripts)}] {script} ì‹¤í–‰ ì¤‘...", end="")
            
            original_script_path = os.path.join(self.current_dir, script)
            
            if not os.path.exists(original_script_path):
                print(" âš  ìŠ¤í¬ë¦½íŠ¸ ì—†ìŒ")
                continue
            
            wrapped_script = self.create_wrapped_script(original_script_path)
            before_time = time.time()
            
            try:
                env = os.environ.copy()
                env['SELECTED_DXF_FILE'] = current_file
                env['AUTO_MODE'] = 'TRUE'
                env['PYTHONIOENCODING'] = 'utf-8'
                
                if sys.platform == 'win32':
                    startupinfo = subprocess.STARTUPINFO()
                    startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
                    startupinfo.wShowWindow = subprocess.SW_HIDE
                else:
                    startupinfo = None
                
                process = subprocess.Popen(
                    [sys.executable, wrapped_script],
                    env=env,
                    cwd=work_dir,
                    startupinfo=startupinfo,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    encoding='utf-8',
                    errors='replace'
                )
                
                stdout, stderr = process.communicate(timeout=120)
                
                if process.returncode == 0:
                    print(" âœ“")
                    
                    time.sleep(2)
                    
                    new_file = self.find_newly_created_dxf(work_dir, before_time, processed_files)
                    
                    if new_file and self.wait_for_file_ready(new_file):
                        processed_files.append(new_file)
                        self.temp_files.add(new_file)
                        current_file = new_file
                    elif os.path.exists(current_file) and os.path.getmtime(current_file) > before_time:
                        pass  # í˜„ì¬ íŒŒì¼ì´ ìˆ˜ì •ë¨
                else:
                    print(" âš  ì˜¤ë¥˜")
                    if stderr:
                        print(f"      ì˜¤ë¥˜: {stderr.strip()[:100]}")
                
            except subprocess.TimeoutExpired:
                print(" â± ì‹œê°„ ì´ˆê³¼")
                process.kill()
            except Exception as e:
                print(f" âœ— ì˜¤ë¥˜: {str(e)}")
            finally:
                try:
                    os.remove(wrapped_script)
                except:
                    pass
            
            time.sleep(1)
        
        return current_file, processed_files
    
    def rename_all_layers_to_aceplant(self, dxf_file):
        """DXF íŒŒì¼ì˜ ëª¨ë“  ë ˆì´ì–´ ì´ë¦„ì„ ACEPLANTë¡œ ë³€ê²½"""
        if not EZDXF_AVAILABLE:
            print(f"  âœ— ezdxf ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì—†ì–´ ë ˆì´ì–´ ë³€ê²½ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
            return False
            
        try:
            print(f"\në ˆì´ì–´ ì´ë¦„ ë³€ê²½ ì¤‘: {os.path.basename(dxf_file)}")
            
            # DXF íŒŒì¼ ì½ê¸°
            doc = ezdxf.readfile(dxf_file)
            
            # ëª¨ë“  ì—”í‹°í‹°ì˜ ë ˆì´ì–´ë¥¼ ACEPLANTë¡œ ë³€ê²½
            for entity in doc.modelspace():
                entity.dxf.layer = "ACEPLANT"
            
            # í˜ì´í¼ìŠ¤í˜ì´ìŠ¤ì˜ ì—”í‹°í‹°ë„ ì²˜ë¦¬
            for layout in doc.layouts:
                if layout.name != 'Model':
                    for entity in layout:
                        try:
                            entity.dxf.layer = "ACEPLANT"
                        except:
                            pass
            
            # ë¸”ë¡ ë‚´ë¶€ì˜ ì—”í‹°í‹°ë„ ì²˜ë¦¬
            for block in doc.blocks:
                for entity in block:
                    try:
                        entity.dxf.layer = "ACEPLANT"
                    except:
                        pass
            
            # ê¸°ì¡´ ë ˆì´ì–´ë“¤ ì‚­ì œ (ACEPLANTì™€ 0 ë ˆì´ì–´ ì œì™¸)
            layers_to_delete = []
            for layer in doc.layers:
                if layer.dxf.name not in ['ACEPLANT', '0']:
                    layers_to_delete.append(layer.dxf.name)
            
            # ACEPLANT ë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ìƒì„±
            if 'ACEPLANT' not in [layer.dxf.name for layer in doc.layers]:
                doc.layers.new(name='ACEPLANT')
            
            # ë¶ˆí•„ìš”í•œ ë ˆì´ì–´ ì‚­ì œ
            for layer_name in layers_to_delete:
                try:
                    doc.layers.remove(layer_name)
                except:
                    pass
            
            # ì„ì‹œ íŒŒì¼ë¡œ ì €ì¥
            temp_file = dxf_file + '.tmp'
            doc.saveas(temp_file)
            
            # ì›ë³¸ íŒŒì¼ êµì²´
            os.remove(dxf_file)
            os.rename(temp_file, dxf_file)
            
            print(f"  âœ“ ëª¨ë“  ë ˆì´ì–´ê°€ ACEPLANTë¡œ ë³€ê²½ë¨")
            return True
            
        except Exception as e:
            print(f"  âœ— ë ˆì´ì–´ ë³€ê²½ ì‹¤íŒ¨: {str(e)}")
            return False
    
    def cleanup_temp_files(self, original_files, final_files, keep_files):
        """ì„ì‹œ íŒŒì¼ ì •ë¦¬"""
        print("\nì„ì‹œ íŒŒì¼ ì •ë¦¬ ì¤‘...")
        
        # ë³´ì¡´í•´ì•¼ í•  íŒŒì¼ë“¤
        keep_set = set()
        for f in original_files + final_files + keep_files:
            if f and os.path.exists(f):
                keep_set.add(os.path.abspath(f))
        
        # ì„ì‹œ íŒŒì¼ ì‚­ì œ
        deleted_count = 0
        for temp_file in list(self.temp_files):
            try:
                abs_temp = os.path.abspath(temp_file)
                if abs_temp not in keep_set and os.path.exists(temp_file):
                    os.remove(temp_file)
                    deleted_count += 1
                    print(f"  âœ“ ì‚­ì œ: {os.path.basename(temp_file)}")
            except Exception as e:
                print(f"  âœ— ì‚­ì œ ì‹¤íŒ¨: {os.path.basename(temp_file)} - {str(e)}")
        
        print(f"  ì´ {deleted_count}ê°œ ì„ì‹œ íŒŒì¼ ì‚­ì œë¨")
    
    def process_files(self):
        """ì„ íƒëœ DXF íŒŒì¼ë“¤ì„ ì²˜ë¦¬"""
        files = self.select_dxf_files()
        
        if not files:
            messagebox.showinfo("ì•Œë¦¼", "ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        print(f"\n{'='*60}")
        print(f"DXF ìë™ ì²˜ë¦¬ ì‹œì‘")
        print(f"ì„ íƒëœ íŒŒì¼: {len(files)}ê°œ")
        for f in files:
            print(f"  - {os.path.basename(f)}")
        print(f"{'='*60}")
        
        self.temp_dir = tempfile.mkdtemp()
        final_results = {}
        
        try:
            # ê° íŒŒì¼ì„ ê°œë³„ì ìœ¼ë¡œ ì²˜ë¦¬
            for file_idx, original_file in enumerate(files, 1):
                print(f"\n\n[íŒŒì¼ {file_idx}/{len(files)}] ì²˜ë¦¬ ì¤‘...")
                
                # ëª¨ë“  ìŠ¤í¬ë¦½íŠ¸ë¡œ íŒŒì¼ ì²˜ë¦¬
                final_file, temp_files = self.process_single_file(original_file)
                
                # ë ˆì´ì–´ ì´ë¦„ ë³€ê²½ (ezdxfê°€ ìˆì„ ë•Œë§Œ)
                if final_file and os.path.exists(final_file):
                    if EZDXF_AVAILABLE:
                        self.rename_all_layers_to_aceplant(final_file)
                    else:
                        print("  âš  ezdxfê°€ ì—†ì–´ ë ˆì´ì–´ ë³€ê²½ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
                
                # ìµœì¢… íŒŒì¼ëª… ìƒì„± ë° ì €ì¥ (ì˜ˆ: drawing_Final_v2.dxf â†’ drawingACEPLANT.dxf)
                clean_name = self.get_clean_filename(original_file)
                final_path = os.path.join(os.path.dirname(original_file), clean_name)
                
                try:
                    # ìµœì¢… íŒŒì¼ì´ ì›ë³¸ê³¼ ë‹¤ë¥¸ ê²½ìš°
                    if os.path.abspath(final_file) != os.path.abspath(final_path):
                        # ê¸°ì¡´ íŒŒì¼ì´ ìˆìœ¼ë©´ ë°±ì—…
                        if os.path.exists(final_path) and os.path.abspath(final_path) != os.path.abspath(original_file):
                            backup_path = final_path + '.bak'
                            shutil.move(final_path, backup_path)
                            self.temp_files.add(backup_path)
                        
                        # ìµœì¢… íŒŒì¼ ë³µì‚¬
                        shutil.copy2(final_file, final_path)
                        print(f"  âœ“ ìµœì¢… íŒŒì¼ ì €ì¥: {clean_name}")
                    
                    final_results[original_file] = final_path
                    
                except Exception as e:
                    print(f"  âœ— ìµœì¢… íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: {str(e)}")
                    final_results[original_file] = final_file
            
            # ì„ì‹œ íŒŒì¼ ì •ë¦¬
            keep_files = list(final_results.values())
            self.cleanup_temp_files(files, keep_files, [])
            
            # ê²°ê³¼ ì¶œë ¥
            print(f"\n\n{'='*60}")
            print("ğŸ‰ ëª¨ë“  ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
            print(f"\nì²˜ë¦¬ ê²°ê³¼:")
            print(f"  ì›ë³¸ íŒŒì¼: {len(files)}ê°œ")
            print(f"  ì²˜ë¦¬ ì™„ë£Œ: {len(final_results)}ê°œ")
            print(f"\nìµœì¢… íŒŒì¼ ëª©ë¡:")
            for original, final in final_results.items():
                if os.path.exists(final):
                    print(f"  âœ“ {os.path.basename(original)} â†’ {os.path.basename(final)}")
                else:
                    print(f"  âœ— {os.path.basename(original)} (ì²˜ë¦¬ ì‹¤íŒ¨)")
            print(f"{'='*60}")
            
        except Exception as e:
            print(f"\n\nì‹¬ê°í•œ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
            import traceback
            traceback.print_exc()
            
        finally:
            # ì„ì‹œ ë””ë ‰í† ë¦¬ ì •ë¦¬
            if self.temp_dir and os.path.exists(self.temp_dir):
                try:
                    shutil.rmtree(self.temp_dir)
                except:
                    print(f"\nì„ì‹œ ë””ë ‰í† ë¦¬ ì‚­ì œ ì‹¤íŒ¨: {self.temp_dir}")

def main():
    print("DXF ìë™ ì²˜ë¦¬ í”„ë¡œê·¸ë¨ v2.1")
    print("="*60)
    print("ì´ í”„ë¡œê·¸ë¨ì˜ ê¸°ëŠ¥:")
    print("  1. ì„ íƒëœ DXF íŒŒì¼ë“¤ì„ ì§€ì •ëœ Python ìŠ¤í¬ë¦½íŠ¸ë¡œ ìˆœì°¨ ì²˜ë¦¬")
    print("  2. ì²˜ë¦¬ ì¤‘ ìƒì„±ëœ ì„ì‹œ íŒŒì¼ë“¤ ìë™ ì‚­ì œ")
    print("  3. ìµœì¢… íŒŒì¼ì˜ ëª¨ë“  ë ˆì´ì–´ë¥¼ ACEPLANTë¡œ ë³€ê²½")
    print("  4. íŒŒì¼ëª…ì—ì„œ _ ë’¤ì˜ ë‚´ìš©ì„ ì œê±°í•˜ê³  'ACEPLANT.dxf'ë¡œ ì €ì¥")
    print("     ì˜ˆ: drawing_Final_v2.dxf â†’ drawingACEPLANT.dxf")
    print("\nì°¸ê³ : ë ˆì´ì–´ ë³€ê²½ ê¸°ëŠ¥ì€ ezdxf ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.")
    print("     ì„¤ì¹˜ ëª…ë ¹ì–´: pip install ezdxf")
    print("="*60)
    
    # ezdxf ë¼ì´ë¸ŒëŸ¬ë¦¬ í™•ì¸
    if not EZDXF_AVAILABLE:
        print("\nâš  ezdxf ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤!")
        print("ì„¤ì¹˜ ëª…ë ¹ì–´: pip install ezdxf")
        input("\nEnter í‚¤ë¥¼ ëˆŒëŸ¬ ì¢…ë£Œ...")
        return
    
    try:
        # ë²„ì „ í™•ì¸ - ì—¬ëŸ¬ ë°©ë²• ì‹œë„
        version = None
        if hasattr(ezdxf, '__version__'):
            version = ezdxf.__version__
        elif hasattr(ezdxf, 'version'):
            if isinstance(ezdxf.version, str):
                version = ezdxf.version
            elif hasattr(ezdxf.version, '__version__'):
                version = ezdxf.version.__version__
        
        if version:
            print(f"ezdxf ë²„ì „: {version}")
        else:
            print("ezdxfê°€ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤.")
    except Exception as e:
        print(f"ezdxf ë²„ì „ í™•ì¸ ì¤‘ ì˜¤ë¥˜: {e}")
        print("ezdxfê°€ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤.")
    
    processor = DXFAutoProcessor()
    
    # ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ í™•ì¸
    missing = []
    print(f"\ní˜„ì¬ ë””ë ‰í† ë¦¬: {processor.current_dir}")
    print("\nìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ í™•ì¸ ì¤‘...")
    
    for script in processor.scripts:
        script_path = os.path.join(processor.current_dir, script)
        if os.path.exists(script_path):
            print(f"  âœ“ {script}")
        else:
            print(f"  âœ— {script} (ëˆ„ë½)")
            missing.append(script)
    
    if missing:
        print(f"\nâš  ì´ {len(missing)}ê°œì˜ ìŠ¤í¬ë¦½íŠ¸ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.")
        print("  ëˆ„ë½ëœ ìŠ¤í¬ë¦½íŠ¸ë¡œ ì¸í•´ ì¼ë¶€ ì²˜ë¦¬ê°€ ê±´ë„ˆë›°ì–´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
        if input("\nê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ").lower() != 'y':
            return
    else:
        print(f"\nâœ“ ëª¨ë“  ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.")
    
    try:
        processor.process_files()
    except KeyboardInterrupt:
        print("\n\nì‚¬ìš©ìì— ì˜í•´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
    except Exception as e:
        print(f"\n\nì˜¤ë¥˜ ë°œìƒ: {str(e)}")
        import traceback
        traceback.print_exc()
    
    print("\nì¢…ë£Œí•˜ë ¤ë©´ Enter í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”...")
    input()

if __name__ == "__main__":
    main()