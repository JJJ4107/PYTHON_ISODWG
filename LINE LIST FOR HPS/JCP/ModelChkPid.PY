import fitz  # PyMuPDF
import re
import csv
import math
import os
from collections import defaultdict
from tkinter import Tk, filedialog
from datetime import datetime

# ë‚ ì§œ ë¬¸ìì—´
today_str = datetime.now().strftime("%Y%m%d")

# íŒŒì¼ ì„ íƒ
root = Tk()
root.withdraw()
pdf_paths = filedialog.askopenfilenames(title="PDF íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”", filetypes=[("PDF files", "*.pdf")])
if not pdf_paths:
    print("âŒ PDF íŒŒì¼ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    exit()

model_csv_path = filedialog.askopenfilename(title="MODEL.CSV íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”", filetypes=[("CSV files", "*.csv")])
if not model_csv_path:
    print("âŒ MODEL.CSV íŒŒì¼ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    exit()

# MODEL ëª©ë¡ ë¡œë”©
with open(model_csv_path, newline='', encoding='utf-8-sig') as f:
    reader = csv.reader(f)
    model_set = set(row[0].strip().upper() for row in reader if row and row[0].strip())

# ì •ê·œì‹
P1_PATTERN = re.compile(r'^(00|11|21|22)[A-Za-z0-9]{0,7}$', re.IGNORECASE)
P2_PATTERN = re.compile(r'^(BR|AA)[A-Za-z0-9]{0,8}$', re.IGNORECASE)
P3_DN_PATTERN = re.compile(r'^DN.{0,11}$', re.IGNORECASE)
P3_H_PATTERN = re.compile(r'^H.{0,11}$', re.IGNORECASE)

# ê±°ë¦¬ ê³„ì‚°
def center(rect): return ((rect.x0 + rect.x1) / 2, (rect.y0 + rect.y1) / 2)
def distance(r1, r2): return math.hypot(center(r1)[0] - center(r2)[0], center(r1)[1] - center(r2)[1])
def normalize_p3(*words): return '-'.join(w.replace(' ', '-') for w in words if w).replace('--', '-')
def highlight(page, rect, color, opacity=0.4):
    annot = page.add_rect_annot(rect)
    annot.set_colors(stroke=color)
    annot.set_opacity(opacity)
    annot.update()

# PDF ì²˜ë¦¬
for input_pdf_path in pdf_paths:
    base_name = os.path.splitext(os.path.basename(input_pdf_path))[0]
    folder = os.path.dirname(input_pdf_path)

    output_pdf = os.path.join(folder, f"CHK_{base_name}_{today_str}.PDF")
    unmodel_csv = os.path.join(folder, f"UNMODEL_{base_name}_{today_str}.CSV")
    unmodel_sorted_csv = os.path.join(folder, f"UNMODEL_SORTED_{base_name}_{today_str}.CSV")

    doc = fitz.open(input_pdf_path)
    unmatched_set = set()

    for page_num, page in enumerate(doc, 1):
        words = page.get_text("words")
        n = len(words)
        for i, w in enumerate(words):
            text = w[4].strip().replace(" ", "")
            if not P1_PATTERN.match(text):
                continue
            p1 = text
            p1_rect = fitz.Rect(w[:4])
            highlight(page, p1_rect, color=(0, 1, 0), opacity=0.2)

            # P2 íƒìƒ‰
            min_dist = float('inf')
            found_p2 = None
            found_p2_rect = None
            for j, next_w in enumerate(words):
                if i == j:
                    continue
                next_text = next_w[4].strip().replace(" ", "")
                if not P2_PATTERN.match(next_text):
                    continue
                next_rect = fitz.Rect(next_w[:4])
                dist = distance(p1_rect, next_rect)
                if dist < min_dist:
                    min_dist = dist
                    found_p2 = next_text
                    found_p2_rect = next_rect
            if not found_p2:
                continue
            highlight(page, found_p2_rect, color=(1, 0.5, 0), opacity=0.2)

            # P3 ìˆëŠ” ê²½ìš° â†’ LINE NO
            if found_p2.upper().startswith("BR"):
                min_dist3 = float('inf')
                found_p3 = None
                found_p3_rect = None
                for k, next_w3 in enumerate(words):
                    dn_raw = next_w3[4].strip()
                    if not P3_DN_PATTERN.match(dn_raw):
                        continue
                    dn_rect = fitz.Rect(next_w3[:4])
                    dist3 = distance(found_p2_rect, dn_rect)
                    if dist3 < min_dist3:
                        p3_full = dn_raw
                        p3_rects = [dn_rect]
                        if k + 1 < n:
                            next_h_word = words[k + 1][4].strip()
                            next_h_rect = fitz.Rect(words[k + 1][:4])
                            if P3_H_PATTERN.match(next_h_word) and distance(dn_rect, next_h_rect) < 20:
                                p3_full = f"{dn_raw} {next_h_word}"
                                p3_rects.append(next_h_rect)
                        found_p3 = normalize_p3(*p3_full.split())
                        found_p3_rect = p3_rects[0]
                        min_dist3 = dist3
                if found_p3:
                    full_line_no = f"{p1}-{found_p2.replace(' ', '-')}-{found_p3}"
                    highlight(page, found_p3_rect, color=(0, 0, 1), opacity=0.2)
                    if full_line_no not in model_set:
                        unmatched_set.add(full_line_no)
                        highlight(page, p1_rect, color=(1, 0, 0), opacity=0.4)
                        highlight(page, found_p2_rect, color=(1, 0, 0), opacity=0.4)
                        highlight(page, found_p3_rect, color=(1, 0, 0), opacity=0.4)
            elif found_p2.upper().startswith("AA"):
                full_valve_no = f"{p1}-{found_p2.replace(' ', '-')}"
                if full_valve_no not in model_set:
                    unmatched_set.add(full_valve_no)
                    highlight(page, p1_rect, color=(1, 0, 0), opacity=0.4)
                    highlight(page, found_p2_rect, color=(1, 0, 0), opacity=0.4)

    # í•˜ì´ë¼ì´íŠ¸ ì €ì¥
    doc.save(output_pdf)
    doc.close()
    print(f"ğŸ“„ CHK PDF ì €ì¥ ì™„ë£Œ: {output_pdf}")

    # UNMODEL CSV ì €ì¥
    if unmatched_set:
        with open(unmodel_csv, "w", newline='', encoding='utf-8-sig') as f:
            writer = csv.writer(f)
            writer.writerow(["UNMODELED P1"])
            for p in sorted(unmatched_set):
                writer.writerow([p])
        print(f"âŒ UNMODELED ì €ì¥ ì™„ë£Œ: {unmodel_csv}")
    else:
        print("âœ… ëª¨ë“  P1ì´ MODEL.CSVì™€ ì¼ì¹˜í•©ë‹ˆë‹¤.")

    # ì •ë ¬ í…Œì´ë¸” ì €ì¥ (LINE / VALVE ì„¸ë¡œ êµ¬ë¶„)
    line_nos = sorted([p for p in unmatched_set if "-BR" in p])
    valve_nos = sorted([p for p in unmatched_set if any(tag in p for tag in ["-AA", "-AJ", "-BJ", "-AT"])])

    max_len = max(len(line_nos), len(valve_nos))
    with open(unmodel_sorted_csv, "w", newline='', encoding='utf-8-sig') as f:
        writer = csv.writer(f)
        writer.writerow(["LINE NO", "VALVE NO"])
        for i in range(max_len):
            line_val = line_nos[i] if i < len(line_nos) else ""
            valve_val = valve_nos[i] if i < len(valve_nos) else ""
            writer.writerow([line_val, valve_val])
    print(f"ğŸ§¾ ì •ë¦¬ëœ UNMODEL í…Œì´ë¸” ì €ì¥ ì™„ë£Œ: {unmodel_sorted_csv}")
