import ezdxf
import tkinter as tk
from tkinter import filedialog
import math
import os
import traceback
import sys

CYAN = 4
RED = 1
YELLOW = 2
BLUE = 5
MAGENTA = 6
WHITE = 7
SL1_LENGTH = 4.4
HALF_SL1 = 0.7  # ì›ì˜ ë°˜ì§€ë¦„ì„ 0.7mmë¡œ ë³€ê²½
LINE_LENGTH = 3.5  # ì„ ì˜ ê¸¸ì´ 3.5mm
LINE_WIDTH = 0.6  # ì„  ë‘ê»˜ 0.6
NODENO_RADIUS = 2.9  # NODENO ì›ì˜ ë°˜ì§€ë¦„ (ì§€ë¦„ 5.8mm)
NODENO_OFFSET_Y = 7.3  # Yë°©í–¥ ì´ë™ ê±°ë¦¬
ROTATION_ANGLE = 30  # íšŒì „ ê°ë„ (ë„)
TEXT_HEIGHT = 2.0  # í…ìŠ¤íŠ¸ ë†’ì´

def calc_distance(p1, p2):
    return math.hypot(p1[0] - p2[0], p1[1] - p2[1])

def extract_points(ent):
    try:
        if not ent or not hasattr(ent, 'dxf') or ent.dxf is None:
            return []
        t = ent.dxftype()
        if t == 'LINE':
            return [(ent.dxf.start.x, ent.dxf.start.y), (ent.dxf.end.x, ent.dxf.end.y)]
        if t == 'LWPOLYLINE':
            return [tuple(pt[:2]) for pt in ent.get_points()]
        if t == 'POLYLINE':
            return [(v.dxf.location.x, v.dxf.location.y) for v in ent.vertices]
    except:
        pass
    return []

def has_curve(ent):
    t = ent.dxftype()
    if t == 'LWPOLYLINE':
        for pt in ent.get_points():
            if len(pt) > 4 and abs(pt[4]) > 1e-3:
                return True
    if t == 'POLYLINE':
        for v in ent.vertices:
            if hasattr(v.dxf, 'bulge') and abs(v.dxf.bulge) > 1e-3:
                return True
    return False

def polyline_length(pts):
    return sum(calc_distance(pts[i], pts[i+1]) for i in range(len(pts)-1))

def midpoint(pts):
    return (sum(p[0] for p in pts)/len(pts), sum(p[1] for p in pts)/len(pts))

def is_valid_s1(ent):
    if has_curve(ent): return False
    pts = extract_points(ent)
    if len(pts) != 2: return False
    L = polyline_length(pts)
    return 3.4 <= L <= 3.6  # S1 ê¸¸ì´ ì¡°ê±´ ë³€ê²½: 3.4~3.6

def is_ps_candidate(pts):
    return len(pts) == 7 and any(calc_distance(pts[i], pts[i+1]) >= 3.0 for i in range(6))

def point_at_distance(origin, target, dist):
    dx, dy = target[0] - origin[0], target[1] - origin[1]
    length = math.hypot(dx, dy)
    if length == 0:
        return origin
    ux, uy = dx / length, dy / length
    return (origin[0] + ux * dist, origin[1] + uy * dist)

def find_arrow_lines(msp, a1_points):
    """A1ì˜ ëì ì— ì ‘í•˜ëŠ” ARROW ë ˆì´ì–´ì˜ 1mm ì´í•˜ LINE ì°¾ê¸°"""
    arrow_lines = []
    for e in msp:
        if e.dxftype() == 'LINE' and e.dxf.layer == 'ARROW':
            line_pts = extract_points(e)
            if len(line_pts) == 2:
                line_length = calc_distance(line_pts[0], line_pts[1])
                if line_length <= 1.0:  # 1mm ì´í•˜
                    # A1ì˜ ê° ëì ê³¼ LINEì˜ ëì  ê°„ ê±°ë¦¬ í™•ì¸
                    for a1_pt in [a1_points[0], a1_points[-1]]:  # A1ì˜ ì²«ì ê³¼ ëì 
                        for line_pt in line_pts:
                            if calc_distance(a1_pt, line_pt) <= 0.1:  # 0.1mm ì´ë‚´ë©´ ì ‘ì´‰
                                arrow_lines.append(e)
                                break
    return arrow_lines

def get_pipe_angle(pts1, pts2):
    """ë‘ S1 í´ë¦¬ë¼ì¸ì—ì„œ íŒŒì´í”„ì˜ ì£¼ ë°©í–¥ ê°ë„ë¥¼ ê³„ì‚°"""
    # ê° í´ë¦¬ë¼ì¸ì˜ ë°©í–¥ ë²¡í„° ê³„ì‚°
    dir1 = (pts1[1][0] - pts1[0][0], pts1[1][1] - pts1[0][1])
    dir2 = (pts2[1][0] - pts2[0][0], pts2[1][1] - pts2[0][1])
    
    # í‰ê·  ë°©í–¥ ê³„ì‚°
    avg_dir = ((dir1[0] + dir2[0])/2, (dir1[1] + dir2[1])/2)
    
    # ê°ë„ ê³„ì‚° (ë¼ë””ì•ˆ)
    angle = math.atan2(avg_dir[1], avg_dir[0])
    
    return angle

def create_iso_orthogonal_lines(center, pipe_angle, length, msp):
    """ISO ë„ë©´ ê¸°ì¤€ìœ¼ë¡œ íŒŒì´í”„ì— ì§êµí•˜ëŠ” 4ê°œ ë°©í–¥ìœ¼ë¡œ ì„ ì„ ìƒì„±"""
    lines = []
    
    # íŒŒì´í”„ ê°ë„ë¥¼ ë„ ë‹¨ìœ„ë¡œ ë³€í™˜
    pipe_angle_deg = math.degrees(pipe_angle) % 360
    
    # ISO ë„ë©´ì˜ í‘œì¤€ ê°ë„ë“¤ (30ë„ ê°„ê²©)
    # íŒŒì´í”„ ë°©í–¥ë³„ë¡œ ì§êµí•˜ëŠ” ISO í‘œì¤€ ê°ë„ ì„ íƒ
    
    if abs(pipe_angle_deg - 90) < 5 or abs(pipe_angle_deg - 270) < 5:
        # ìˆ˜ì§ íŒŒì´í”„ (90ë„): ì§êµëŠ” ìˆ˜í‰ ë°©í–¥ë“¤
        # ISO ìˆ˜í‰: 30ë„, 150ë„ì™€ ê·¸ ë°˜ëŒ€
        angles = [30, 210, 150, 330]  # 30+180=210, 150+180=330
        
    elif abs(pipe_angle_deg - 30) < 5 or abs(pipe_angle_deg - 210) < 5:
        # 30ë„ íŒŒì´í”„: ì§êµëŠ” 120ë„, 300ë„
        angles = [120, 300]  # ì´ë¯¸ ì„œë¡œ 180ë„ ì°¨ì´
        # ISO ë„ë©´ì—ì„œëŠ” ë³´í†µ 90ë„(ìˆ˜ì§)ë„ í¬í•¨
        angles.extend([90, 270])
        
    elif abs(pipe_angle_deg - 150) < 5 or abs(pipe_angle_deg - 330) < 5:
        # 150ë„ íŒŒì´í”„: ì§êµëŠ” 60ë„, 240ë„
        angles = [60, 240]  # ì´ë¯¸ ì„œë¡œ 180ë„ ì°¨ì´
        # ISO ë„ë©´ì—ì„œëŠ” ë³´í†µ 90ë„(ìˆ˜ì§)ë„ í¬í•¨
        angles.extend([90, 270])
        
    elif abs(pipe_angle_deg - 0) < 5 or abs(pipe_angle_deg - 180) < 5:
        # ìˆ˜í‰ íŒŒì´í”„ (0ë„/180ë„): ì§êµëŠ” 90ë„, 270ë„
        angles = [90, 270]
        # ISO ê°ë„ ì¶”ê°€
        angles.extend([60, 240])  # ë˜ëŠ” [120, 300]
        
    else:
        # ê¸°íƒ€ ê°ë„: ê°€ì¥ ê°€ê¹Œìš´ ISO í‘œì¤€ ê°ë„ë¡œ ë§ì¶¤
        # ì§êµ ê°ë„ ê³„ì‚° í›„ ê°€ì¥ ê°€ê¹Œìš´ 30ë„ ë°°ìˆ˜ë¡œ ë°˜ì˜¬ë¦¼
        orth1 = pipe_angle_deg + 90
        orth2 = pipe_angle_deg - 90
        
        # 30ë„ ë‹¨ìœ„ë¡œ ë°˜ì˜¬ë¦¼
        orth1_iso = round(orth1 / 30) * 30
        orth2_iso = round(orth2 / 30) * 30
        
        angles = [orth1_iso % 360, (orth1_iso + 180) % 360,
                  orth2_iso % 360, (orth2_iso + 180) % 360]
    
    # ì¤‘ë³µ ì œê±°
    unique_angles = list(dict.fromkeys(angles))
    
    # ê° ë°©í–¥ìœ¼ë¡œ 3.5mm ì„  ê·¸ë¦¬ê¸° (ìµœëŒ€ 4ê°œ)
    for angle_deg in unique_angles[:4]:
        angle_rad = math.radians(angle_deg)
        end_point = (center[0] + length * math.cos(angle_rad),
                     center[1] + length * math.sin(angle_rad))
        
        line = msp.add_line(center, end_point, 
                          dxfattribs={'color': BLUE, 'lineweight': 60})
        lines.append(line)
    
    return lines

def rotate_point(point, center, angle_deg):
    """ì ì„ ì¤‘ì‹¬ì  ê¸°ì¤€ìœ¼ë¡œ íšŒì „"""
    angle_rad = math.radians(angle_deg)
    cos_a = math.cos(angle_rad)
    sin_a = math.sin(angle_rad)
    
    dx = point[0] - center[0]
    dy = point[1] - center[1]
    
    new_x = center[0] + dx * cos_a - dy * sin_a
    new_y = center[1] + dx * sin_a + dy * cos_a
    
    return (new_x, new_y)

def check_circle_interference(circle_center, radius, msp, exclude_entities=[]):
    """ì›ê³¼ ë‹¤ë¥¸ ì—”í‹°í‹°ë“¤ ê°„ì˜ ê°„ì„­ ì²´í¬"""
    for ent in msp:
        if ent in exclude_entities:
            continue
            
        ent_type = ent.dxftype()
        if ent_type in ['LINE', 'LWPOLYLINE', 'POLYLINE']:
            pts = extract_points(ent)
            if len(pts) >= 2:
                # ê° ì„ ë¶„ê³¼ ì›ì˜ ê°„ì„­ ì²´í¬
                for i in range(len(pts) - 1):
                    p1, p2 = pts[i], pts[i+1]
                    # ì„ ë¶„ê³¼ ì›ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
                    dist = point_to_line_distance(circle_center, p1, p2)
                    if dist < radius:
                        return True
    return False

def point_to_line_distance(point, line_start, line_end):
    """ì ê³¼ ì„ ë¶„ ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°"""
    x0, y0 = point
    x1, y1 = line_start
    x2, y2 = line_end
    
    dx = x2 - x1
    dy = y2 - y1
    
    if dx == 0 and dy == 0:
        return calc_distance(point, line_start)
    
    t = ((x0 - x1) * dx + (y0 - y1) * dy) / (dx * dx + dy * dy)
    t = max(0, min(1, t))
    
    closest_point = (x1 + t * dx, y1 + t * dy)
    return calc_distance(point, closest_point)

def find_non_interfering_position(cp, initial_offset_y, rotation_step, radius, msp, exclude_entities):
    """ê°„ì„­ì´ ì—†ëŠ” ìœ„ì¹˜ë¥¼ ì°¾ê¸°"""
    # ì´ˆê¸° ìœ„ì¹˜
    initial_pos = (cp[0], cp[1] + initial_offset_y)
    
    # 0ë„ë¶€í„° 360ë„ê¹Œì§€ rotation_step ê°„ê²©ìœ¼ë¡œ ì²´í¬
    for angle in range(0, 360, rotation_step):
        test_pos = rotate_point(initial_pos, cp, angle)
        
        if not check_circle_interference(test_pos, radius, msp, exclude_entities):
            return test_pos
    
    # ê°„ì„­ì´ ì—†ëŠ” ìœ„ì¹˜ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° ì´ˆê¸° ìœ„ì¹˜ ë°˜í™˜
    return initial_pos

def main():
    root = tk.Tk(); root.withdraw()
    files = filedialog.askopenfilenames(title="DXF íŒŒì¼ ì„ íƒ", filetypes=[("DXF Files", "*.dxf")])
    if not files:
        print("ì„ íƒëœ íŒŒì¼ ì—†ìŒ"); return

    for filepath in files:
        print(f"\nğŸ”§ ì²˜ë¦¬ì¤‘: {filepath}")
        try:
            doc = ezdxf.readfile(filepath)
            msp = doc.modelspace()
            
            # NODE ë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ìƒì„±
            if 'NODE' not in doc.layers:
                doc.layers.new('NODE')

            s1_list = []
            for e in msp:
                if is_valid_s1(e):
                    pts = extract_points(e)
                    if pts and len(pts) == 2:
                        s1_list.append({'ent': e, 'pts': pts})

            croschk = []
            for rec1 in s1_list:
                for rec2 in s1_list:
                    if rec1 is rec2:
                        continue
                    if not hasattr(rec1['ent'], 'dxf') or not hasattr(rec2['ent'], 'dxf'):
                        continue
                    
                    # ë‘ S1ì˜ ê¸¸ì´ ì°¨ì´ê°€ 0.2mm ì´ë‚´ì—¬ì•¼ í•¨
                    len1 = polyline_length(rec1['pts'])
                    len2 = polyline_length(rec2['pts'])
                    if abs(len1 - len2) > 0.2:
                        continue
                    
                    # ê° ì  ê°„ì˜ ê±°ë¦¬ ê³„ì‚°
                    all_distances = [calc_distance(a, b) for a in rec1['pts'] for b in rec2['pts']]
                    dmin = min(all_distances)
                    dmax = max(all_distances)
                    
                    # ì  ê°„ ê±°ë¦¬ëŠ” 3.5~7mm ì‚¬ì´ì—¬ì•¼ í•¨
                    if not (3.5 <= dmin <= 7.0 and 3.5 <= dmax <= 7.0):
                        continue
                    
                    # ë‘ í´ë¦¬ë¼ì¸ì˜ ì ë“¤ì´ 0.2mm ë²”ìœ„ì—ì„œ ê°™ì€ ìœ„ì¹˜ì— ìˆìœ¼ë©´ PASS (í‰í–‰í•´ì•¼ í•˜ê³  ë§Œë‚˜ë©´ ì•ˆë¨)
                    if any(calc_distance(p1, p2) <= 0.2 for p1 in rec1['pts'] for p2 in rec2['pts']):
                        continue

                    sp1, ep1 = rec1['pts']
                    sp2, ep2 = rec2['pts']
                    print(f"S1-S2 ê²€ì¦: ê¸¸ì´ì°¨={abs(len1-len2):.3f}mm")
                    print(f"  ê±°ë¦¬: sp1-sp2={calc_distance(sp1, sp2):.2f} "
                          f"sp1-ep2={calc_distance(sp1, ep2):.2f} "
                          f"ep1-sp2={calc_distance(ep1, sp2):.2f} "
                          f"ep1-ep2={calc_distance(ep1, ep2):.2f}")

                    rec1['ent'].dxf.color = CYAN
                    rec2['ent'].dxf.color = CYAN
                    center1 = midpoint(rec1['pts'])

                    A1 = next(({'ent':e,'pts':extract_points(e)} for e in msp if len(extract_points(e))==3 and any(calc_distance(p,center1)<=1 for p in extract_points(e))), None)
                    if not A1: continue
                    mid_p2 = A1['pts'][1]
                    A2 = next(({'ent':e,'pts':extract_points(e)} for e in msp if e is not A1['ent'] and len(extract_points(e)) in (2,3) and any(calc_distance(p,mid_p2)<=0.3 for p in extract_points(e))), None)
                    if not A2:
                        # A2ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° - ì•„ë¬´ê²ƒë„ ì‚­ì œí•˜ì§€ ì•ŠìŒ
                        continue
                    A2['ent'].dxf.color = RED
                    farpt = max(A2['pts'], key=lambda p: calc_distance(p, center1))
                    PS = next(({'ent':e,'pts':extract_points(e)} for e in msp if is_ps_candidate(extract_points(e)) and any(calc_distance(p,farpt)<=7 for p in extract_points(e))), None)
                    if not PS:
                        # PSë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° - ì•„ë¬´ê²ƒë„ ì‚­ì œí•˜ì§€ ì•ŠìŒ
                        continue
                    PS['ent'].dxf.color = CYAN
                    ps_point = min(PS['pts'], key=lambda p: calc_distance(p, center1))
                    line = msp.add_line(center1, ps_point, dxfattribs={'color': CYAN})
                    croschk.append({'s1': rec1['ent'], 's2': rec2['ent'], 'line': line, 'ps': ps_point})
                    
                    # ì „ì²´ ì‘ì—…ì´ ì„±ê³µí•œ ê²½ìš°ì—ë§Œ A1, A2 ì‚­ì œ
                    # A1 ì‚­ì œ ì‹œ ARROW ë ˆì´ì–´ì˜ 1mm ì´í•˜ LINEë„ í•¨ê»˜ ì‚­ì œ
                    arrow_lines = find_arrow_lines(msp, A1['pts'])
                    for arrow_line in arrow_lines:
                        msp.delete_entity(arrow_line)
                        print(f"  ARROW ë ˆì´ì–´ LINE ì‚­ì œë¨ (ê¸¸ì´: {polyline_length(extract_points(arrow_line)):.3f}mm)")
                    
                    msp.delete_entity(A1['ent'])
                    msp.delete_entity(A2['ent'])
                    break

            supptag = []
            created_circles = []  # ìƒì„±ëœ ì›ë“¤ì„ ì¶”ì 
            for rec1 in list(s1_list):
                for rec2 in list(s1_list):
                    if rec1 is rec2: continue
                    if not hasattr(rec1['ent'], 'dxf') or not hasattr(rec2['ent'], 'dxf'):
                        continue
                    
                    # ë‘ S1ì˜ ê¸¸ì´ ì°¨ì´ê°€ 0.2mm ì´ë‚´ì—¬ì•¼ í•¨
                    len1 = polyline_length(rec1['pts'])
                    len2 = polyline_length(rec2['pts'])
                    if abs(len1 - len2) > 0.2:
                        continue
                    
                    # ê° ì  ê°„ì˜ ê±°ë¦¬ ê³„ì‚°
                    all_distances = [calc_distance(a, b) for a in rec1['pts'] for b in rec2['pts']]
                    dmin = min(all_distances)
                    dmax = max(all_distances)
                    
                    # ì  ê°„ ê±°ë¦¬ëŠ” 3.5~7mm ì‚¬ì´ì—¬ì•¼ í•¨
                    if not (3.5 <= dmin <= 7.0 and 3.5 <= dmax <= 7.0):
                        continue
                    
                    # ë‘ í´ë¦¬ë¼ì¸ì˜ ì ë“¤ì´ 0.2mm ë²”ìœ„ì—ì„œ ê°™ì€ ìœ„ì¹˜ì— ìˆìœ¼ë©´ PASS
                    if any(calc_distance(p1, p2) <= 0.2 for p1 in rec1['pts'] for p2 in rec2['pts']):
                        continue
                    pts1, pts2 = rec1['pts'], rec2['pts']
                    center_sl1 = midpoint([midpoint(pts1), midpoint(pts2)])
                    
                    # CP ì› ê·¸ë¦¬ê¸°
                    cp_circle = msp.add_circle(center=center_sl1, radius=HALF_SL1, dxfattribs={'color': CYAN})
                    created_circles.append(cp_circle)
                    
                    # íŒŒì´í”„ ë°©í–¥ ê³„ì‚° ë° ì§êµì„  ìƒì„±
                    pipe_angle = get_pipe_angle(pts1, pts2)
                    orthogonal_lines = create_iso_orthogonal_lines(center_sl1, pipe_angle, LINE_LENGTH, msp)
                    
                    # NODENO ì› ìœ„ì¹˜ ê²°ì •
                    nodeno_pos = find_non_interfering_position(
                        center_sl1, NODENO_OFFSET_Y, ROTATION_ANGLE, 
                        NODENO_RADIUS, msp, [cp_circle] + orthogonal_lines
                    )
                    
                    # NODENO ì› ê·¸ë¦¬ê¸°
                    nodeno_circle = msp.add_circle(
                        center=nodeno_pos, 
                        radius=NODENO_RADIUS, 
                        dxfattribs={'color': MAGENTA, 'layer': 'NODE'}
                    )
                    
                    # í…ìŠ¤íŠ¸ '0' ì¶”ê°€
                    text = msp.add_text(
                        '0',
                        dxfattribs={
                            'height': TEXT_HEIGHT,
                            'color': YELLOW,
                            'layer': 'NODE',
                            'insert': nodeno_pos,
                            'halign': 4,  # CENTER
                            'valign': 2   # MIDDLE
                        }
                    )
                    
                    # CPì™€ NODENO ì¤‘ì‹¬ì„ ì‡ëŠ” ì„ 
                    msp.add_line(
                        center_sl1, 
                        nodeno_pos, 
                        dxfattribs={'color': WHITE, 'layer': 'NODE'}
                    )
                    
                    msp.delete_entity(rec1['ent']); msp.delete_entity(rec2['ent'])
                    supptag.append({'s1': rec1['ent'], 's2': rec2['ent'], 'center': center_sl1})
                    break

            for rec in croschk:
                match = next((x for x in supptag if x['s1']==rec['s1'] and x['s2']==rec['s2']), None)
                if not match: continue
                ln = rec['line']
                ln.dxf.start = rec['ps']
                ln.dxf.end = (*match['center'], 0)
                msp.delete_entity(rec['s1']); msp.delete_entity(rec['s2'])

            # ===== ì¶”ê°€ëœ ì½”ë“œ: PS-ì› ì¤‘ì‹¬ ì—°ê²°ì„  ì¬í™•ì¸ ë° ì¡°ì • =====
            print("\nğŸ“ PS-ì› ì¤‘ì‹¬ ì—°ê²°ì„  ì¬í™•ì¸ ì‹œì‘...")
            
            # ëª¨ë“  ì›(ë°˜ì§€ë¦„ 0.7mm) ì°¾ê¸°
            circles = []
            for e in msp:
                if e.dxftype() == 'CIRCLE' and abs(e.dxf.radius - HALF_SL1) < 0.01:
                    circles.append({'ent': e, 'center': (e.dxf.center.x, e.dxf.center.y)})
            
            # ëª¨ë“  7ì  í´ë¦¬ë¼ì¸(PS) ì°¾ê¸°
            ps_entities = []
            for e in msp:
                pts = extract_points(e)
                if is_ps_candidate(pts):
                    ps_entities.append({'ent': e, 'pts': pts})
            
            # ëª¨ë“  CYAN ìƒ‰ìƒì˜ LINE ê²€ì‚¬
            adjustment_count = 0
            for e in msp:
                if e.dxftype() == 'LINE' and hasattr(e.dxf, 'color') and e.dxf.color == CYAN:
                    line_start = (e.dxf.start.x, e.dxf.start.y)
                    line_end = (e.dxf.end.x, e.dxf.end.y)
                    
                    # ì´ ì„ ì´ PSì™€ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
                    connected_to_ps = False
                    for ps in ps_entities:
                        for pt in ps['pts']:
                            if calc_distance(line_start, pt) < 0.1 or calc_distance(line_end, pt) < 0.1:
                                connected_to_ps = True
                                break
                        if connected_to_ps:
                            break
                    
                    if connected_to_ps:
                        # ê°€ì¥ ê°€ê¹Œìš´ ì› ì°¾ê¸°
                        closest_circle = None
                        min_dist = float('inf')
                        
                        for circle in circles:
                            dist_start = calc_distance(line_start, circle['center'])
                            dist_end = calc_distance(line_end, circle['center'])
                            
                            if dist_start < min_dist:
                                min_dist = dist_start
                                closest_circle = circle
                                is_start_closer = True
                            if dist_end < min_dist:
                                min_dist = dist_end
                                closest_circle = circle
                                is_start_closer = False
                        
                        # ì›ì— ê°€ê¹Œìš´ ëì ì„ ì›ì˜ ì¤‘ì‹¬ìœ¼ë¡œ ì¡°ì •
                        if closest_circle and min_dist < 5.0:  # 5mm ì´ë‚´ì— ì›ì´ ìˆìœ¼ë©´
                            if is_start_closer:
                                old_point = line_start
                                e.dxf.start = (*closest_circle['center'], 0)
                            else:
                                old_point = line_end
                                e.dxf.end = (*closest_circle['center'], 0)
                            
                            adjustment_count += 1
                            print(f"  ì„  ì¡°ì • #{adjustment_count}: "
                                  f"({old_point[0]:.3f}, {old_point[1]:.3f}) â†’ "
                                  f"({closest_circle['center'][0]:.3f}, {closest_circle['center'][1]:.3f})")
            
            print(f"âœ… PS-ì› ì¤‘ì‹¬ ì—°ê²°ì„  ì¬ì¡°ì • ì™„ë£Œ: {adjustment_count}ê°œ ì„  ì¡°ì •ë¨")
            # ===== ì¶”ê°€ ì½”ë“œ ë =====

            out_path = os.path.splitext(filepath)[0] + '_SUPP.dxf'
            doc.saveas(out_path)
            print(f"âœ… ì €ì¥ë¨: {out_path}")

        except Exception as e:
            print(f"âŒ ì˜¤ë¥˜ ë°œìƒ @ {filepath}")
            traceback.print_exc(file=sys.stdout)

    print("ğŸ‰ ì „ì²´ ì‘ì—… ì™„ë£Œ")

if __name__ == '__main__':
    main()