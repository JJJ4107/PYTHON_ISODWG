import ezdxf
import tkinter as tk
from tkinter import filedialog
import math
import os
import traceback
import sys

CYAN = 4
RED = 1
YELLOW = 2
BLUE = 5
MAGENTA = 6
WHITE = 7
SL1_LENGTH = 3.5  # S1 í‰ê·  ê¸¸ì´ (3~4mmì˜ ì¤‘ê°„ê°’)
HALF_SL1 = 0.25  # ì›ì˜ ë°˜ì§€ë¦„ì„ 0.25mmë¡œ ë³€ê²½ (ì§ê²½ 0.5mm)
LINE_LENGTH = 7.0  # ì„ ì˜ ê¸¸ì´ 7mmë¡œ ë³€ê²½
LINE_WIDTH = 0.6  # ì„  ë‘ê»˜ 0.6
NODENO_RADIUS = 5.25  # NODENO ì›ì˜ ë°˜ì§€ë¦„ 10.5mm/2 = 5.25mm
NODENO_OFFSET_Y = 12.25  # Yë°©í–¥ ì´ë™ ê±°ë¦¬ 12.25mmë¡œ ë³€ê²½
ROTATION_ANGLE = 30  # íšŒì „ ê°ë„ (ë„)
TEXT_HEIGHT = 3.0  # í…ìŠ¤íŠ¸ ë†’ì´ 3mm
TEXT_VALUE = '0000'  # í…ìŠ¤íŠ¸ ê°’

def calc_distance(p1, p2):
    return math.hypot(p1[0] - p2[0], p1[1] - p2[1])

def extract_points(ent):
    try:
        if not ent or not hasattr(ent, 'dxf') or ent.dxf is None:
            return []
        t = ent.dxftype()
        if t == 'LINE':
            return [(ent.dxf.start.x, ent.dxf.start.y), (ent.dxf.end.x, ent.dxf.end.y)]
        if t == 'LWPOLYLINE':
            return [tuple(pt[:2]) for pt in ent.get_points()]
        if t == 'POLYLINE':
            return [(v.dxf.location.x, v.dxf.location.y) for v in ent.vertices]
    except:
        pass
    return []

def has_curve(ent):
    t = ent.dxftype()
    if t == 'LWPOLYLINE':
        for pt in ent.get_points():
            if len(pt) > 4 and abs(pt[4]) > 1e-3:
                return True
    if t == 'POLYLINE':
        for v in ent.vertices:
            if hasattr(v.dxf, 'bulge') and abs(v.dxf.bulge) > 1e-3:
                return True
    return False

def polyline_length(pts):
    return sum(calc_distance(pts[i], pts[i+1]) for i in range(len(pts)-1))

def midpoint(pts):
    return (sum(p[0] for p in pts)/len(pts), sum(p[1] for p in pts)/len(pts))

def is_valid_s1(ent):
    if has_curve(ent): return False
    pts = extract_points(ent)
    if len(pts) != 2: return False
    L = polyline_length(pts)
    return 3.0 <= L <= 4.0  # S1 ê¸¸ì´ ì¡°ê±´ ë³€ê²½: 3.0~4.0mm

def point_at_distance(origin, target, dist):
    dx, dy = target[0] - origin[0], target[1] - origin[1]
    length = math.hypot(dx, dy)
    if length == 0:
        return origin
    ux, uy = dx / length, dy / length
    return (origin[0] + ux * dist, origin[1] + uy * dist)

def find_arrow_lines(msp, a1_points):
    """A1ì˜ ëì ì— ì ‘í•˜ëŠ” ARROW ë ˆì´ì–´ì˜ 1mm ì´í•˜ LINE ì°¾ê¸°"""
    arrow_lines = []
    for e in msp:
        if e.dxftype() == 'LINE' and e.dxf.layer == 'ARROW':
            line_pts = extract_points(e)
            if len(line_pts) == 2:
                line_length = calc_distance(line_pts[0], line_pts[1])
                if line_length <= 1.0:  # 1mm ì´í•˜
                    # A1ì˜ ê° ëì ê³¼ LINEì˜ ëì  ê°„ ê±°ë¦¬ í™•ì¸
                    for a1_pt in [a1_points[0], a1_points[-1]]:  # A1ì˜ ì²«ì ê³¼ ëì 
                        for line_pt in line_pts:
                            if calc_distance(a1_pt, line_pt) <= 0.1:  # 0.1mm ì´ë‚´ë©´ ì ‘ì´‰
                                arrow_lines.append(e)
                                break
    return arrow_lines

def get_pipe_angle(pts1, pts2):
    """ë‘ S1 í´ë¦¬ë¼ì¸ì—ì„œ íŒŒì´í”„ì˜ ì£¼ ë°©í–¥ ê°ë„ë¥¼ ê³„ì‚°"""
    # ê° í´ë¦¬ë¼ì¸ì˜ ë°©í–¥ ë²¡í„° ê³„ì‚°
    dir1 = (pts1[1][0] - pts1[0][0], pts1[1][1] - pts1[0][1])
    dir2 = (pts2[1][0] - pts2[0][0], pts2[1][1] - pts2[0][1])
    
    # ë²¡í„°ì˜ í¬ê¸° ê³„ì‚°
    mag1 = math.hypot(dir1[0], dir1[1])
    mag2 = math.hypot(dir2[0], dir2[1])
    
    # ì •ê·œí™”ëœ ë²¡í„°
    if mag1 > 0:
        norm1 = (dir1[0]/mag1, dir1[1]/mag1)
    else:
        norm1 = (0, 0)
        
    if mag2 > 0:
        norm2 = (dir2[0]/mag2, dir2[1]/mag2)
    else:
        norm2 = (0, 0)
    
    # ë‘ ë²¡í„°ì˜ ë‚´ì ì„ ê³„ì‚°í•˜ì—¬ ê°™ì€ ë°©í–¥ì¸ì§€ í™•ì¸
    dot_product = norm1[0]*norm2[0] + norm1[1]*norm2[1]
    
    # ë°˜ëŒ€ ë°©í–¥ì´ë©´ dir2ë¥¼ ë°˜ì „
    if dot_product < -0.5:  # ëŒ€ëµ 120ë„ ì´ìƒ ì°¨ì´ë‚˜ë©´ ë°˜ëŒ€ ë°©í–¥
        dir2 = (-dir2[0], -dir2[1])
    
    # í‰ê·  ë°©í–¥ ê³„ì‚°
    avg_dir = ((dir1[0] + dir2[0])/2, (dir1[1] + dir2[1])/2)
    
    # í‰ê·  ë²¡í„°ê°€ ì˜ë²¡í„°ì¸ ê²½ìš° ì²« ë²ˆì§¸ ë²¡í„° ì‚¬ìš©
    if abs(avg_dir[0]) < 0.01 and abs(avg_dir[1]) < 0.01:
        avg_dir = dir1
    
    # ê°ë„ ê³„ì‚° (ë¼ë””ì•ˆ)
    angle = math.atan2(avg_dir[1], avg_dir[0])
    
    return angle

def create_triangle_arrow(center, direction_angle, side_length, base_width, msp, color=CYAN, layer='SUPP', scale=1.0):
    """ì´ë“±ë³€ ì‚¼ê°í˜• í™”ì‚´í‘œë¥¼ ìƒì„±
    side_length: ì–‘ìª½ ë³€ì˜ ê¸¸ì´ (2.8mm)
    base_width: ë°‘ë³€ì˜ ê¸¸ì´ (1mm)
    scale: ì¤‘ì‹¬ì  ê¸°ì¤€ ìŠ¤ì¼€ì¼ (0~1)
    """
    # ë°©í–¥ ê°ë„ë¥¼ ë¼ë””ì•ˆìœ¼ë¡œ ë³€í™˜
    angle_rad = math.radians(direction_angle)
    
    # ì´ë“±ë³€ ì‚¼ê°í˜•ì˜ ë†’ì´ ê³„ì‚°
    # h = sqrt(side_length^2 - (base_width/2)^2)
    height = math.sqrt(side_length**2 - (base_width/2)**2)
    
    # ì‚¼ê°í˜•ì˜ ë¬´ê²Œì¤‘ì‹¬ ê³„ì‚° (ê¼­ì§€ì ì—ì„œ ë†’ì´ì˜ 2/3 ì§€ì )
    centroid_distance = height * 2/3
    centroid_x = center[0] + centroid_distance * math.cos(angle_rad)
    centroid_y = center[1] + centroid_distance * math.sin(angle_rad)
    centroid = (centroid_x, centroid_y)
    
    # ì‚¼ê°í˜•ì˜ ì„¸ ê¼­ì§€ì  ê³„ì‚°
    # ì²« ë²ˆì§¸ ì : center (ê¼­ì§€ì )
    p1 = center
    
    # ë‘ ë²ˆì§¸ ì : ì™¼ìª½ ë°‘ë³€
    p2_x = center[0] - base_width/2 * math.cos(angle_rad + math.pi/2) + height * math.cos(angle_rad)
    p2_y = center[1] - base_width/2 * math.sin(angle_rad + math.pi/2) + height * math.sin(angle_rad)
    p2 = (p2_x, p2_y)
    
    # ì„¸ ë²ˆì§¸ ì : ì˜¤ë¥¸ìª½ ë°‘ë³€
    p3_x = center[0] + base_width/2 * math.cos(angle_rad + math.pi/2) + height * math.cos(angle_rad)
    p3_y = center[1] + base_width/2 * math.sin(angle_rad + math.pi/2) + height * math.sin(angle_rad)
    p3 = (p3_x, p3_y)
    
    # ìŠ¤ì¼€ì¼ ì ìš© (ë¬´ê²Œì¤‘ì‹¬ ê¸°ì¤€)
    if scale < 1.0:
        p1 = (centroid[0] + (p1[0] - centroid[0]) * scale,
              centroid[1] + (p1[1] - centroid[1]) * scale)
        p2 = (centroid[0] + (p2[0] - centroid[0]) * scale,
              centroid[1] + (p2[1] - centroid[1]) * scale)
        p3 = (centroid[0] + (p3[0] - centroid[0]) * scale,
              centroid[1] + (p3[1] - centroid[1]) * scale)
    
    # ì‚¼ê°í˜• ê·¸ë¦¬ê¸° (ë‹«íŒ í´ë¦¬ë¼ì¸)
    triangle_points = [p1, p2, p3, p1]
    
    try:
        msp.add_lwpolyline(
            triangle_points,
            dxfattribs={'color': color, 'layer': layer}
        )
    except:
        # í´ë¦¬ë¼ì¸ì´ ì‹¤íŒ¨í•˜ë©´ ê°œë³„ ì„ ìœ¼ë¡œ ê·¸ë¦¬ê¸°
        msp.add_line(p1, p2, dxfattribs={'color': color, 'layer': layer})
        msp.add_line(p2, p3, dxfattribs={'color': color, 'layer': layer})
        msp.add_line(p3, p1, dxfattribs={'color': color, 'layer': layer})

def create_iso_orthogonal_lines(center, pipe_angle, length, msp):
    """ISO ë„ë©´ ê¸°ì¤€ìœ¼ë¡œ íŒŒì´í”„ì— ì§êµí•˜ëŠ” 4ê°œ ë°©í–¥ìœ¼ë¡œ ì„ ì„ ìƒì„±"""
    lines = []
    line_angles = []  # ìƒì„±ëœ ì„ ì˜ ê°ë„ë¥¼ ì €ì¥
    
    # íŒŒì´í”„ ê°ë„ë¥¼ ë„ ë‹¨ìœ„ë¡œ ë³€í™˜
    pipe_angle_deg = math.degrees(pipe_angle) % 360
    
    # íŒŒì´í”„ ê°ë„ë¥¼ 30ë„ ë‹¨ìœ„ë¡œ ë°˜ì˜¬ë¦¼í•˜ì—¬ í‘œì¤€í™”
    normalized_angle = round(pipe_angle_deg / 30) * 30 % 360
    
    # ìˆ˜ì§ íŒŒì´í”„ì˜ ê²½ìš° ì•½ê°„ì˜ ì˜¤ì°¨ í—ˆìš© (Â±5ë„)
    if 85 <= pipe_angle_deg <= 95 or 265 <= pipe_angle_deg <= 275:
        normalized_angle = 90 if pipe_angle_deg < 180 else 270
    
    # ISO ë„ë©´ í‘œì¤€ì— ë”°ë¥¸ ì§êµì„  ê°ë„ ê²°ì •
    if normalized_angle == 0 or normalized_angle == 180:  # ìˆ˜í‰ íŒŒì´í”„
        angles = [90, 270, 30, 210]
        
    elif normalized_angle == 90 or normalized_angle == 270:  # ìˆ˜ì§ íŒŒì´í”„
        angles = [30, 150, 210, 330]
        
    elif normalized_angle == 30 or normalized_angle == 210:  # 30ë„ ê²½ì‚¬ íŒŒì´í”„
        angles = [90, 270, 150, 330]
        
    elif normalized_angle == 60 or normalized_angle == 240:  # 60ë„ ê²½ì‚¬ íŒŒì´í”„
        angles = [90, 270, 180, 0]
        
    elif normalized_angle == 120 or normalized_angle == 300:  # 120ë„ ê²½ì‚¬ íŒŒì´í”„
        angles = [90, 270, 60, 240]
        
    elif normalized_angle == 150 or normalized_angle == 330:  # 150ë„ ê²½ì‚¬ íŒŒì´í”„
        angles = [90, 270, 30, 210]
        
    else:
        # ê¸°íƒ€ ê°ë„: íŒŒì´í”„ì— ì§êµí•˜ëŠ” ë°©í–¥ + ISO í‘œì¤€ ê°ë„
        orth_angle = (pipe_angle_deg + 90) % 360
        orth_angle_normalized = round(orth_angle / 30) * 30
        
        angles = [
            orth_angle_normalized % 360,
            (orth_angle_normalized + 180) % 360,
            (orth_angle_normalized + 60) % 360,
            (orth_angle_normalized + 240) % 360
        ]
    
    # ê° ë°©í–¥ìœ¼ë¡œ ì„  ê·¸ë¦¬ê¸°
    for i, angle_deg in enumerate(angles[:4]):
        angle_rad = math.radians(angle_deg)
        
        # ì›ê³¼ì˜ êµì°¨ì  ê³„ì‚° (trimì„ ìœ„í•´)
        # cyan ì›ì˜ ë°˜ì§€ë¦„ì€ HALF_SL1 = 0.25mm
        trim_start_x = center[0] + HALF_SL1 * math.cos(angle_rad)
        trim_start_y = center[1] + HALF_SL1 * math.sin(angle_rad)
        trim_start = (trim_start_x, trim_start_y)
        
        end_point = (center[0] + length * math.cos(angle_rad),
                     center[1] + length * math.sin(angle_rad))
        
        # Trimëœ ì„  ê·¸ë¦¬ê¸° (ì› ë°–ì—ì„œë¶€í„°)
        line = msp.add_line(trim_start, end_point, 
                          dxfattribs={'color': CYAN, 'lineweight': 60, 'layer': 'SUPP'})
        lines.append(line)
        line_angles.append(angle_deg)  # ì„ ì˜ ê°ë„ ì €ì¥
        
        # ì‚¼ê°í˜• í™”ì‚´í‘œ 5ê°œ ê·¸ë¦¬ê¸° (ê°™ì€ ìœ„ì¹˜ì—ì„œ í¬ê¸°ë§Œ ë‹¤ë¥´ê²Œ)
        arrow_side_length = 4.0  # ì–‘ìª½ ë³€ì˜ ê¸¸ì´ mm
        arrow_base_width = 1.4   # ë°‘ë³€ì˜ ê¸¸ì´ mm
        
        for j in range(5):
            # ê° ì‚¼ê°í˜•ì€ 20%ì”© ì‘ì•„ì§
            scale = 1.0 - (j * 0.2)
            if scale <= 0:  # ìŠ¤ì¼€ì¼ì´ 0 ì´í•˜ê°€ ë˜ë©´ ì¤‘ë‹¨
                break
            
            # ëª¨ë“  ì‚¼ê°í˜•ì€ cyan ì› ì¤‘ì‹¬ì—ì„œ ì‹œì‘
            arrow_pos = center
            
            # ì‚¼ê°í˜• ê·¸ë¦¬ê¸° (ì¤‘ì‹¬ì  ê¸°ì¤€ ìŠ¤ì¼€ì¼ë§)
            create_triangle_arrow(arrow_pos, angle_deg, arrow_side_length, arrow_base_width, msp, scale=scale)
    
    return lines, line_angles  # ì„ ë“¤ê³¼ ê°ë„ë“¤ì„ í•¨ê»˜ ë°˜í™˜

def rotate_point(point, center, angle_deg):
    """ì ì„ ì¤‘ì‹¬ì  ê¸°ì¤€ìœ¼ë¡œ íšŒì „"""
    angle_rad = math.radians(angle_deg)
    cos_a = math.cos(angle_rad)
    sin_a = math.sin(angle_rad)
    
    dx = point[0] - center[0]
    dy = point[1] - center[1]
    
    new_x = center[0] + dx * cos_a - dy * sin_a
    new_y = center[1] + dx * sin_a + dy * cos_a
    
    return (new_x, new_y)

def find_best_orthogonal_position_for_special(cp, offset_distance, pipe_angle, msp, exclude_entities):
    """ELBO/TEEìš© íŠ¹ë³„í•œ NODE ìœ„ì¹˜ ê²°ì • - 30ë„ ë‹¨ìœ„ë¡œ ëª¨ë“  ê°ë„ë¥¼ ê²€ì‚¬í•˜ì—¬ ìµœì  ìœ„ì¹˜ ì°¾ê¸° (ìˆ˜ì§ ì œì™¸)"""
    pipe_angle_deg = math.degrees(pipe_angle) % 360
    
    # ëª¨ë“  ê°€ëŠ¥í•œ ê°ë„ (30ë„ ê°„ê²©) - ìˆ˜ì§(90ë„, 270ë„) ì œì™¸
    all_angles = [0, 30, 60, 120, 150, 180, 210, 240, 300, 330]
    
    print(f"      íŠ¹ìˆ˜ ë…¸ë“œ: íŒŒì´í”„ ê°ë„={pipe_angle_deg:.1f}Â°")
    print(f"      ìˆ˜ì§ ì œì™¸í•œ ëª¨ë“  ê°ë„ì—ì„œ ê°„ì„­ ì²´í¬ ì‹œì‘...")
    
    # ê° ê°€ëŠ¥í•œ ë°©í–¥ì—ì„œì˜ ê°„ì„­ ì²´í¬
    best_angle = None
    min_interference_count = float('inf')
    no_interference_angles = []  # ê°„ì„­ì´ ì—†ëŠ” ê°ë„ë“¤
    
    for angle in all_angles:
        angle_rad = math.radians(angle)
        test_pos = (cp[0] + offset_distance * math.cos(angle_rad),
                    cp[1] + offset_distance * math.sin(angle_rad))
        
        # ì´ ìœ„ì¹˜ì—ì„œì˜ ê°„ì„­ ê°œìˆ˜ ê³„ì‚°
        interference_count = 0
        for ent in msp:
            if ent in exclude_entities:
                continue
                
            ent_type = ent.dxftype()
            if ent_type == 'CIRCLE':
                # ë‹¤ë¥¸ ì›ê³¼ì˜ ê±°ë¦¬ ì²´í¬
                other_center = (ent.dxf.center.x, ent.dxf.center.y)
                other_radius = ent.dxf.radius
                dist = calc_distance(test_pos, other_center)
                if dist < (NODENO_RADIUS + other_radius + 1.0):  # 1mm ì—¬ìœ 
                    interference_count += 1
            elif ent_type in ['LINE', 'LWPOLYLINE', 'POLYLINE']:
                # ì„ ê³¼ì˜ ê±°ë¦¬ ì²´í¬
                pts = extract_points(ent)
                for i in range(len(pts) - 1):
                    dist = point_to_line_distance(test_pos, pts[i], pts[i+1])
                    if dist < NODENO_RADIUS + 1.0:  # 1mm ì—¬ìœ 
                        interference_count += 1
                        break
            elif ent_type == 'TEXT' or ent_type == 'MTEXT':
                # í…ìŠ¤íŠ¸ì™€ì˜ ê°„ì„­ë„ ì²´í¬
                if ent_type == 'TEXT':
                    text_pos = (ent.dxf.insert.x, ent.dxf.insert.y)
                else:
                    text_pos = (ent.dxf.insert.x, ent.dxf.insert.y)
                dist = calc_distance(test_pos, text_pos)
                if dist < NODENO_RADIUS + 2.0:  # í…ìŠ¤íŠ¸ì™€ 2mm ì—¬ìœ 
                    interference_count += 1
        
        print(f"      {angle}Â° ë°©í–¥: ê°„ì„­ {interference_count}ê°œ")
        
        # ê°„ì„­ì´ ì—†ëŠ” ê°ë„ ì €ì¥
        if interference_count == 0:
            no_interference_angles.append(angle)
        
        # ê°„ì„­ì´ ê°€ì¥ ì ì€ ë°©í–¥ ì„ íƒ
        if interference_count < min_interference_count:
            min_interference_count = interference_count
            best_angle = angle
    
    # ê°„ì„­ì´ ì—†ëŠ” ê°ë„ê°€ ìˆìœ¼ë©´ ê·¸ ì¤‘ ì²« ë²ˆì§¸ ì„ íƒ
    if no_interference_angles:
        best_angle = no_interference_angles[0]
        print(f"      â†’ ê°„ì„­ ì—†ëŠ” ê°ë„ ë°œê²¬: {no_interference_angles}")
        print(f"      â†’ ì„ íƒëœ ê°ë„: {best_angle}Â°")
    else:
        print(f"      â†’ ëª¨ë“  ê°ë„ì— ê°„ì„­ ìˆìŒ. ìµœì†Œ ê°„ì„­ ê°ë„: {best_angle}Â° (ê°„ì„­ {min_interference_count}ê°œ)")
    
    if best_angle is not None:
        angle_rad = math.radians(best_angle)
        best_pos = (cp[0] + offset_distance * math.cos(angle_rad),
                    cp[1] + offset_distance * math.sin(angle_rad))
        return best_pos
    
    # ê¸°ë³¸ê°’: 0ë„ ë°©í–¥
    angle_rad = math.radians(0)
    return (cp[0] + offset_distance * math.cos(angle_rad),
            cp[1] + offset_distance * math.sin(angle_rad))

def find_best_orthogonal_position(cp, offset_distance, pipe_angle, msp, exclude_entities, line_angles=None):
    """ì¼ë°˜ NODEìš© ì§êµì„  ë°©í–¥ ì¤‘ ê°„ì„­ì´ ê°€ì¥ ì ì€ ìœ„ì¹˜ ì°¾ê¸° - ìˆ˜ì§ ìœ„ì¹˜ ì œì™¸"""
    pipe_angle_deg = math.degrees(pipe_angle) % 360
    normalized_angle = round(pipe_angle_deg / 30) * 30 % 360
    
    # ìˆ˜ì§ íŒŒì´í”„ì˜ ê²½ìš° ì•½ê°„ì˜ ì˜¤ì°¨ í—ˆìš©
    if 85 <= pipe_angle_deg <= 95 or 265 <= pipe_angle_deg <= 275:
        normalized_angle = 90 if pipe_angle_deg < 180 else 270
    
    # íŒŒì´í”„ ê°ë„ì— ë”°ë¥¸ ì§êµì„  ë°©í–¥ ê²°ì •
    if normalized_angle == 0 or normalized_angle == 180:  # ìˆ˜í‰ íŒŒì´í”„
        orthogonal_angles = [90, 270, 30, 210]
    elif normalized_angle == 90 or normalized_angle == 270:  # ìˆ˜ì§ íŒŒì´í”„
        orthogonal_angles = [30, 150, 210, 330]
    elif normalized_angle == 30 or normalized_angle == 210:  # 30ë„ ê²½ì‚¬
        orthogonal_angles = [90, 270, 150, 330]
    elif normalized_angle == 60 or normalized_angle == 240:  # 60ë„ ê²½ì‚¬
        orthogonal_angles = [90, 270, 180, 0]
    elif normalized_angle == 120 or normalized_angle == 300:  # 120ë„ ê²½ì‚¬
        orthogonal_angles = [90, 270, 60, 240]
    elif normalized_angle == 150 or normalized_angle == 330:  # 150ë„ ê²½ì‚¬
        orthogonal_angles = [90, 270, 30, 210]
    else:
        # ê¸°íƒ€ ê°ë„: íŒŒì´í”„ì— ì§êµí•˜ëŠ” ë°©í–¥
        orth_angle = (pipe_angle_deg + 90) % 360
        orth_angle_normalized = round(orth_angle / 30) * 30
        orthogonal_angles = [
            orth_angle_normalized % 360,
            (orth_angle_normalized + 180) % 360,
            (orth_angle_normalized + 60) % 360,
            (orth_angle_normalized + 240) % 360
        ]
    
    # ìˆ˜ì§ ìœ„ì¹˜(90ë„, 270ë„) ì œì™¸
    non_vertical_angles = [angle for angle in orthogonal_angles if angle != 90 and angle != 270]
    
    # ìˆ˜ì§ì´ ì•„ë‹Œ ê°ë„ê°€ ì—†ìœ¼ë©´ (ëª¨ë‘ ìˆ˜ì§ì¸ ê²½ìš°) ë‹¤ë¥¸ ê°ë„ ì¶”ê°€
    if not non_vertical_angles:
        non_vertical_angles = [0, 30, 60, 120, 150, 180, 210, 240, 300, 330]
    
    print(f"      ê°€ëŠ¥í•œ NODE ìœ„ì¹˜ ê°ë„ (ìˆ˜ì§ ì œì™¸): {non_vertical_angles}")
    
    # ê° ì§êµì„  ë°©í–¥ì—ì„œì˜ ê°„ì„­ ì²´í¬
    best_angle = None
    min_interference_count = float('inf')
    
    for angle in non_vertical_angles:
        angle_rad = math.radians(angle)
        test_pos = (cp[0] + offset_distance * math.cos(angle_rad),
                    cp[1] + offset_distance * math.sin(angle_rad))
        
        # ì´ ìœ„ì¹˜ì—ì„œì˜ ê°„ì„­ ê°œìˆ˜ ê³„ì‚°
        interference_count = 0
        for ent in msp:
            if ent in exclude_entities:
                continue
                
            ent_type = ent.dxftype()
            if ent_type == 'CIRCLE':
                # ë‹¤ë¥¸ ì›ê³¼ì˜ ê±°ë¦¬ ì²´í¬
                other_center = (ent.dxf.center.x, ent.dxf.center.y)
                other_radius = ent.dxf.radius
                dist = calc_distance(test_pos, other_center)
                if dist < (NODENO_RADIUS + other_radius + 1.0):  # 1mm ì—¬ìœ 
                    interference_count += 1
            elif ent_type in ['LINE', 'LWPOLYLINE', 'POLYLINE']:
                # ì„ ê³¼ì˜ ê±°ë¦¬ ì²´í¬
                pts = extract_points(ent)
                for i in range(len(pts) - 1):
                    dist = point_to_line_distance(test_pos, pts[i], pts[i+1])
                    if dist < NODENO_RADIUS + 1.0:  # 1mm ì—¬ìœ 
                        interference_count += 1
                        break
        
        print(f"      {angle}Â° ë°©í–¥: ê°„ì„­ {interference_count}ê°œ")
        
        # ê°„ì„­ì´ ê°€ì¥ ì ì€ ë°©í–¥ ì„ íƒ
        if interference_count < min_interference_count:
            min_interference_count = interference_count
            best_angle = angle
    
    if best_angle is not None:
        angle_rad = math.radians(best_angle)
        best_pos = (cp[0] + offset_distance * math.cos(angle_rad),
                    cp[1] + offset_distance * math.sin(angle_rad))
        print(f"      â†’ ìµœì  ë°©í–¥: {best_angle}Â° (ê°„ì„­ {min_interference_count}ê°œ)")
        return best_pos, best_angle  # ì„ íƒëœ ê°ë„ë„ ë°˜í™˜
    
    # ê¸°ë³¸ê°’: ì²« ë²ˆì§¸ ë¹„ìˆ˜ì§ ê°ë„
    angle_rad = math.radians(non_vertical_angles[0])
    return (cp[0] + offset_distance * math.cos(angle_rad),
            cp[1] + offset_distance * math.sin(angle_rad)), non_vertical_angles[0]

def point_to_line_distance(point, line_start, line_end):
    """ì ê³¼ ì„ ë¶„ ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°"""
    x0, y0 = point
    x1, y1 = line_start
    x2, y2 = line_end
    
    dx = x2 - x1
    dy = y2 - y1
    
    if dx == 0 and dy == 0:
        return calc_distance(point, line_start)
    
    t = ((x0 - x1) * dx + (y0 - y1) * dy) / (dx * dx + dy * dy)
    t = max(0, min(1, t))
    
    closest_point = (x1 + t * dx, y1 + t * dy)
    return calc_distance(point, closest_point)

def find_connected_pipes(elbo_pts, msp):
    """ELBOì˜ ì–‘ ëì ì— ì—°ê²°ëœ PIPE ì°¾ê¸° - PIPE TEXTê°€ í¬í•¨ëœ ë ˆì´ì–´ ê²€ìƒ‰"""
    start_point = elbo_pts[0]
    end_point = elbo_pts[-1]
    
    start_pipe = None
    end_pipe = None
    
    # PIPE TEXTê°€ í¬í•¨ëœ ë ˆì´ì–´ì˜ ì—”í‹°í‹° ê²€ìƒ‰
    for e in msp:
        if hasattr(e.dxf, 'layer') and 'PIPE' in e.dxf.layer:
            pts = extract_points(e)
            if len(pts) >= 2:
                # ì‹œì‘ì ê³¼ ì—°ê²°ëœ íŒŒì´í”„ ì°¾ê¸°
                for pt in pts:
                    if calc_distance(pt, start_point) < 0.5:  # 0.5mm ì´ë‚´
                        start_pipe = {'entity': e, 'points': pts, 'connection': pt}
                        break
                
                # ëì ê³¼ ì—°ê²°ëœ íŒŒì´í”„ ì°¾ê¸°
                for pt in pts:
                    if calc_distance(pt, end_point) < 0.5:  # 0.5mm ì´ë‚´
                        end_pipe = {'entity': e, 'points': pts, 'connection': pt}
                        break
    
    return start_pipe, end_pipe

def find_line_intersection(p1, v1, p2, v2):
    """ë‘ ì§ì„ ì˜ êµì  ì°¾ê¸°
    p1, p2: ê° ì§ì„  ìœ„ì˜ ì 
    v1, v2: ê° ì§ì„ ì˜ ë°©í–¥ ë²¡í„°
    """
    # ì§ì„  ë°©ì •ì‹: P = P0 + t*V
    # êµì ì—ì„œ: P1 + t1*V1 = P2 + t2*V2
    
    det = v1[0]*v2[1] - v1[1]*v2[0]
    if abs(det) < 1e-10:  # í‰í–‰ì„ 
        return None
    
    dp = (p2[0] - p1[0], p2[1] - p1[1])
    t1 = (dp[0]*v2[1] - dp[1]*v2[0]) / det
    
    # êµì  ê³„ì‚°
    intersection = (p1[0] + t1*v1[0], p1[1] + t1*v1[1])
    return intersection

def find_elbow_vertices(msp):
    """ELBO ë ˆì´ì–´ì—ì„œ íŒŒì´í”„ ì—°ì¥ì„ ì˜ êµì (ë°”ê¹¥ìª½ ê¼­ì§€ì ) ì°¾ê¸°"""
    elbow_vertices = []
    elbo_count = 0
    
    for e in msp:
        if hasattr(e.dxf, 'layer') and e.dxf.layer == 'ELBO':
            elbo_count += 1
            pts = extract_points(e)
            print(f"    ELBO ì—”í‹°í‹° ë°œê²¬: {e.dxftype()}, ì  ê°œìˆ˜: {len(pts)}")
            
            if len(pts) >= 2:
                # ELBOì˜ ì–‘ ëì— ì—°ê²°ëœ PIPE ì°¾ê¸°
                start_pipe, end_pipe = find_connected_pipes(pts, msp)
                
                if start_pipe and end_pipe:
                    # ê° íŒŒì´í”„ì˜ ë°©í–¥ ë²¡í„° ê³„ì‚°
                    # ì‹œì‘ íŒŒì´í”„ì˜ ë°©í–¥ (ELBOì™€ ì—°ê²°ëœ ì ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥)
                    if calc_distance(start_pipe['points'][0], start_pipe['connection']) < 0.5:
                        v1 = (start_pipe['points'][1][0] - start_pipe['points'][0][0],
                              start_pipe['points'][1][1] - start_pipe['points'][0][1])
                    else:
                        v1 = (start_pipe['points'][-2][0] - start_pipe['points'][-1][0],
                              start_pipe['points'][-2][1] - start_pipe['points'][-1][1])
                    
                    # ë íŒŒì´í”„ì˜ ë°©í–¥
                    if calc_distance(end_pipe['points'][0], end_pipe['connection']) < 0.5:
                        v2 = (end_pipe['points'][1][0] - end_pipe['points'][0][0],
                              end_pipe['points'][1][1] - end_pipe['points'][0][1])
                    else:
                        v2 = (end_pipe['points'][-2][0] - end_pipe['points'][-1][0],
                              end_pipe['points'][-2][1] - end_pipe['points'][-1][1])
                    
                    # ë‘ íŒŒì´í”„ ì—°ì¥ì„ ì˜ êµì  ì°¾ê¸°
                    intersection = find_line_intersection(pts[0], v1, pts[-1], v2)
                    
                    if intersection:
                        elbow_vertices.append({
                            'point': intersection,
                            'angle': 90,
                            'entity': e,
                            'direction': (v1, v2)
                        })
                        print(f"      â†’ íŒŒì´í”„ ì—°ì¥ì„  êµì (ë°”ê¹¥ìª½): ({intersection[0]:.1f}, {intersection[1]:.1f})")
                    else:
                        # êµì ì„ ì°¾ì§€ ëª»í•œ ê²½ìš° ì¤‘ì  ì‚¬ìš©
                        mid_point = midpoint(pts)
                        elbow_vertices.append({
                            'point': mid_point,
                            'angle': 180,
                            'entity': e,
                            'direction': ((1, 0), (0, 1))
                        })
                        print(f"      â†’ êµì ì„ ì°¾ì§€ ëª»í•´ ì¤‘ì  ì‚¬ìš©")
                else:
                    # PIPEë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° ELBOì˜ ì–‘ ë ë°©í–¥ ë²¡í„°ë¡œ ì¶”ì •
                    if len(pts) >= 3:
                        # ì²« ë¶€ë¶„ì˜ ë°©í–¥
                        v1 = (pts[0][0] - pts[1][0], pts[0][1] - pts[1][1])
                        # ë ë¶€ë¶„ì˜ ë°©í–¥
                        v2 = (pts[-1][0] - pts[-2][0], pts[-1][1] - pts[-2][1])
                        
                        # êµì  ê³„ì‚°
                        intersection = find_line_intersection(pts[0], v1, pts[-1], v2)
                        
                        if intersection:
                            elbow_vertices.append({
                                'point': intersection,
                                'angle': 90,
                                'entity': e,
                                'direction': (v1, v2)
                            })
                            print(f"      â†’ ELBO ìì²´ ë°©í–¥ìœ¼ë¡œ êµì  ê³„ì‚°: ({intersection[0]:.1f}, {intersection[1]:.1f})")
                    else:
                        # 2ì ë§Œ ìˆëŠ” ê²½ìš° ì¤‘ì  ì‚¬ìš©
                        mid_point = midpoint(pts)
                        v1 = (pts[1][0] - pts[0][0], pts[1][1] - pts[0][1])
                        elbow_vertices.append({
                            'point': mid_point,
                            'angle': 180,
                            'entity': e,
                            'direction': (v1, v1)
                        })
                        print(f"      â†’ 2ì  LINEì˜ ì¤‘ì  ì‚¬ìš©")
    
    print(f"    ELBO ì—”í‹°í‹° ì´ {elbo_count}ê°œ, ê¼­ì§€ì  {len(elbow_vertices)}ê°œ ë°œê²¬")
    return elbow_vertices

def find_tee_junction_points(msp):
    """TEE TEXTê°€ í¬í•¨ëœ ë ˆì´ì–´ì—ì„œ 3ê°œ ì ì´ ë§Œë‚˜ëŠ” ì  ì°¾ê¸°"""
    tee_points = []
    tee_entities = []
    
    # TEE TEXTê°€ í¬í•¨ëœ ë ˆì´ì–´ì˜ ëª¨ë“  ì—”í‹°í‹° ìˆ˜ì§‘
    for e in msp:
        if hasattr(e.dxf, 'layer') and 'TEE' in e.dxf.layer:
            if e.dxftype() in ['LWPOLYLINE', 'POLYLINE']:
                pts = extract_points(e)
                if pts:
                    tee_entities.append({'entity': e, 'points': pts})
                    print(f"    TEE ì—”í‹°í‹° ë°œê²¬: ë ˆì´ì–´={e.dxf.layer}, ì  ê°œìˆ˜={len(pts)}")
    
    print(f"    TEE ì—”í‹°í‹° ì´ {len(tee_entities)}ê°œ ë°œê²¬")
    
    # ëª¨ë“  ì ë“¤ì„ ìˆ˜ì§‘í•˜ê³  ì¤‘ë³µ ì  ì°¾ê¸°
    point_count = {}
    point_entities = {}
    
    for item in tee_entities:
        for pt in item['points']:
            # ì ì„ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ í‚¤ë¡œ ì‚¬ìš© (0.1mm ì •ë°€ë„)
            key = f"{pt[0]:.1f},{pt[1]:.1f}"
            
            if key not in point_count:
                point_count[key] = 0
                point_entities[key] = []
            
            point_count[key] += 1
            point_entities[key].append(item['entity'])
    
    # 3ê°œ ì´ìƒì˜ ì„ ì´ ë§Œë‚˜ëŠ” ì  ì°¾ê¸°
    for key, count in point_count.items():
        if count >= 3:
            x, y = map(float, key.split(','))
            tee_points.append({
                'point': (x, y),
                'count': count,
                'entities': point_entities[key]
            })
            print(f"      3ë°©í–¥ ë¶„ê¸°ì  ë°œê²¬: ({x:.1f}, {y:.1f}) - {count}ê°œ ì—°ê²°")
    
    print(f"    TEE ë¶„ê¸°ì  ì´ {len(tee_points)}ê°œ ë°œê²¬")
    return tee_points

def add_text_to_node(msp, center, text_value, height, color, layer, doc=None):
    """NODEì— í…ìŠ¤íŠ¸ ì¶”ê°€ - (0,0)ì— ìƒì„± í›„ NODE ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™"""
    try:
        print(f"\n      === í…ìŠ¤íŠ¸ ì¶”ê°€ ì‹œì‘ ===")
        print(f"      ëª©í‘œ NODE ì¤‘ì‹¬: ({center[0]:.2f}, {center[1]:.2f})")
        
        # ARIAL ìŠ¤íƒ€ì¼ì´ ì—†ìœ¼ë©´ ìƒì„±
        if doc and "ARIAL" not in doc.styles:
            try:
                doc.styles.new("ARIAL", dxfattribs={"font": "arial.ttf"})
            except:
                pass
        
        # 1ë‹¨ê³„: (0, 0) ìœ„ì¹˜ì— TEXT ìƒì„±
        text = msp.add_text(
            text_value,
            dxfattribs={
                'height': 3.5,  # 3.5mm ë†’ì´
                'color': MAGENTA,  # MAGENTA ìƒ‰ìƒ
                'layer': layer,
                'insert': (0, 0, 0),  # (0, 0) ìœ„ì¹˜ì— ìƒì„±
                'halign': 4,  # CENTER
                'valign': 2,  # MIDDLE
                'style': 'ARIAL' if doc else 'Standard',
                'width': 0.85
            }
        )
        print(f"      [1ë‹¨ê³„] í…ìŠ¤íŠ¸ '0000' (0,0)ì— ìƒì„± ì™„ë£Œ")
        
        # 2ë‹¨ê³„: transformì„ ì‚¬ìš©í•˜ì—¬ ì´ë™
        try:
            from ezdxf.math import Matrix44
            # ì´ë™ ë³€í™˜ í–‰ë ¬ ìƒì„±
            transform = Matrix44.translate(center[0], center[1], 0)
            # í…ìŠ¤íŠ¸ì— ë³€í™˜ ì ìš©
            text.transform(transform)
            print(f"      [2ë‹¨ê³„] transformìœ¼ë¡œ ({center[0]:.2f}, {center[1]:.2f})ë¡œ ì´ë™ ì™„ë£Œ")
            
            # ì´ë™ í™•ì¸
            new_pos = text.dxf.insert
            if hasattr(new_pos, 'x'):
                print(f"      â†’ ì´ë™ í›„ ì‹¤ì œ ìœ„ì¹˜: ({new_pos.x:.2f}, {new_pos.y:.2f})")
            else:
                print(f"      â†’ ì´ë™ í›„ ì‹¤ì œ ìœ„ì¹˜: ({new_pos[0]:.2f}, {new_pos[1]:.2f})")
            
            return text
            
        except Exception as e:
            print(f"      â†’ transform ì‹¤íŒ¨: {e}")
            
            # transformì´ ì‹¤íŒ¨í•˜ë©´ ì‚­ì œ í›„ ì¬ìƒì„±
            print(f"      â†’ ì‚­ì œ í›„ ì¬ìƒì„± ì‹œë„")
            try:
                msp.delete_entity(text)
                print(f"      â†’ (0,0)ì˜ í…ìŠ¤íŠ¸ ì‚­ì œë¨")
            except:
                print(f"      â†’ ì‚­ì œ ì‹¤íŒ¨, ê·¸ë˜ë„ ê³„ì† ì§„í–‰")
            
            # NODE ì¤‘ì‹¬ì— ìƒˆë¡œ ìƒì„±
            new_text = msp.add_text(
                text_value,
                dxfattribs={
                    'height': 3.5,
                    'color': MAGENTA,
                    'layer': layer,
                    'insert': (center[0], center[1], 0),
                    'halign': 4,
                    'valign': 2,
                    'style': 'ARIAL' if doc else 'Standard',
                    'width': 0.85
                }
            )
            print(f"      [ì¬ìƒì„±] NODE ì¤‘ì‹¬ ({center[0]:.2f}, {center[1]:.2f})ì— í…ìŠ¤íŠ¸ ìƒì„± ì™„ë£Œ")
            return new_text
        
    except Exception as e:
        print(f"      âŒ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì‹¤íŒ¨: {e}")
        import traceback
        traceback.print_exc()
        
        # ìµœí›„ì˜ ì‹œë„: NODE ì¤‘ì‹¬ì— ì§ì ‘ ìƒì„±
        try:
            text = msp.add_text(
                text_value,
                dxfattribs={
                    'height': 3.5,
                    'color': MAGENTA,
                    'layer': layer,
                    'insert': (center[0], center[1], 0),
                    'halign': 4,
                    'valign': 2,
                    'style': 'Standard'
                }
            )
            print(f"      [ìµœì¢…] NODE ì¤‘ì‹¬ì— ì§ì ‘ ìƒì„±")
            return text
        except Exception as e2:
            print(f"      âŒ ìµœì¢… ìƒì„±ë„ ì‹¤íŒ¨: {e2}")
            return None

def process_special_nodes(msp, doc):
    """ELBOì™€ TEE TEXT ë ˆì´ì–´ì˜ íŠ¹ìˆ˜ ë…¸ë“œ ì²˜ë¦¬"""
    processed_count = 0
    texts_to_add = []  # í…ìŠ¤íŠ¸ ì¶”ê°€ë¥¼ ìœ„í•œ ë¦¬ìŠ¤íŠ¸
    
    # ELBO ì²˜ë¦¬
    # ELBO ë ˆì´ì–´ì˜ ëª¨ë“  ì—”í‹°í‹°ë¥¼ CYANìœ¼ë¡œ ë³€ê²½
    elbo_count = 0
    for e in msp:
        if hasattr(e.dxf, 'layer') and e.dxf.layer == 'ELBO':
            e.dxf.color = CYAN
            elbo_count += 1
    if elbo_count > 0:
        print(f"  ELBO ë ˆì´ì–´ {elbo_count}ê°œ ì—”í‹°í‹° ìƒ‰ìƒì„ CYANìœ¼ë¡œ ë³€ê²½")
    
    elbow_vertices = find_elbow_vertices(msp)
    for elbow in elbow_vertices:
        center_point = elbow['point']
        
        # íŒŒì´í”„ ë°©í–¥ ì¶”ì • (ì—˜ë³´ì˜ ë‘ ë°©í–¥ ë²¡í„°ì˜ í‰ê· )
        v1, v2 = elbow['direction']
        avg_dir = ((v1[0] + v2[0])/2, (v1[1] + v2[1])/2)
        pipe_angle = math.atan2(avg_dir[1], avg_dir[0])
        
        # NODENO ì› ìœ„ì¹˜ ê²°ì • (30ë„ ë‹¨ìœ„ë¡œ íšŒì „í•˜ë©° ê°„ì„­ ì²´í¬)
        nodeno_pos = find_best_orthogonal_position_for_special(
            center_point, NODENO_OFFSET_Y, pipe_angle, msp, []
        )
        
        # NODENO ì› ê·¸ë¦¬ê¸°
        nodeno_circle = msp.add_circle(
            center=nodeno_pos, 
            radius=NODENO_RADIUS, 
            dxfattribs={'color': MAGENTA, 'layer': 'NODE'}
        )
        
        # center_pointì™€ NODENO ì¤‘ì‹¬ì„ ì‡ëŠ” ì„  (NODE ì›ì—ì„œ trim)
        dx = nodeno_pos[0] - center_point[0]
        dy = nodeno_pos[1] - center_point[1]
        distance = math.hypot(dx, dy)
        
        if distance > 0:
            ux = dx / distance
            uy = dy / distance
            trim_end_x = nodeno_pos[0] - ux * NODENO_RADIUS
            trim_end_y = nodeno_pos[1] - uy * NODENO_RADIUS
            
            msp.add_line(
                center_point, 
                (trim_end_x, trim_end_y), 
                dxfattribs={'color': WHITE, 'layer': 'NODE'}
            )
        
        # í…ìŠ¤íŠ¸ ì¶”ê°€ë¥¼ ìœ„í•´ ì €ì¥
        texts_to_add.append(nodeno_pos)
        
        processed_count += 1
        print(f"  ELBO ë…¸ë“œ ì²˜ë¦¬: ({center_point[0]:.2f}, {center_point[1]:.2f})")
    
    # TEE TEXT ì²˜ë¦¬
    tee_points = find_tee_junction_points(msp)
    
    # TEEê°€ í¬í•¨ëœ ëª¨ë“  ì—”í‹°í‹°ì˜ ìƒ‰ìƒì„ CYANìœ¼ë¡œ ë³€ê²½
    tee_layer_count = 0
    for e in msp:
        if hasattr(e.dxf, 'layer') and 'TEE' in e.dxf.layer:
            e.dxf.color = CYAN
            tee_layer_count += 1
    if tee_layer_count > 0:
        print(f"  TEE ë ˆì´ì–´ {tee_layer_count}ê°œ ì—”í‹°í‹° ìƒ‰ìƒì„ CYANìœ¼ë¡œ ë³€ê²½")
    
    for tee in tee_points:
        center_point = tee['point']
        
        # TEEì˜ ê²½ìš° ì—°ê²°ëœ íŒŒì´í”„ ë°©í–¥ì„ ì¶”ì •
        # 3ê°œ ì´ìƒì˜ ì„ ì´ ë§Œë‚˜ë¯€ë¡œ ê°€ì¥ ê¸´ ë‘ ì„ ì˜ ë°©í–¥ í‰ê·  ì‚¬ìš©
        pipe_angle = 0  # ê¸°ë³¸ê°’
        
        # ì—°ê²°ëœ ì—”í‹°í‹°ë“¤ì—ì„œ ë°©í–¥ ì¶”ì • ì‹œë„
        if tee['entities']:
            directions = []
            for ent in tee['entities'][:2]:  # ì²˜ìŒ 2ê°œë§Œ ì‚¬ìš©
                pts = extract_points(ent)
                if len(pts) >= 2:
                    # ì¤‘ì‹¬ì ì— ê°€ì¥ ê°€ê¹Œìš´ ë‘ ì ì„ ì°¾ì•„ ë°©í–¥ ê³„ì‚°
                    for i in range(len(pts)-1):
                        if calc_distance(pts[i], center_point) < 1.0:
                            dir_vec = (pts[i+1][0] - pts[i][0], pts[i+1][1] - pts[i][1])
                            directions.append(dir_vec)
                            break
                        elif calc_distance(pts[i+1], center_point) < 1.0:
                            dir_vec = (pts[i][0] - pts[i+1][0], pts[i][1] - pts[i+1][1])
                            directions.append(dir_vec)
                            break
            
            if directions:
                avg_dir = (sum(d[0] for d in directions)/len(directions), 
                          sum(d[1] for d in directions)/len(directions))
                if abs(avg_dir[0]) > 0.01 or abs(avg_dir[1]) > 0.01:
                    pipe_angle = math.atan2(avg_dir[1], avg_dir[0])
        
        # NODENO ì› ìœ„ì¹˜ ê²°ì • (30ë„ ë‹¨ìœ„ë¡œ íšŒì „í•˜ë©° ê°„ì„­ ì²´í¬)
        nodeno_pos = find_best_orthogonal_position_for_special(
            center_point, NODENO_OFFSET_Y, pipe_angle, msp, []
        )
        
        # NODENO ì› ê·¸ë¦¬ê¸°
        nodeno_circle = msp.add_circle(
            center=nodeno_pos, 
            radius=NODENO_RADIUS, 
            dxfattribs={'color': MAGENTA, 'layer': 'NODE'}
        )
        
        # center_pointì™€ NODENO ì¤‘ì‹¬ì„ ì‡ëŠ” ì„  (NODE ì›ì—ì„œ trim)
        dx = nodeno_pos[0] - center_point[0]
        dy = nodeno_pos[1] - center_point[1]
        distance = math.hypot(dx, dy)
        
        if distance > 0:
            ux = dx / distance
            uy = dy / distance
            trim_end_x = nodeno_pos[0] - ux * NODENO_RADIUS
            trim_end_y = nodeno_pos[1] - uy * NODENO_RADIUS
            
            msp.add_line(
                center_point, 
                (trim_end_x, trim_end_y), 
                dxfattribs={'color': WHITE, 'layer': 'NODE'}
            )
        
        # í…ìŠ¤íŠ¸ ì¶”ê°€ë¥¼ ìœ„í•´ ì €ì¥
        texts_to_add.append(nodeno_pos)
        
        processed_count += 1
        print(f"  TEE ë…¸ë“œ ì²˜ë¦¬: ({center_point[0]:.2f}, {center_point[1]:.2f}) - {tee['count']}ê°œ ì—°ê²°")
    
    # ëª¨ë“  ê·¸ë˜í”½ ìš”ì†Œ ì²˜ë¦¬ í›„ í…ìŠ¤íŠ¸ ì¶”ê°€
    for text_pos in texts_to_add:
        add_text_to_node(msp, text_pos, TEXT_VALUE, TEXT_HEIGHT, YELLOW, 'NODE', doc)
    
    return processed_count

def find_texts_with_hyphen(msp, center_point, radius):
    """ì¤‘ì‹¬ì ì—ì„œ ë°˜ê²½ ë‚´ì˜ '-'ê°€ í¬í•¨ëœ TEXT ì—”í‹°í‹° ì°¾ê¸°"""
    texts = []
    for e in msp:
        if e.dxftype() == 'TEXT' or e.dxftype() == 'MTEXT':
            text_content = ""
            text_pos = None
            
            if e.dxftype() == 'TEXT':
                text_content = e.dxf.text
                text_pos = (e.dxf.insert.x, e.dxf.insert.y)
            elif e.dxftype() == 'MTEXT':
                text_content = e.text
                text_pos = (e.dxf.insert.x, e.dxf.insert.y)
            
            if text_pos and '-' in text_content:
                dist = calc_distance(center_point, text_pos)
                if dist <= radius:
                    texts.append({
                        'entity': e,
                        'content': text_content,
                        'position': text_pos,
                        'distance': dist
                    })
    
    return texts

def get_text_bounding_box(text_entity):
    """TEXT ì—”í‹°í‹°ì˜ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°"""
    if text_entity.dxftype() == 'TEXT':
        # ê°„ë‹¨í•œ ì¶”ì • (ì •í™•í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ)
        text_height = text_entity.dxf.height
        text_content = text_entity.dxf.text
        text_width = len(text_content) * text_height * 0.6  # ì¶”ì •ê°’
        
        pos = (text_entity.dxf.insert.x, text_entity.dxf.insert.y)
        
        # 4ê°œì˜ ëª¨ì„œë¦¬ ì 
        corners = [
            pos,  # ì¢Œí•˜
            (pos[0] + text_width, pos[1]),  # ìš°í•˜
            (pos[0] + text_width, pos[1] + text_height),  # ìš°ìƒ
            (pos[0], pos[1] + text_height)  # ì¢Œìƒ
        ]
        
        return corners
    
    elif text_entity.dxftype() == 'MTEXT':
        # MTEXTì˜ ê²½ìš°
        pos = (text_entity.dxf.insert.x, text_entity.dxf.insert.y)
        height = text_entity.dxf.char_height
        
        # í…ìŠ¤íŠ¸ ë‚´ìš©ì—ì„œ ì‹¤ì œ í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œ
        text_content = text_entity.text
        # MTEXT í¬ë§· ì½”ë“œ ì œê±° (ê°„ë‹¨í•œ ë°©ë²•)
        import re
        clean_text = re.sub(r'\\[^;]+;', '', text_content)
        
        width = len(clean_text) * height * 0.6  # ì¶”ì •ê°’
        
        corners = [
            (pos[0] - width/2, pos[1] - height/2),  # ì¢Œí•˜
            (pos[0] + width/2, pos[1] - height/2),  # ìš°í•˜
            (pos[0] + width/2, pos[1] + height/2),  # ìš°ìƒ
            (pos[0] - width/2, pos[1] + height/2)   # ì¢Œìƒ
        ]
        
        return corners
    
    return []

def process_type2_support(msp, a1_data, a2_data, ct_entity, cp_center, orthogonal_lines, line_angles, pipe_angle, node_angle):
    """2ë‹¨ê³„ ì§€ì› ì²˜ë¦¬"""
    if not a2_data or not ct_entity:
        return None
    
    # AP1, AP2ëŠ” ì´ë¯¸ ì°¾ì•˜ìœ¼ë¯€ë¡œ ë‹¤ì‹œ ê³„ì‚°
    a1_center = midpoint(a1_data['pts'])
    a2_pts = a2_data['pts']
    
    ap1 = min(a2_pts, key=lambda p: calc_distance(p, a1_center))
    ap2 = max(a2_pts, key=lambda p: calc_distance(p, a1_center))
    
    print(f"\n  2ë‹¨ê³„ ì²˜ë¦¬:")
    print(f"    AP1: ({ap1[0]:.2f}, {ap1[1]:.2f})")
    print(f"    AP2: ({ap2[0]:.2f}, {ap2[1]:.2f})")
    
    # CTëŠ” ì´ë¯¸ ì°¾ì•˜ìœ¼ë¯€ë¡œ ì‚¬ìš©
    if ct_entity.dxftype() == 'TEXT':
        ct_content = ct_entity.dxf.text
    else:  # MTEXT
        ct_content = ct_entity.text
        
    print(f"    CT ë‚´ìš©: '{ct_content}'")
    
    # CT ë‚´ìš©ì—ì„œ ë’¤ì—ì„œ ì²«ë²ˆì§¸ '-' ì°¾ê³  ë‹¤ìŒ ê¸€ìë¥¼ STYPEìœ¼ë¡œ
    last_hyphen_idx = ct_content.rfind('-')
    
    if last_hyphen_idx == -1 or last_hyphen_idx == len(ct_content) - 1:
        print("    STYPEì„ ì¶”ì¶œí•  ìˆ˜ ì—†ìŒ")
        return None
    
    stype = ct_content[last_hyphen_idx + 1]
    print(f"    STYPE: '{stype}'")
    
    # STYPEì— ë”°ë¥¸ ì²˜ë¦¬
    if stype in ['G', 'A']:
        print("    STYPEì´ G ë˜ëŠ” A - íŠ¹ìˆ˜ í™”ì‚´í‘œ ì²˜ë¦¬")
        
        # NODEê°€ ì—†ëŠ” ê°ë„ì˜ LINE ì°¾ê¸° (L1)
        l1_angle = None
        for i, angle in enumerate(line_angles):
            if angle != node_angle:  # NODEê°€ ìˆëŠ” ê°ë„ê°€ ì•„ë‹Œ ê²ƒ
                l1_angle = angle
                break
        
        if l1_angle is None:
            print("    L1ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
            return None
        
        # PIPE ê°ë„ ê³„ì‚°
        pipe_angle_deg = math.degrees(pipe_angle)
        print(f"    L1 ê°ë„: {l1_angle}Â°")
        print(f"    PIPE ê°ë„: {pipe_angle_deg:.1f}Â°")
        
        # CPì ì—ì„œ 5.5mm ë–¨ì–´ì§„ ì§€ì  ê³„ì‚° (L1 ë°©í–¥)
        angle_rad = math.radians(l1_angle)
        intersection_point = (
            cp_center[0] - 5.5 * math.cos(angle_rad),
            cp_center[1] - 5.5 * math.sin(angle_rad)
        )
        
        # PIPEì™€ ë™ì¼í•œ ê¸°ìš¸ê¸°ë¡œ L1 ë¼ì¸ ê¸°ì¤€ êµì°¨í•˜ëŠ” ì–‘ìª½ìœ¼ë¡œ 5mm cyan ì„  ê·¸ë¦¬ê¸°
        perp_angle_rad = math.radians(pipe_angle_deg)
        
        # ì–‘ìª½ ëì  ê³„ì‚°
        p1 = (
            intersection_point[0] - 5.0 * math.cos(perp_angle_rad),
            intersection_point[1] - 5.0 * math.sin(perp_angle_rad)
        )
        p2 = (
            intersection_point[0] + 5.0 * math.cos(perp_angle_rad),
            intersection_point[1] + 5.0 * math.sin(perp_angle_rad)
        )
        
        # 10mm cyan ì„  ê·¸ë¦¬ê¸°
        msp.add_line(p1, p2, dxfattribs={'color': CYAN, 'layer': 'SUPP'})
        
        # PIPE ë°©í–¥ìœ¼ë¡œ ì–‘ë°©í–¥ ì‚¼ê°í˜• ê·¸ë¦¬ê¸°
        arrow_side_length = 4.0
        arrow_base_width = 1.4
        
        # ì²« ë²ˆì§¸ ë°©í–¥ (PIPE ë°©í–¥)
        for j in range(5):
            scale = 1.0 - (j * 0.2)
            if scale <= 0:
                break
            create_triangle_arrow(intersection_point, pipe_angle_deg, arrow_side_length, arrow_base_width, msp, scale=scale)
        
        # ë‘ ë²ˆì§¸ ë°©í–¥ (PIPE ë°˜ëŒ€ ë°©í–¥)
        opposite_angle = (pipe_angle_deg + 180) % 360
        for j in range(5):
            scale = 1.0 - (j * 0.2)
            if scale <= 0:
                break
            create_triangle_arrow(intersection_point, opposite_angle, arrow_side_length, arrow_base_width, msp, scale=scale)
    
    elif stype in ['C', 'V']:
        print("    STYPEì´ C ë˜ëŠ” V - ìˆ˜ì§ì„  ì²˜ë¦¬")
        
        # ìˆ˜ì§ì¸ ë‘ ì„ (90ë„, 270ë„) ì°¾ê¸°
        vertical_lines = []
        for i, angle in enumerate(line_angles):
            if angle == 90 or angle == 270:
                vertical_lines.append((orthogonal_lines[i], angle))
        
        if len(vertical_lines) < 2:
            print("    ìˆ˜ì§ì„ ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
            return None
        
        # ê° ìˆ˜ì§ì„ ì— ëŒ€í•´ ì²˜ë¦¬
        for line, angle in vertical_lines:
            angle_rad = math.radians(angle)
            
            # 5mm, 6mm, 7mm ë–¨ì–´ì§„ ì§€ì 
            distances = [5.0, 6.0, 7.0]
            points = []
            
            for dist in distances:
                point = (
                    cp_center[0] + dist * math.cos(angle_rad),
                    cp_center[1] + dist * math.sin(angle_rad)
                )
                points.append(point)
                
                # PIPE ê¸°ìš¸ê¸°ì™€ ë™ì¼í•˜ê²Œ êµì°¨í•˜ëŠ” 3mm í°ìƒ‰ ì„ 
                pipe_angle_deg = math.degrees(pipe_angle)
                perp_angle_rad = math.radians(pipe_angle_deg)
                
                p1 = (
                    point[0] - 1.5 * math.cos(perp_angle_rad),
                    point[1] - 1.5 * math.sin(perp_angle_rad)
                )
                p2 = (
                    point[0] + 1.5 * math.cos(perp_angle_rad),
                    point[1] + 1.5 * math.sin(perp_angle_rad)
                )
                
                msp.add_line(p1, p2, dxfattribs={'color': WHITE, 'layer': 'SUPP'})
            
            # 5mm ì„ ì˜ ëì ê³¼ 6mm ì„ ì˜ ì‹œì‘ì  ì—°ê²°
            # ì—¬ê¸°ì„œëŠ” ê° êµì°¨ì„ ì˜ ëì ì„ ì‚¬ìš©
            pipe_angle_deg = math.degrees(pipe_angle)
            perp_angle_rad = math.radians(pipe_angle_deg)
            
            # 5mm ìœ„ì¹˜ì˜ ëì 
            p5_end = (
                points[0][0] + 1.5 * math.cos(perp_angle_rad),
                points[0][1] + 1.5 * math.sin(perp_angle_rad)
            )
            # 6mm ìœ„ì¹˜ì˜ ì‹œì‘ì 
            p6_start = (
                points[1][0] - 1.5 * math.cos(perp_angle_rad),
                points[1][1] - 1.5 * math.sin(perp_angle_rad)
            )
            msp.add_line(p5_end, p6_start, dxfattribs={'color': WHITE, 'layer': 'SUPP'})
            
            # 6mm ì„ ì˜ ëì ê³¼ 7mm ì„ ì˜ ì‹œì‘ì  ì—°ê²°
            p6_end = (
                points[1][0] + 1.5 * math.cos(perp_angle_rad),
                points[1][1] + 1.5 * math.sin(perp_angle_rad)
            )
            p7_start = (
                points[2][0] - 1.5 * math.cos(perp_angle_rad),
                points[2][1] - 1.5 * math.sin(perp_angle_rad)
            )
            msp.add_line(p6_end, p7_start, dxfattribs={'color': WHITE, 'layer': 'SUPP'})
    
    return None  # CTëŠ” ì´ë¯¸ ì‚­ì œ ëª©ë¡ì— ì¶”ê°€ë¨

def main():
    root = tk.Tk(); root.withdraw()
    files = filedialog.askopenfilenames(title="DXF íŒŒì¼ ì„ íƒ", filetypes=[("DXF Files", "*.dxf")])
    if not files:
        print("ì„ íƒëœ íŒŒì¼ ì—†ìŒ"); return

    for filepath in files:
        print(f"\nğŸ”§ ì²˜ë¦¬ì¤‘: {filepath}")
        try:
            doc = ezdxf.readfile(filepath)
            msp = doc.modelspace()
            
            # NODE, SUPP, AD1, AD2, AD3 ë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ìƒì„±
            if 'NODE' not in doc.layers:
                doc.layers.new('NODE')
            if 'SUPP' not in doc.layers:
                doc.layers.new('SUPP')
            if 'AD1' not in doc.layers:
                doc.layers.new('AD1')
            if 'AD2' not in doc.layers:
                doc.layers.new('AD2')
            if 'AD3' not in doc.layers:
                doc.layers.new('AD3')

            s1_list = []
            for e in msp:
                if is_valid_s1(e):
                    pts = extract_points(e)
                    if pts and len(pts) == 2:
                        s1_list.append({'ent': e, 'pts': pts})
            
            print(f"\nâœ… ìœ íš¨í•œ S1 ê°œìˆ˜: {len(s1_list)}")

            # 1ë‹¨ê³„ ì²˜ë¦¬ - AD1, AD2, AD3ë¥¼ ì €ì¥í•˜ê³  ë‚˜ì¤‘ì— ì‚­ì œ
            entities_to_delete = []  # ì‚­ì œí•  ì—”í‹°í‹°ë“¤
            ct_entities_to_delete = []  # CT ì—”í‹°í‹°ë“¤
            
            # ë¨¼ì € AD1, AD2, AD3ì™€ ê´€ë ¨ëœ ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ëŠ” ë£¨í”„
            a1_a2_info = []
            for rec1 in s1_list:
                for rec2 in s1_list:
                    if rec1 is rec2: continue
                    if not hasattr(rec1['ent'], 'dxf') or not hasattr(rec2['ent'], 'dxf'):
                        continue
                    
                    # ë‘ S1ì˜ ê¸¸ì´ ì°¨ì´ê°€ 0.2mm ì´ë‚´ì—¬ì•¼ í•¨
                    len1 = polyline_length(rec1['pts'])
                    len2 = polyline_length(rec2['pts'])
                    if abs(len1 - len2) > 0.2:
                        continue
                    
                    # ê° ì  ê°„ì˜ ê±°ë¦¬ ê³„ì‚°
                    all_distances = [calc_distance(a, b) for a in rec1['pts'] for b in rec2['pts']]
                    dmin = min(all_distances)
                    dmax = max(all_distances)
                    
                    # ì  ê°„ ê±°ë¦¬ëŠ” 3.5~7mm ì‚¬ì´ì—¬ì•¼ í•¨
                    if not (3.5 <= dmin <= 7.0 and 3.5 <= dmax <= 7.0):
                        continue
                    
                    # ë‘ í´ë¦¬ë¼ì¸ì˜ ì ë“¤ì´ 0.2mm ë²”ìœ„ì—ì„œ ê°™ì€ ìœ„ì¹˜ì— ìˆìœ¼ë©´ PASS
                    if any(calc_distance(p1, p2) <= 0.2 for p1 in rec1['pts'] for p2 in rec2['pts']):
                        continue

                    sp1, ep1 = rec1['pts']
                    sp2, ep2 = rec2['pts']
                    print(f"S1-S2 ê²€ì¦: ê¸¸ì´ì°¨={abs(len1-len2):.3f}mm")
                    print(f"  ê±°ë¦¬: sp1-sp2={calc_distance(sp1, sp2):.2f} "
                          f"sp1-ep2={calc_distance(sp1, ep2):.2f} "
                          f"ep1-sp2={calc_distance(ep1, sp2):.2f} "
                          f"ep1-ep2={calc_distance(ep1, ep2):.2f}")

                    rec1['ent'].dxf.color = CYAN
                    rec2['ent'].dxf.color = CYAN
                    
                    # 0.5mm CYAN ì›ì˜ ì¤‘ì‹¬ (S1 ìŒì˜ ì¤‘ì‹¬)
                    center_sl1 = midpoint([midpoint(rec1['pts']), midpoint(rec2['pts'])])
                    
                    # AD1 ì°¾ê¸°: CYAN ì› ì¤‘ì‹¬ì—ì„œ 4mm ì´ë‚´, GT_1 ë ˆì´ì–´, 3ì , ê¸¸ì´ 5ì´í•˜
                    AD1 = None
                    for e in msp:
                        if hasattr(e.dxf, 'layer') and e.dxf.layer == 'GT_1':
                            pts = extract_points(e)
                            if len(pts) == 3:
                                # ê¸¸ì´ ê³„ì‚°
                                length = polyline_length(pts)
                                if length <= 5.0:
                                    # ì¤‘ì‹¬ì—ì„œ 4mm ì´ë‚´ì¸ì§€ í™•ì¸
                                    if any(calc_distance(p, center_sl1) <= 4.0 for p in pts):
                                        AD1 = {'ent': e, 'pts': pts}
                                        break
                    
                    if not AD1: 
                        continue
                    
                    # AD1 ë ˆì´ì–´ì™€ ìƒ‰ìƒ ì„¤ì •
                    AD1['ent'].dxf.layer = 'AD1'
                    AD1['ent'].dxf.color = RED
                    print(f"  AD1 ë°œê²¬: 3ì  í´ë¦¬ë¼ì¸, ê¸¸ì´={polyline_length(AD1['pts']):.2f}mm")
                    
                    # AD2 ì°¾ê¸°: AD1ì˜ ì ì—ì„œ 0.1mm ë‚´, ARROW ë ˆì´ì–´, 1mm ì´í•˜ LINE
                    AD2_list = []
                    for e in msp:
                        if e.dxftype() == 'LINE' and hasattr(e.dxf, 'layer') and e.dxf.layer == 'ARROW':
                            line_pts = extract_points(e)
                            if len(line_pts) == 2:
                                line_length = calc_distance(line_pts[0], line_pts[1])
                                if line_length <= 1.0:
                                    # AD1ì˜ ì ê³¼ 0.1mm ì´ë‚´ì¸ì§€ í™•ì¸
                                    for ad1_pt in AD1['pts']:
                                        for line_pt in line_pts:
                                            if calc_distance(ad1_pt, line_pt) <= 0.1:
                                                e.dxf.layer = 'AD2'
                                                e.dxf.color = RED
                                                AD2_list.append(e)
                                                print(f"  AD2 ë°œê²¬: LINE, ê¸¸ì´={line_length:.3f}mm")
                                                break
                                        if e in AD2_list:
                                            break
                    
                    # AD3 ì°¾ê¸°: AD1ì˜ ì ì—ì„œ 0.1mm ë‚´, PL2 ë ˆì´ì–´ í´ë¦¬ë¼ì¸
                    AD3 = None
                    for e in msp:
                        if hasattr(e.dxf, 'layer') and e.dxf.layer == 'PL2':
                            if e.dxftype() in ['LWPOLYLINE', 'POLYLINE']:
                                pts = extract_points(e)
                                if pts:
                                    # AD1ì˜ ì ê³¼ 0.1mm ì´ë‚´ì¸ì§€ í™•ì¸
                                    for ad1_pt in AD1['pts']:
                                        for pt in pts:
                                            if calc_distance(ad1_pt, pt) <= 0.1:
                                                AD3 = {'ent': e, 'pts': pts}
                                                e.dxf.layer = 'AD3'
                                                e.dxf.color = RED
                                                print(f"  AD3 ë°œê²¬: {e.dxftype()}, ì  ê°œìˆ˜={len(pts)}")
                                                break
                                        if AD3:
                                            break
                                if AD3:
                                    break
                    
                    if not AD3:
                        continue
                    
                    # AP1, AP2 ì°¾ê¸°
                    ad1_center = midpoint(AD1['pts'])
                    ap1 = min(AD3['pts'], key=lambda p: calc_distance(p, ad1_center))
                    ap2 = max(AD3['pts'], key=lambda p: calc_distance(p, ad1_center))
                    print(f"  AP1: ({ap1[0]:.2f}, {ap1[1]:.2f}), AP2: ({ap2[0]:.2f}, {ap2[1]:.2f})")
                    
                    # CT ì°¾ê¸°: AP2ì—ì„œ X: -70~+15mm, Y: Â±7mm ë²”ìœ„, ê¸°ìš¸ê¸° 0, '-' í¬í•¨ TEXT
                    CT = None
                    for e in msp:
                        if e.dxftype() in ['TEXT', 'MTEXT']:
                            text_content = ""
                            text_pos = None
                            
                            if e.dxftype() == 'TEXT':
                                text_content = e.dxf.text
                                text_pos = (e.dxf.insert.x, e.dxf.insert.y)
                                # ê¸°ìš¸ê¸° 0 í™•ì¸ (rotationì´ 0ì´ê±°ë‚˜ ì—†ìŒ)
                                if hasattr(e.dxf, 'rotation') and abs(e.dxf.rotation) > 0.1:
                                    continue
                            elif e.dxftype() == 'MTEXT':
                                text_content = e.text
                                text_pos = (e.dxf.insert.x, e.dxf.insert.y)
                            
                            if text_pos and '-' in text_content:
                                # ë²”ìœ„ í™•ì¸
                                dx = text_pos[0] - ap2[0]
                                dy = text_pos[1] - ap2[1]
                                
                                if -70 <= dx <= 15 and -7 <= dy <= 7:
                                    CT = e
                                    e.dxf.color = RED
                                    print(f"  CT ë°œê²¬: '{text_content}' at ({text_pos[0]:.2f}, {text_pos[1]:.2f})")
                                    break
                    
                    # AD1, AD2, AD3, CT ì •ë³´ ì €ì¥
                    a1_a2_info.append({
                        's1': rec1,
                        's2': rec2,
                        'a1': AD1,  # AD1ìœ¼ë¡œ ì‚¬ìš©
                        'a2': AD3,  # AD3ë¥¼ a2ë¡œ ì‚¬ìš© (2ë‹¨ê³„ ì²˜ë¦¬ë¥¼ ìœ„í•´)
                        'ad2_list': AD2_list,  # AD2 ë¦¬ìŠ¤íŠ¸ ì €ì¥
                        'ct': CT,
                        'center': center_sl1
                    })
                    
                    # ì‚­ì œí•  ì—”í‹°í‹° ëª©ë¡ì— ì¶”ê°€
                    entities_to_delete.append(AD1['ent'])
                    entities_to_delete.extend(AD2_list)
                    entities_to_delete.append(AD3['ent'])
                    if CT:
                        ct_entities_to_delete.append(CT)
                    
                    break

            # S1 ìŒì„ ì°¾ì•„ CP ì›, ì§êµì„ , NODE ìƒì„±í•˜ëŠ” ë£¨í”„
            supptag = []
            created_circles = []
            texts_to_add = []  # í…ìŠ¤íŠ¸ ì¶”ê°€ë¥¼ ìœ„í•œ ë¦¬ìŠ¤íŠ¸
            
            for rec1 in list(s1_list):
                for rec2 in list(s1_list):
                    if rec1 is rec2: continue
                    if not hasattr(rec1['ent'], 'dxf') or not hasattr(rec2['ent'], 'dxf'):
                        continue
                    
                    # ë‘ S1ì˜ ê¸¸ì´ ì°¨ì´ê°€ 0.2mm ì´ë‚´ì—¬ì•¼ í•¨
                    len1 = polyline_length(rec1['pts'])
                    len2 = polyline_length(rec2['pts'])
                    if abs(len1 - len2) > 0.2:
                        continue
                    
                    # ê° ì  ê°„ì˜ ê±°ë¦¬ ê³„ì‚°
                    all_distances = [calc_distance(a, b) for a in rec1['pts'] for b in rec2['pts']]
                    dmin = min(all_distances)
                    dmax = max(all_distances)
                    
                    # ì  ê°„ ê±°ë¦¬ëŠ” 3.5~7mm ì‚¬ì´ì—¬ì•¼ í•¨
                    if not (3.5 <= dmin <= 7.0 and 3.5 <= dmax <= 7.0):
                        continue
                    
                    # ë‘ í´ë¦¬ë¼ì¸ì˜ ì ë“¤ì´ 0.2mm ë²”ìœ„ì—ì„œ ê°™ì€ ìœ„ì¹˜ì— ìˆìœ¼ë©´ PASS
                    if any(calc_distance(p1, p2) <= 0.2 for p1 in rec1['pts'] for p2 in rec2['pts']):
                        continue
                    
                    pts1, pts2 = rec1['pts'], rec2['pts']
                    center_sl1 = midpoint([midpoint(pts1), midpoint(pts2)])
                    
                    # CP ì› ê·¸ë¦¬ê¸°
                    cp_circle = msp.add_circle(center=center_sl1, radius=HALF_SL1, dxfattribs={'color': CYAN})
                    created_circles.append(cp_circle)
                    
                    # íŒŒì´í”„ ë°©í–¥ ê³„ì‚° ë° ì§êµì„  ìƒì„±
                    pipe_angle = get_pipe_angle(pts1, pts2)
                    
                    # ì§êµì„ ê³¼ ê°ë„ í•¨ê»˜ ë°›ê¸°
                    orthogonal_lines, line_angles = create_iso_orthogonal_lines(center_sl1, pipe_angle, LINE_LENGTH, msp)
                    
                    # NODENO ì› ìœ„ì¹˜ ê²°ì • (4ê°œì˜ ì§êµì„  ë°©í–¥ ì¤‘ ìµœì  ì„ íƒ)
                    nodeno_pos, node_angle = find_best_orthogonal_position(
                        center_sl1, NODENO_OFFSET_Y, pipe_angle, msp, [cp_circle], line_angles
                    )
                    
                    # NODENO ì› ê·¸ë¦¬ê¸°
                    nodeno_circle = msp.add_circle(
                        center=nodeno_pos, 
                        radius=NODENO_RADIUS, 
                        dxfattribs={'color': MAGENTA, 'layer': 'NODE'}
                    )
                    
                    # CPì™€ NODENO ì¤‘ì‹¬ì„ ì‡ëŠ” ì„  (NODE ì›ì—ì„œ trim)
                    dx = nodeno_pos[0] - center_sl1[0]
                    dy = nodeno_pos[1] - center_sl1[1]
                    distance = math.hypot(dx, dy)
                    
                    if distance > 0:
                        ux = dx / distance
                        uy = dy / distance
                        trim_end_x = nodeno_pos[0] - ux * NODENO_RADIUS
                        trim_end_y = nodeno_pos[1] - uy * NODENO_RADIUS
                        
                        msp.add_line(
                            center_sl1, 
                            (trim_end_x, trim_end_y), 
                            dxfattribs={'color': WHITE, 'layer': 'NODE'}
                        )
                    
                    # í…ìŠ¤íŠ¸ ì¶”ê°€ë¥¼ ìœ„í•´ ì €ì¥
                    texts_to_add.append(nodeno_pos)
                    
                    # 2ë‹¨ê³„ ì²˜ë¦¬ë¥¼ ìœ„í•´ í•´ë‹¹í•˜ëŠ” A1, A2 ì •ë³´ ì°¾ê¸°
                    matching_info = None
                    for info in a1_a2_info:
                        if (info['s1']['ent'] == rec1['ent'] and info['s2']['ent'] == rec2['ent']) or \
                           (info['s1']['ent'] == rec2['ent'] and info['s2']['ent'] == rec1['ent']):
                            matching_info = info
                            break
                    
                    # 2ë‹¨ê³„ ì²˜ë¦¬
                    if matching_info:
                        ct_entity = matching_info.get('ct')  # CT ì—”í‹°í‹° ê°€ì ¸ì˜¤ê¸°
                        process_type2_support(
                            msp, matching_info['a1'], matching_info['a2'], ct_entity,
                            center_sl1, orthogonal_lines, line_angles, 
                            pipe_angle, node_angle
                        )
                    
                    msp.delete_entity(rec1['ent'])
                    msp.delete_entity(rec2['ent'])
                    supptag.append({'s1': rec1['ent'], 's2': rec2['ent'], 'center': center_sl1})
                    break

            # ===== ELBOì™€ TEE TEXT ì²˜ë¦¬ =====
            print("\nğŸ”§ ELBO ë° TEE TEXT íŠ¹ìˆ˜ ë…¸ë“œ ì²˜ë¦¬ ì‹œì‘...")
            special_nodes_count = process_special_nodes(msp, doc)
            print(f"âœ… íŠ¹ìˆ˜ ë…¸ë“œ ì²˜ë¦¬ ì™„ë£Œ: {special_nodes_count}ê°œ ë…¸ë“œ ìƒì„±ë¨")
            
            # ëª¨ë“  ê·¸ë˜í”½ ìš”ì†Œ ì²˜ë¦¬ í›„ í…ìŠ¤íŠ¸ ì¶”ê°€
            print("\nğŸ“ í…ìŠ¤íŠ¸ ì¶”ê°€ ì‹œì‘...")
            text_count = 0
            for text_pos in texts_to_add:
                result = add_text_to_node(msp, text_pos, TEXT_VALUE, TEXT_HEIGHT, YELLOW, 'NODE', doc)
                if result:
                    text_count += 1
                else:
                    print(f"      âš ï¸ í…ìŠ¤íŠ¸ ì¶”ê°€ ì‹¤íŒ¨: ìœ„ì¹˜ ({text_pos[0]:.2f}, {text_pos[1]:.2f})")
            print(f"âœ… {text_count}/{len(texts_to_add)}ê°œ í…ìŠ¤íŠ¸ ì¶”ê°€ ì™„ë£Œ")
            
            # ëª¨ë“  ì‘ì—… ì™„ë£Œ í›„ AD1, AD2, AD3, CT ì‚­ì œ
            print("\nğŸ—‘ï¸ ì—”í‹°í‹° ì‚­ì œ ì‹œì‘...")
            deleted_count = 0
            for ent in entities_to_delete:
                try:
                    msp.delete_entity(ent)
                    deleted_count += 1
                except:
                    pass
            
            for ent in ct_entities_to_delete:
                try:
                    msp.delete_entity(ent)
                    deleted_count += 1
                except:
                    pass
            
            print(f"âœ… {deleted_count}ê°œ ì—”í‹°í‹° ì‚­ì œ ì™„ë£Œ")

            out_path = os.path.splitext(filepath)[0] + '_SUPP.dxf'
            doc.saveas(out_path)
            print(f"âœ… ì €ì¥ë¨: {out_path}")

        except Exception as e:
            print(f"âŒ ì˜¤ë¥˜ ë°œìƒ @ {filepath}")
            traceback.print_exc(file=sys.stdout)

    print("ğŸ‰ ì „ì²´ ì‘ì—… ì™„ë£Œ")

if __name__ == '__main__':
    main()