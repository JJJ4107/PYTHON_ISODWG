import ezdxf
import os
import math
from ezdxf.math import Vec2
from tkinter import Tk, filedialog

def select_dxf_files():
    """DXF íŒŒì¼ ì„ íƒ ëŒ€í™”ìƒì"""
    root = Tk()
    root.withdraw()
    file_paths = filedialog.askopenfilenames(
        title="DXF íŒŒì¼ ì„ íƒ",
        filetypes=[("DXF Files", "*.dxf")]
    )
    root.destroy()
    return file_paths

def extract_points(entity):
    """í´ë¦¬ë¼ì¸ì—ì„œ ì  ì¶”ì¶œ"""
    if entity.dxftype() == 'LWPOLYLINE':
        return [Vec2(x, y) for x, y, *_ in entity.get_points()]
    elif entity.dxftype() == 'POLYLINE':
        try:
            # POLYLINE vertices ì ‘ê·¼ ë°©ì‹
            points = []
            for vertex in entity.vertices:
                if hasattr(vertex, 'dxf'):
                    location = vertex.dxf.location
                    points.append(Vec2(location.x, location.y))
                else:
                    # ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì‹œë„
                    points.append(Vec2(vertex.location[0], vertex.location[1]))
            return points
        except:
            try:
                # ëŒ€ì²´ ë°©ì‹
                return [Vec2(v.dxf.location.x, v.dxf.location.y) for v in entity]
            except:
                return []
    return []

def distance(p1, p2):
    """ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬"""
    return math.hypot(p2.x - p1.x, p2.y - p1.y)

def get_entity_layer(entity):
    """ì—”í‹°í‹°ì˜ ë ˆì´ì–´ ì´ë¦„ì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°"""
    try:
        if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'layer'):
            return entity.dxf.layer
        elif hasattr(entity, 'get_dxf_attrib'):
            return entity.get_dxf_attrib('layer', default='')
        else:
            return ''
    except:
        return ''

def get_entity_color(entity):
    """ì—”í‹°í‹°ì˜ ìƒ‰ìƒì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°"""
    try:
        if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'color'):
            return entity.dxf.color
        elif hasattr(entity, 'get_dxf_attrib'):
            return entity.get_dxf_attrib('color', default=7)
        else:
            return 7
    except:
        return 7

def set_entity_color(entity, color):
    """ì—”í‹°í‹°ì˜ ìƒ‰ìƒì„ ì•ˆì „í•˜ê²Œ ì„¤ì •í•˜ê¸°"""
    try:
        if hasattr(entity, 'dxf'):
            entity.dxf.color = color
        elif hasattr(entity, 'set_dxf_attrib'):
            entity.set_dxf_attrib('color', color)
    except:
        pass

def get_entity_handle(entity):
    """ì—”í‹°í‹°ì˜ í•¸ë“¤ì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°"""
    try:
        if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'handle'):
            return entity.dxf.handle
        elif hasattr(entity, 'get_dxf_attrib'):
            return entity.get_dxf_attrib('handle', default='')
        elif hasattr(entity, 'handle'):
            return entity.handle
        else:
            return 'UNKNOWN'
    except:
        return 'UNKNOWN'

def get_polyline_length(points):
    """í´ë¦¬ë¼ì¸ì˜ ì´ ê¸¸ì´ ê³„ì‚°"""
    if len(points) < 2:
        return 0
    total_length = 0
    for i in range(len(points) - 1):
        total_length += distance(points[i], points[i+1])
    return total_length

def get_angle(p1, p2):
    """ë‘ ì  ì‚¬ì´ì˜ ê°ë„ (ë„ ë‹¨ìœ„)"""
    return math.degrees(math.atan2(p2.y - p1.y, p2.x - p1.x))

def are_parallel(angle1, angle2, tolerance=5):
    """ë‘ ê°ë„ê°€ í‰í–‰í•œì§€ í™•ì¸ (í—ˆìš© ì˜¤ì°¨ ë‚´)
    
    ì‹œì‘ì ê³¼ ëì ì´ ë°˜ëŒ€ì¸ ê²½ìš°(180ë„ ì°¨ì´)ë„ í‰í–‰ìœ¼ë¡œ ì¸ì‹
    ì˜ˆ: 45ë„ì™€ 225ë„ëŠ” ê°™ì€ ì„ ì´ì§€ë§Œ ë°©í–¥ì´ ë°˜ëŒ€ -> í‰í–‰ìœ¼ë¡œ ì²˜ë¦¬
    """
    diff = abs(angle1 - angle2) % 180
    return diff <= tolerance or diff >= (180 - tolerance)

def find_nearest_polyline(ref_points, polylines, max_dist):
    """ì°¸ì¡° í´ë¦¬ë¼ì¸ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ í´ë¦¬ë¼ì¸ ì°¾ê¸°"""
    min_dist = float('inf')
    nearest = None
    
    for pl in polylines:
        pl_points = extract_points(pl)
        if not pl_points:
            continue
            
        # ë‘ í´ë¦¬ë¼ì¸ ê°„ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
        for ref_pt in ref_points:
            for pl_pt in pl_points:
                d = distance(ref_pt, pl_pt)
                if d < min_dist and d <= max_dist:
                    min_dist = d
                    nearest = pl
    
    return nearest, min_dist

def point_to_line_distance(point, line_start, line_end):
    """ì ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ìˆ˜ì§ ê±°ë¦¬ ê³„ì‚°"""
    line_vec = line_end - line_start
    point_vec = point - line_start
    line_len = distance(line_start, line_end)
    
    if line_len < 0.001:  # ì„ ë¶„ì´ ì ì¸ ê²½ìš°
        return distance(point, line_start)
    
    # ì ì„ ì„ ë¶„ì— íˆ¬ì˜
    t = max(0, min(1, (point_vec.x * line_vec.x + point_vec.y * line_vec.y) / (line_len * line_len)))
    projection = line_start + line_vec * t
    
    return distance(point, projection)

def polyline_to_polyline_min_distance(points1, points2):
    """ë‘ í´ë¦¬ë¼ì¸ ê°„ì˜ ìµœì†Œ ìˆ˜ì§ ê±°ë¦¬ ê³„ì‚°"""
    min_dist = float('inf')
    
    # points1ì˜ ê° ì ì—ì„œ points2ì˜ ê° ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬
    for pt1 in points1:
        for i in range(len(points2) - 1):
            dist = point_to_line_distance(pt1, points2[i], points2[i+1])
            min_dist = min(min_dist, dist)
    
    # points2ì˜ ê° ì ì—ì„œ points1ì˜ ê° ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬
    for pt2 in points2:
        for i in range(len(points1) - 1):
            dist = point_to_line_distance(pt2, points1[i], points1[i+1])
            min_dist = min(min_dist, dist)
    
    return min_dist

def is_entity_touching_olet(entity, dolet_points, tolerance=0.1):
    """ì—”í‹°í‹°ê°€ OLETê³¼ ì ‘í•˜ëŠ”ì§€ í™•ì¸"""
    if entity.dxftype() == 'LINE':
        start = Vec2(entity.dxf.start.x, entity.dxf.start.y)
        end = Vec2(entity.dxf.end.x, entity.dxf.end.y)
        points = [start, end]
    else:
        points = extract_points(entity)
    
    if not points:
        return False
    
    # ì—”í‹°í‹°ì˜ ê° ì ì´ OLETì˜ ì ê³¼ ì ‘í•˜ëŠ”ì§€ í™•ì¸
    for entity_pt in points:
        for dolet_pt in dolet_points:
            if distance(entity_pt, dolet_pt) <= tolerance:
                return True
    
    # ì—”í‹°í‹°ì˜ ê° ì„ ë¶„ì´ OLETì˜ ì„ ë¶„ê³¼ ì ‘í•˜ëŠ”ì§€ í™•ì¸
    for i in range(len(points) - 1):
        for j in range(len(dolet_points) - 1):
            # ë‘ ì„ ë¶„ ê°„ì˜ ìµœì†Œ ê±°ë¦¬ê°€ tolerance ì´í•˜ë©´ ì ‘ì´‰
            dist = point_to_line_distance(points[i], dolet_points[j], dolet_points[j+1])
            if dist <= tolerance:
                return True
            dist = point_to_line_distance(dolet_points[j], points[i], points[i+1])
            if dist <= tolerance:
                return True
                
    return False

def line_passes_through_polyline(line_start, line_end, polyline_points):
    """ë¼ì¸ì´ í´ë¦¬ë¼ì¸ì„ í†µê³¼í•˜ëŠ”ì§€ í™•ì¸"""
    def ccw(A, B, C):
        return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x)
    
    def segments_intersect(A, B, C, D):
        return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)
    
    # í´ë¦¬ë¼ì¸ì˜ ê° ì„ ë¶„ê³¼ êµì°¨ í™•ì¸
    for i in range(len(polyline_points) - 1):
        if segments_intersect(line_start, line_end, polyline_points[i], polyline_points[i+1]):
            return True
    return False

def polyline_passes_through_line(polyline_points, line_start, line_end):
    """í´ë¦¬ë¼ì¸ì˜ ì„ ë¶„ ì¤‘ í•˜ë‚˜ê°€ ë¼ì¸ì„ í†µê³¼í•˜ëŠ”ì§€ í™•ì¸"""
    def ccw(A, B, C):
        return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x)
    
    def segments_intersect(A, B, C, D):
        return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)
    
    # í´ë¦¬ë¼ì¸ì˜ ê° ì„ ë¶„ì´ ë¼ì¸ê³¼ êµì°¨í•˜ëŠ”ì§€ í™•ì¸
    for i in range(len(polyline_points) - 1):
        if segments_intersect(polyline_points[i], polyline_points[i+1], line_start, line_end):
            return True
    return False

def find_nearest_point_to_point_distance(points1, points2, max_dist):
    """ë‘ í´ë¦¬ë¼ì¸ì˜ ì ë“¤ ê°„ ìµœì†Œ ê±°ë¦¬ ì°¾ê¸°
    
    max_dist ì´ë‚´ì˜ ê°€ì¥ ê°€ê¹Œìš´ ì  ìŒì˜ ê±°ë¦¬ë¥¼ ë°˜í™˜
    """
    min_dist = float('inf')
    
    for pt1 in points1:
        for pt2 in points2:
            d = distance(pt1, pt2)
            if d <= max_dist and d < min_dist:
                min_dist = d
    
    return min_dist if min_dist != float('inf') else None

def process_file(filepath):
    """DXF íŒŒì¼ ì²˜ë¦¬"""
    doc = ezdxf.readfile(filepath)
    msp = doc.modelspace()
    
    print(f"\nì²˜ë¦¬ ì¤‘: {os.path.basename(filepath)}")
    
    # ì‚­ì œí•  ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸
    entities_to_delete = []
    
    # ì´ë¯¸ ë‹¤ë¥¸ OLETì—ì„œ ì‚¬ìš©ëœ ì—”í‹°í‹° ì¶”ì 
    used_entities = set()
    
    # 1. OLET ë ˆì´ì–´ í´ë¦¬ë¼ì¸ ì°¾ê¸° (DOLET)
    dolet_entities = []
    for entity in msp.query('LWPOLYLINE POLYLINE'):
        layer = get_entity_layer(entity).upper()
        if layer == 'OLET':
            dolet_entities.append(entity)
            handle = get_entity_handle(entity)
            print(f"[DOLET] OLET ë ˆì´ì–´ í´ë¦¬ë¼ì¸ ë°œê²¬: {handle}")
    
    # ê° DOLETì— ëŒ€í•´ ì²˜ë¦¬
    for dolet in dolet_entities:
        dolet_points = extract_points(dolet)
        if not dolet_points:
            continue
            
        # DOLET ìƒ‰ìƒì„ CYANìœ¼ë¡œ ë³€ê²½
        set_entity_color(dolet, 4)  # CYAN
        
        print(f"\n[DOLET {get_entity_handle(dolet)}] ì²˜ë¦¬ ì‹œì‘")
        
        # 2. OLETì˜ ì–´ëŠ í•œ ì ìœ¼ë¡œë¶€í„° PIPEì˜ ì–´ëŠ í•œ ì ì´ 1mm ì´ë‚´ì— ìœ„ì¹˜í•˜ëŠ” PIPE ë ˆì´ì–´ ì°¾ê¸°
        pipe = None
        pipe_points = None
        pipe_dist = float('inf')
        
        # í´ë¦¬ë¼ì¸ì—ì„œ PIPE ì°¾ê¸°
        for entity in msp.query('LWPOLYLINE POLYLINE'):
            layer = get_entity_layer(entity).upper()
            if layer == 'PIPE':
                entity_points = extract_points(entity)
                if not entity_points:
                    continue
                    
                # OLETì˜ ì ê³¼ PIPEì˜ ì  ê°„ ìµœì†Œ ê±°ë¦¬ í™•ì¸
                for dolet_pt in dolet_points:
                    for entity_pt in entity_points:
                        d = distance(dolet_pt, entity_pt)
                        if d <= 1.0 and d < pipe_dist:
                            pipe = entity
                            pipe_dist = d
                            pipe_points = entity_points
        
        # LINEì—ì„œë„ PIPE ì°¾ê¸°
        for line in msp.query('LINE'):
            layer = get_entity_layer(line).upper()
            if layer == 'PIPE':
                start = Vec2(line.dxf.start.x, line.dxf.start.y)
                end = Vec2(line.dxf.end.x, line.dxf.end.y)
                line_points = [start, end]
                
                # OLETì˜ ì ê³¼ LINEì˜ ì  ê°„ ìµœì†Œ ê±°ë¦¬ í™•ì¸
                for dolet_pt in dolet_points:
                    for line_pt in line_points:
                        d = distance(dolet_pt, line_pt)
                        if d <= 1.0 and d < pipe_dist:
                            pipe = line
                            pipe_dist = d
                            pipe_points = line_points
        
        if not pipe:
            print(f"  [ê²½ê³ ] OLETì˜ ì ìœ¼ë¡œë¶€í„° 1mm ë‚´ì— PIPE ë ˆì´ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            continue
            
        if len(pipe_points) < 2:
            continue
            
        # PIPE ìƒ‰ìƒì„ ë³´ë¼ìƒ‰(MAGENTA)ìœ¼ë¡œ ë³€ê²½
        # set_entity_color(pipe, 3)  # MAGENTA
            
        # PIPEì˜ ê°ë„ ê³„ì‚°
        pipe_angle = get_angle(pipe_points[0], pipe_points[1])
        pipe_type = "LINE" if pipe.dxftype() == 'LINE' else "POLYLINE"
        opposite_angle = (pipe_angle + 180) % 360
        print(f"  [PIPE] ë°œê²¬ ({pipe_type}, ì  ê°„ ê±°ë¦¬: {pipe_dist:.3f}mm, ê°ë„: {pipe_angle:.1f}Â° ë˜ëŠ” {opposite_angle:.1f}Â°, ìƒ‰ìƒ: MAGENTA)")
        
        # 3. PIPEì™€ í‰í–‰í•˜ê³  GT ë˜ëŠ” PL í¬í•¨, ê¸¸ì´ 5-25mm, 2ì  í´ë¦¬ë¼ì¸, OLETì˜ ì ì—ì„œ 1.5-5mm ë²”ìœ„ 2ê°œ ì°¾ê¸° (DEL1)
        del1_list = []  # 2ê°œ ì°¾ê¸°
        del1_candidates = []
        
        for entity in msp.query('LWPOLYLINE POLYLINE'):
            if entity == dolet or entity == pipe:
                continue
                
            # ì´ë¯¸ ë‹¤ë¥¸ OLETì—ì„œ ì‚¬ìš©ëœ ì—”í‹°í‹° ì œì™¸
            if entity in used_entities:
                continue
                
            # OLETê³¼ ì ‘í•˜ëŠ” ì—”í‹°í‹° ì œì™¸
            if is_entity_touching_olet(entity, dolet_points):
                continue
                
            layer_name = get_entity_layer(entity).upper()
            if not ('GT' in layer_name or 'PL' in layer_name):
                continue
                
            points = extract_points(entity)
            # ì •í™•íˆ 2ì ë§Œ í—ˆìš©
            if len(points) != 2:
                continue
                
            # ê¸¸ì´ í™•ì¸ (5mm ~ 25mmë¡œ ë³€ê²½)
            length = get_polyline_length(points)
            if not (5 <= length <= 25):
                continue
                
            # ê°ë„ í™•ì¸ (í‰í–‰ ì—¬ë¶€) - ì‹œì‘ì ì´ ë°˜ëŒ€ì¸ ê²½ìš°ë„ í‰í–‰ìœ¼ë¡œ ì¸ì‹
            entity_angle = get_angle(points[0], points[1])
            if not are_parallel(pipe_angle, entity_angle):
                continue
                
            # OLETì˜ ì ì—ì„œ í´ë¦¬ë¼ì¸ì˜ ì ê¹Œì§€ 1.5mm ì´ìƒ 5mm ì´ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
            is_in_range = False
            min_dist_to_olet = float('inf')
            
            for entity_pt in points:
                for dolet_pt in dolet_points:
                    dist = distance(entity_pt, dolet_pt)
                    min_dist_to_olet = min(min_dist_to_olet, dist)
                    if 1.5 <= dist <= 5.0:  # 1.5mm ì´ìƒ 5mm ì´ë‚´ë¡œ ë³€ê²½
                        is_in_range = True
            
            if not is_in_range:
                continue
                
            # DEL1 í›„ë³´ë¡œ ì¶”ê°€
            del1_candidates.append({
                'entity': entity,
                'distance_to_dolet': min_dist_to_olet,
                'length': length
            })
        
        # ê¸¸ì´ê°€ ë™ì¼í•œ(ì˜¤ì°¨ 0.3mm) 2ê°œ ì°¾ê¸°
        del1_candidates.sort(key=lambda x: x['distance_to_dolet'])
        
        for i, candidate1 in enumerate(del1_candidates):
            if len(del1_list) >= 2:
                break
                
            for j, candidate2 in enumerate(del1_candidates[i+1:], i+1):
                # ë‘ í´ë¦¬ë¼ì¸ì˜ ê¸¸ì´ ì°¨ì´ê°€ 0.3mm ì´ë‚´ì¸ì§€ í™•ì¸
                if abs(candidate1['length'] - candidate2['length']) <= 0.3:
                    del1_list = [candidate1['entity'], candidate2['entity']]
                    
                    # ì²« ë²ˆì§¸ DEL1 ì •ë³´ ì¶œë ¥ ë° ìƒ‰ìƒ ë³€ê²½
                    entity = candidate1['entity']
                    set_entity_color(entity, 1)  # REDë¡œ ì¦‰ì‹œ ë³€ê²½
                    used_entities.add(entity)  # ì‚¬ìš©ëœ ì—”í‹°í‹°ë¡œ ì¶”ê°€
                    points = extract_points(entity)
                    layer = get_entity_layer(entity)
                    angle = get_angle(points[0], points[1])
                    print(f"  [DEL1-1] ë°œê²¬: {get_entity_handle(entity)} (ë ˆì´ì–´: {layer}, ê¸¸ì´: {candidate1['length']:.1f}mm, ê°ë„: {angle:.1f}Â°, ìƒ‰ìƒ: RED)")
                    
                    # ë‘ ë²ˆì§¸ DEL1 ì •ë³´ ì¶œë ¥ ë° ìƒ‰ìƒ ë³€ê²½
                    entity = candidate2['entity']
                    set_entity_color(entity, 1)  # REDë¡œ ì¦‰ì‹œ ë³€ê²½
                    used_entities.add(entity)  # ì‚¬ìš©ëœ ì—”í‹°í‹°ë¡œ ì¶”ê°€
                    points = extract_points(entity)
                    layer = get_entity_layer(entity)
                    angle = get_angle(points[0], points[1])
                    print(f"  [DEL1-2] ë°œê²¬: {get_entity_handle(entity)} (ë ˆì´ì–´: {layer}, ê¸¸ì´: {candidate2['length']:.1f}mm, ê°ë„: {angle:.1f}Â°, ìƒ‰ìƒ: RED)")
                    
                    print(f"  [DEL1] ê¸¸ì´ ì°¨ì´: {abs(candidate1['length'] - candidate2['length']):.3f}mm")
                    break
        
        if len(del1_list) < 2:
            print(f"  [ê²½ê³ ] ê¸¸ì´ê°€ ë™ì¼í•œ(ì˜¤ì°¨ 0.3mm) DEL1 2ê°œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ({len(del1_list)}ê°œ ë°œê²¬)")
            if len(del1_list) == 0:
                continue
        
        # DEL1ì„ í•˜ë‚˜ë¼ë„ ì°¾ì€ ê²½ìš°ì—ë§Œ ê³„ì† ì§„í–‰
        if not del1_list:
            print(f"  [ê²½ê³ ] DEL1ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            continue
            
        # ì²« ë²ˆì§¸ DEL1ì„ ê¸°ì¤€ìœ¼ë¡œ ì§„í–‰
        del1 = del1_list[0]
        
        # 4. DEL1ì˜ ì  ì¤‘ OLETê³¼ ë¨¼ ì ì—ì„œ 3ì  í´ë¦¬ë¼ì¸ì˜ 2ë²ˆì§¸ ì ê³¼ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì°¾ê¸° (DEL2) - ë¬´ì¡°ê±´ 1ê°œ
        del2 = None
        del1_points = extract_points(del1)
        
        # DEL1ì˜ ì  ì¤‘ OLETê³¼ ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
        farthest_del1_point = None
        max_dist_to_olet = 0
        
        for del1_pt in del1_points:
            min_dist_to_olet = float('inf')
            for dolet_pt in dolet_points:
                dist = distance(del1_pt, dolet_pt)
                min_dist_to_olet = min(min_dist_to_olet, dist)
            
            if min_dist_to_olet > max_dist_to_olet:
                max_dist_to_olet = min_dist_to_olet
                farthest_del1_point = del1_pt
        
        print(f"  [DEL1-OLET] DEL1ì˜ ì  ì¤‘ OLETê³¼ ê°€ì¥ ë¨¼ ì ì˜ ê±°ë¦¬: {max_dist_to_olet:.3f}mm")
        
        # OLETê³¼ ë¨¼ DEL1 ì ì—ì„œ 3ì  í´ë¦¬ë¼ì¸ì˜ 2ë²ˆì§¸ ì (ì¤‘ê°„ì )ê³¼ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì°¾ê¸°
        min_del2_dist = float('inf')
        del2_candidates = []
        
        for entity in msp.query('LWPOLYLINE POLYLINE'):
            if entity == dolet:  # OLET ìì‹ ì€ ì œì™¸
                continue
                
            # ì´ë¯¸ ë‹¤ë¥¸ OLETì—ì„œ ì‚¬ìš©ëœ ì—”í‹°í‹° ì œì™¸
            if entity in used_entities:
                continue
                
            # OLETê³¼ ì ‘í•˜ëŠ” ì—”í‹°í‹° ì œì™¸
            if is_entity_touching_olet(entity, dolet_points):
                continue
                
            points = extract_points(entity)
            if len(points) != 3:
                continue
                
            # OLETê³¼ ë¨¼ DEL1 ì ì—ì„œ 3ì  í´ë¦¬ë¼ì¸ì˜ 2ë²ˆì§¸ ì (ì¤‘ê°„ì )ê¹Œì§€ì˜ ê±°ë¦¬
            dist_to_second_point = distance(farthest_del1_point, points[1])  # points[1]ì´ 2ë²ˆì§¸ ì 
            
            # ì ê°„ ê±°ë¦¬í•© ê³„ì‚° (ì°¸ê³ ìš©)
            total_dist = distance(points[0], points[1]) + distance(points[1], points[2])
            
            del2_candidates.append({
                'entity': entity,
                'distance': dist_to_second_point,
                'total_dist': total_dist,
                'layer': get_entity_layer(entity)
            })
        
        # ê±°ë¦¬ê°€ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
        if del2_candidates:
            del2_candidates.sort(key=lambda x: x['distance'])
            selected = del2_candidates[0]
            del2 = selected['entity']
            min_del2_dist = selected['distance']
            
            set_entity_color(del2, 1)  # REDë¡œ ì¦‰ì‹œ ë³€ê²½
            used_entities.add(del2)  # ì‚¬ìš©ëœ ì—”í‹°í‹°ë¡œ ì¶”ê°€
            handle = get_entity_handle(del2)
            print(f"  [DEL2] ë°œê²¬: {handle} (ë ˆì´ì–´: {selected['layer']}, ì ê°„ ê±°ë¦¬í•©: {selected['total_dist']:.1f}mm, OLETê³¼ ë¨¼ DEL1 ì ê³¼ 2ë²ˆì§¸ ì ì˜ ê±°ë¦¬: {min_del2_dist:.1f}mm, ìƒ‰ìƒ: RED)")
            print(f"  [DEL2] ì´ {len(del2_candidates)}ê°œì˜ 3ì  í´ë¦¬ë¼ì¸ ì¤‘ ì„ íƒë¨")
        else:
            print(f"  [ê²½ê³ ] DEL2ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (3ì  í´ë¦¬ë¼ì¸ì´ ì—†ìŒ)")
            continue
            
        # 5. DEL2ì˜ ê° ì ì—ì„œ ARROW ë ˆì´ì–´, ê¸¸ì´ 1mm ì´í•˜ LINE ì°¾ê¸° (DEL3)
        del3_list = []
        del2_points = extract_points(del2)
        
        for line in msp.query('LINE'):
            # ì´ë¯¸ ë‹¤ë¥¸ OLETì—ì„œ ì‚¬ìš©ëœ ì—”í‹°í‹° ì œì™¸
            if line in used_entities:
                continue
                
            # OLETê³¼ ì ‘í•˜ëŠ” LINE ì œì™¸
            if is_entity_touching_olet(line, dolet_points):
                continue
                
            layer = get_entity_layer(line).upper()
            if layer != 'ARROW':
                continue
                
            start = Vec2(line.dxf.start.x, line.dxf.start.y)
            end = Vec2(line.dxf.end.x, line.dxf.end.y)
            
            # ê¸¸ì´ í™•ì¸
            line_length = distance(start, end)
            if line_length > 1.0:
                continue
                
            # DEL2ì˜ ì ë“¤ê³¼ì˜ ê±°ë¦¬ í™•ì¸
            for pt in del2_points:
                if distance(pt, start) < 0.1 or distance(pt, end) < 0.1:
                    del3_list.append(line)
                    set_entity_color(line, 1)  # REDë¡œ ì¦‰ì‹œ ë³€ê²½
                    used_entities.add(line)  # ì‚¬ìš©ëœ ì—”í‹°í‹°ë¡œ ì¶”ê°€
                    handle = get_entity_handle(line)
                    print(f"  [DEL3] ë°œê²¬: LINE {handle} (ê¸¸ì´: {line_length:.3f}mm, ìƒ‰ìƒ: RED)")
                    break
        
        if not del3_list:
            print(f"  [ê²½ê³ ] DEL3ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            continue
            
        # 6. GT/PL2 í¬í•¨, ê¸¸ì´ 3.5-100mm, 2ì  ë˜ëŠ” 3ì , DEL3 ì ê³¼ 3mm ì´ë‚´ í´ë¦¬ë¼ì¸ ì°¾ê¸° (DEL4)
        del4 = None
        del4_candidates = []
        
        for entity in msp.query('LWPOLYLINE POLYLINE'):
            if entity == dolet:  # OLET ìì‹ ì€ ì œì™¸
                continue
                
            # ì´ë¯¸ ë‹¤ë¥¸ OLETì—ì„œ ì‚¬ìš©ëœ ì—”í‹°í‹° ì œì™¸
            if entity in used_entities:
                continue
                
            # DEL2ë¡œ ì„ íƒëœ ì—”í‹°í‹° ì œì™¸
            if entity == del2:
                continue
                
            # OLETê³¼ ì ‘í•˜ëŠ” ì—”í‹°í‹° ì œì™¸
            if is_entity_touching_olet(entity, dolet_points):
                continue
                
            layer_name = get_entity_layer(entity).upper()
            if not ('GT' in layer_name or 'PL2' in layer_name):
                continue
                
            points = extract_points(entity)
            # 2ì  ë˜ëŠ” 3ì ë§Œ í—ˆìš©
            if len(points) != 2 and len(points) != 3:
                continue
                
            # ê¸¸ì´ í™•ì¸ (3.5mm ~ 100mm)
            length = get_polyline_length(points)
            if length < 3.5 or length > 100:
                continue
                
            # DEL3ë“¤ì˜ ì ê³¼ 3mm ì´ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
            min_dist_to_del3 = float('inf')
            is_within_3mm = False
            
            for line in del3_list:
                start = Vec2(line.dxf.start.x, line.dxf.start.y)
                end = Vec2(line.dxf.end.x, line.dxf.end.y)
                
                # í´ë¦¬ë¼ì¸ì˜ ê° ì ì—ì„œ DEL3ì˜ ì ê¹Œì§€ ê±°ë¦¬
                for pt in points:
                    dist_to_start = distance(pt, start)
                    dist_to_end = distance(pt, end)
                    
                    min_dist_to_del3 = min(min_dist_to_del3, dist_to_start, dist_to_end)
                    
                    # 3mm ì´ë‚´ì¸ì§€ í™•ì¸
                    if dist_to_start <= 3.0 or dist_to_end <= 3.0:
                        is_within_3mm = True
            
            # 3mm ì´ë‚´ì— ìˆëŠ” ê²ƒë§Œ í›„ë³´ë¡œ ì¶”ê°€
            if is_within_3mm:
                del4_candidates.append({
                    'entity': entity,
                    'distance_to_del3': min_dist_to_del3,
                    'length': length,
                    'points': len(points)
                })
        
        # DEL3ì— ê°€ì¥ ê°€ê¹Œìš´ ê²ƒì„ ì„ íƒ
        if del4_candidates:
            del4_candidates.sort(key=lambda x: x['distance_to_del3'])
            selected = del4_candidates[0]
            del4 = selected['entity']
            set_entity_color(del4, 1)  # REDë¡œ ì¦‰ì‹œ ë³€ê²½
            used_entities.add(del4)  # ì‚¬ìš©ëœ ì—”í‹°í‹°ë¡œ ì¶”ê°€
            layer = get_entity_layer(del4)
            handle = get_entity_handle(del4)
            print(f"  [DEL4] ë°œê²¬: {handle} (ë ˆì´ì–´: {layer}, ê¸¸ì´: {selected['length']:.1f}mm, ì  ê°œìˆ˜: {selected['points']}, DEL3ì™€ì˜ ê±°ë¦¬: {selected['distance_to_del3']:.1f}mm, ìƒ‰ìƒ: RED)")
            print(f"  [DEL4] ì´ {len(del4_candidates)}ê°œ í›„ë³´ ì¤‘ DEL3ì— ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ")
        else:
            print(f"  [ê²½ê³ ] DEL4ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (DEL3 ì ê³¼ 3mm ì´ë‚´ì— ìˆëŠ” GT/PL2 í´ë¦¬ë¼ì¸ ì—†ìŒ)")
            continue
            
        # 7. DEL4 25mm ë‚´ì˜ 60-400 ìˆ«ì í…ìŠ¤íŠ¸ ì°¾ê¸° (DEL5) - ê¸°ìš¸ê¸° 0ì¸ 1ê°œë§Œ
        del5 = None
        del4_points = extract_points(del4)
        min_dist_for_del5 = float('inf')
        
        for text in msp.query('TEXT'):
            # ì´ë¯¸ ë‹¤ë¥¸ OLETì—ì„œ ì‚¬ìš©ëœ í…ìŠ¤íŠ¸ ì œì™¸
            if text in used_entities:
                continue
                
            # í…ìŠ¤íŠ¸ ê¸°ìš¸ê¸° í™•ì¸ (0ë„ì¸ì§€)
            try:
                rotation = text.dxf.rotation
                if abs(rotation) > 0.01:  # 0.01ë„ ì´ìƒ ê¸°ìš¸ì–´ì ¸ ìˆìœ¼ë©´ ì œì™¸
                    continue
            except:
                continue
                
            text_str = text.dxf.text.strip()
            
            # ìˆ«ìì¸ì§€ í™•ì¸
            try:
                value = float(text_str)
                if not (60 <= value <= 400):
                    continue
            except:
                continue
                
            # DEL4ì™€ì˜ ìµœì†Œ ê±°ë¦¬ í™•ì¸
            insert = text.dxf.insert
            text_pos = Vec2(insert[0], insert[1])
            
            for pt in del4_points:
                dist = distance(pt, text_pos)
                if dist <= 25 and dist < min_dist_for_del5:
                    min_dist_for_del5 = dist
                    del5 = text
        
        if del5:
            set_entity_color(del5, 1)  # REDë¡œ ì¦‰ì‹œ ë³€ê²½
            used_entities.add(del5)  # ì‚¬ìš©ëœ ì—”í‹°í‹°ë¡œ ì¶”ê°€
            print(f"  [DEL5] ë°œê²¬: TEXT '{del5.dxf.text}' (ê±°ë¦¬: {min_dist_for_del5:.1f}mm, ê¸°ìš¸ê¸°: 0Â°, ìƒ‰ìƒ: RED)")
        
        # 8. ì°¾ì€ ëª¨ë“  ì—”í‹°í‹°ë¥¼ ì‚­ì œ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ (ìƒ‰ìƒì€ ì´ë¯¸ ë³€ê²½ë¨)
        for del1 in del1_list:
            entities_to_delete.append(del1)
            
        if del2:
            entities_to_delete.append(del2)
            
        for line in del3_list:
            entities_to_delete.append(line)
            
        if del4:
            entities_to_delete.append(del4)
            if not del5:
                print(f"  [ì£¼ì˜] DEL5ë¥¼ ì°¾ì§€ ëª»í–ˆì§€ë§Œ DEL4ëŠ” REDë¡œ ì´ë¯¸ ì„¤ì •ë˜ì–´ ì‚­ì œë©ë‹ˆë‹¤.")
            
        if del5:
            entities_to_delete.append(del5)
    
    # 9. ì—”í‹°í‹° ì‚­ì œ (DOLETê³¼ PIPE ì œì™¸, RED ìƒ‰ìƒë§Œ)
    deleted_count = 0
    for entity in entities_to_delete:
        try:
            # ìƒ‰ìƒì´ RED(1)ì¸ ê²½ìš°ë§Œ ì‚­ì œ
            if get_entity_color(entity) == 1:
                msp.delete_entity(entity)
                deleted_count += 1
                handle = get_entity_handle(entity)
                print(f"[ì‚­ì œ] {entity.dxftype()}: {handle}")
        except Exception as e:
            handle = get_entity_handle(entity)
            print(f"[ì‚­ì œ ì˜¤ë¥˜] {handle}: {e}")
    
    print(f"\nì´ {deleted_count}ê°œ ì—”í‹°í‹° ì‚­ì œë¨")
    print(f"ì´ {len(entities_to_delete)}ê°œ ì—”í‹°í‹°ê°€ ì²˜ë¦¬ë¨")
    print(f"\nìƒ‰ìƒ ë³€ê²½ ì •ë³´:")
    print(f"  - OLET (DOLET): CYAN (ìœ ì§€)")
    print(f"  - PIPE: MAGENTA (ìœ ì§€)")
    print(f"  - DEL1~DEL5: RED (ë°œê²¬ ì¦‰ì‹œ ë³€ê²½ í›„ ì‚­ì œ)")
    print(f"\nì¤‘ë³µ ë°©ì§€: ê° ì—”í‹°í‹°ëŠ” í•˜ë‚˜ì˜ OLETì—ì„œë§Œ ì„ íƒë¨")
    
    # 10. íŒŒì¼ ì €ì¥
    save_path = os.path.splitext(filepath)[0] + "_ODEL.dxf"
    doc.saveas(save_path)
    print(f"âœ… ì €ì¥ ì™„ë£Œ: {os.path.basename(save_path)}")

if __name__ == "__main__":
    files = select_dxf_files()
    if not files:
        print("âŒ ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
    else:
        for file in files:
            try:
                process_file(file)
            except Exception as e:
                print(f"âŒ íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        print("\nğŸ‰ ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ!")