import os
import sys
import ezdxf
import math
import numpy as np
from ezdxf.entities import Line, LWPolyline, Polyline, Text
import tkinter as tk
from tkinter import filedialog, messagebox
from tkinter import ttk

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì„¤ì • ê°’ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ANGLE_TOLERANCE = 5.0  # ê°ë„ í—ˆìš© ì˜¤ì°¨ (Â°)
DIM_LAYER_PREFIX = "GT_"  # ì¹˜ìˆ˜ì„  ë ˆì´ì–´ ì ‘ë‘ì‚¬


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ íŒŒì¼ ì„ íƒ GUI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def select_dxf_files():
    """
    Windows íŒŒì¼ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ë¥¼ ì—´ì–´ DXF íŒŒì¼ë“¤ì„ ì„ íƒ
    Returns: ì„ íƒëœ íŒŒì¼ ê²½ë¡œë“¤ì˜ ë¦¬ìŠ¤íŠ¸
    """
    root = tk.Tk()
    root.withdraw()
    
    file_paths = filedialog.askopenfilenames(
        title="DXF íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš” (ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥)",
        filetypes=[
            ("DXF files", "*.dxf"),
            ("All files", "*.*")
        ],
        multiple=True
    )
    
    root.destroy()
    return list(file_paths)

def show_progress_window(total_files):
    """
    ì§„í–‰ ìƒí™©ì„ ë³´ì—¬ì£¼ëŠ” í”„ë¡œê·¸ë ˆìŠ¤ ìœˆë„ìš° ìƒì„±
    """
    progress_window = tk.Tk()
    progress_window.title("DXF ì²˜ë¦¬ ì§„í–‰ ìƒí™©")
    progress_window.geometry("500x150")
    progress_window.resizable(False, False)
    
    progress_window.eval('tk::PlaceWindow . center')
    
    label = tk.Label(progress_window, text="DXF íŒŒì¼ì„ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...", font=("Arial", 12))
    label.pack(pady=10)
    
    file_label = tk.Label(progress_window, text="", font=("Arial", 10), fg="blue")
    file_label.pack(pady=5)
    
    progress_var = tk.DoubleVar()
    progress_bar = ttk.Progressbar(
        progress_window, 
        variable=progress_var, 
        maximum=total_files, 
        length=400,
        mode='determinate'
    )
    progress_bar.pack(pady=10)
    
    progress_text = tk.Label(progress_window, text=f"0 / {total_files}", font=("Arial", 10))
    progress_text.pack()
    
    progress_window.update()
    
    return progress_window, progress_var, file_label, progress_text

def update_progress(window, progress_var, file_label, progress_text, current, total, current_file):
    """
    í”„ë¡œê·¸ë ˆìŠ¤ ì—…ë°ì´íŠ¸
    """
    if window and window.winfo_exists():
        progress_var.set(current)
        file_label.config(text=f"ì²˜ë¦¬ ì¤‘: {os.path.basename(current_file)}")
        progress_text.config(text=f"{current} / {total}")
        window.update()

def close_progress_window(window):
    """
    í”„ë¡œê·¸ë ˆìŠ¤ ìœˆë„ìš° ë‹«ê¸°
    """
    if window and window.winfo_exists():
        window.destroy()


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ìœ í‹¸ í•¨ìˆ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def to2d(pt):
    if hasattr(pt, "__getitem__"):
        return np.array((pt[0], pt[1]), float)
    return np.array((pt.x, pt.y), float)

def distance(a, b):
    return float(np.linalg.norm(a - b))

def angle_deg(a, b):
    dx, dy = b - a
    return (math.degrees(math.atan2(dy, dx)) + 360) % 360

def get_entity_handle(entity):
    """
    ì—”í‹°í‹°ì˜ í•¸ë“¤ì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜
    """
    try:
        if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'handle'):
            return entity.dxf.handle
        elif hasattr(entity, 'handle'):
            return entity.handle
        else:
            return str(id(entity))  # ë§ˆì§€ë§‰ ìˆ˜ë‹¨ìœ¼ë¡œ ê°ì²´ ID ì‚¬ìš©
    except:
        return "unknown"

def extract_segments(ent):
    if isinstance(ent, Line):
        return [(ent.dxf.start, ent.dxf.end)]
    if isinstance(ent, LWPolyline):
        pts = list(ent.get_points("xyb"))
        z = ent.dxf.elevation
        return [
            ((x0, y0, z), (x1, y1, z)) for (x0, y0, _), (x1, y1, _) in zip(pts, pts[1:])
        ]
    if isinstance(ent, Polyline):
        verts = list(ent.vertices)
        return [
            (verts[i].dxf.location, verts[i + 1].dxf.location)
            for i in range(len(verts) - 1)
        ]
    return []

def is_enclosed(point, msp):
    """
    ì£¼ì–´ì§„ ì ì´ ë‹«íŒ ì˜ì—­(í´ë¦¬ê³¤) ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
    """
    x, y = float(point[0]), float(point[1])
    
    for entity in msp.query("LWPOLYLINE POLYLINE"):
        if not entity.is_closed:
            continue
            
        if hasattr(entity, 'get_points'):
            points = list(entity.get_points("xy"))
        else:
            points = [(v.dxf.location[0], v.dxf.location[1]) for v in entity.vertices]
        
        if len(points) < 3:
            continue
            
        if point_in_polygon(x, y, points):
            return True
    
    return False

def point_in_polygon(x, y, polygon_points):
    """
    Ray casting ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì ì´ í´ë¦¬ê³¤ ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
    """
    n = len(polygon_points)
    inside = False
    
    p1x, p1y = polygon_points[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon_points[i % n]
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        p1x, p1y = p2x, p2y
    
    return inside

def point_to_line_distance(point, line_start, line_end):
    """
    ì ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°
    """
    line_vec = line_end - line_start
    line_length_sq = np.dot(line_vec, line_vec)
    
    if line_length_sq == 0:
        return distance(point, line_start)
    
    point_vec = point - line_start
    t = np.dot(point_vec, line_vec) / line_length_sq
    t = max(0, min(1, t))
    closest_point = line_start + t * line_vec
    
    return distance(point, closest_point)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DB1, CH1 ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def find_dim_pairs_optimized(all_line_entities):
    """
    DIM1, DIM2 ìŒì„ ì°¾ëŠ” í•¨ìˆ˜ (ìµœì í™”ëœ ë²„ì „ - ë¯¸ë¦¬ í•„í„°ë§ëœ ì—”í‹°í‹° ì‚¬ìš©)
    """
    two_point_entities = []
    
    for ent in all_line_entities:
        if not ent.dxf.layer.startswith(DIM_LAYER_PREFIX):
            continue
            
        segments = extract_segments(ent)
        if len(segments) != 1:
            continue
            
        p0, p1 = segments[0]
        v0, v1 = to2d(p0), to2d(p1)
        length = distance(v0, v1)
        
        if 1.5 <= length <= 8.0:
            two_point_entities.append((ent, v0, v1, length))
    
    dim_pairs = []
    overlapped_entities = []
    close_tolerance = 0.2
    far_threshold = 3.0
    tolerance_len = 0.5
    
    for i in range(len(two_point_entities)):
        for j in range(i + 1, len(two_point_entities)):
            ent1, v0_1, v1_1, len1 = two_point_entities[i]
            ent2, v0_2, v1_2, len2 = two_point_entities[j]
            
            length_diff = abs(len1 - len2)
            if length_diff > tolerance_len:
                continue
            
            connection_cases = [
                (v0_1, v0_2, v1_1, v1_2, "v0_1-v0_2"),
                (v0_1, v1_2, v1_1, v0_2, "v0_1-v1_2"),
                (v1_1, v0_2, v0_1, v1_2, "v1_1-v0_2"),
                (v1_1, v1_2, v0_1, v0_2, "v1_1-v1_2"),
            ]
            
            valid_pair_found = False
            overlap_found = False
            
            for close_pt1, close_pt2, far_pt1, far_pt2, case_name in connection_cases:
                close_dist = distance(close_pt1, close_pt2)
                far_dist = distance(far_pt1, far_pt2)
                
                if close_dist <= close_tolerance:
                    if far_dist <= close_tolerance:
                        if ent1 not in overlapped_entities:
                            ent1.dxf.color = 3
                            overlapped_entities.append(ent1)
                        if ent2 not in overlapped_entities:
                            ent2.dxf.color = 3
                            overlapped_entities.append(ent2)
                        overlap_found = True
                        break
                    elif far_dist >= far_threshold:
                        if case_name == "v0_1-v0_2":
                            vec1 = v1_1 - v0_1
                            vec2 = v1_2 - v0_2
                            dim1_common, dim1_opposite = v0_1, v1_1
                            dim2_common, dim2_opposite = v0_2, v1_2
                        elif case_name == "v0_1-v1_2":
                            vec1 = v1_1 - v0_1
                            vec2 = v0_2 - v1_2
                            dim1_common, dim1_opposite = v0_1, v1_1
                            dim2_common, dim2_opposite = v1_2, v0_2
                        elif case_name == "v1_1-v0_2":
                            vec1 = v0_1 - v1_1
                            vec2 = v1_2 - v0_2
                            dim1_common, dim1_opposite = v1_1, v0_1
                            dim2_common, dim2_opposite = v0_2, v1_2
                        else:
                            vec1 = v0_1 - v1_1
                            vec2 = v0_2 - v1_2
                            dim1_common, dim1_opposite = v1_1, v0_1
                            dim2_common, dim2_opposite = v1_2, v0_2
                        
                        dot_product = np.dot(vec1, vec2)
                        
                        if dot_product < 0:
                            if ent1 not in overlapped_entities and ent2 not in overlapped_entities:
                                dim_pairs.append({
                                    'DIM1': ent1, 'DIM1_common': dim1_common, 'DIM1_opposite': dim1_opposite,
                                    'DIM2': ent2, 'DIM2_common': dim2_common, 'DIM2_opposite': dim2_opposite,
                                    'common_point': (close_pt1 + close_pt2) / 2,
                                    'length': (len1 + len2) / 2
                                })
                                valid_pair_found = True
                                break
                
                if valid_pair_found or overlap_found:
                    break
            
            if not overlap_found and not valid_pair_found:
                reverse_dist1 = distance(v0_1, v1_2)
                reverse_dist2 = distance(v1_1, v0_2)
                
                if reverse_dist1 <= close_tolerance and reverse_dist2 <= close_tolerance:
                    if ent1 not in overlapped_entities:
                        ent1.dxf.color = 3
                        overlapped_entities.append(ent1)
                    if ent2 not in overlapped_entities:
                        ent2.dxf.color = 3
                        overlapped_entities.append(ent2)
                    overlap_found = True
    
    return dim_pairs, overlapped_entities

def find_arrow_entities_optimized(all_line_entities, point, tolerance=0.5):
    """
    ìµœì í™”ëœ ë²„ì „ - ë¯¸ë¦¬ í•„í„°ë§ëœ ì—”í‹°í‹°ì—ì„œ 3ì  í´ë¦¬ë¼ì¸ ì°¾ê¸°
    """
    arrows = []
    
    for ent in all_line_entities:
        if not ent.dxf.layer.startswith(DIM_LAYER_PREFIX):
            continue
            
        if isinstance(ent, LWPolyline):
            points = list(ent.get_points("xy"))
        else:
            points = [v.dxf.location for v in ent.vertices]
        
        if len(points) != 3:
            continue
        
        pts = [to2d(p) for p in points]
        min_dist_to_point = min(distance(pt, point) for pt in pts)
        
        if min_dist_to_point <= tolerance:
            arrows.append(ent)
    
    return arrows

def find_ad3_entities_optimized(all_line_entities, dim_pair, ad1_entities, ad2_entities, tolerance=0.5):
    """
    ìµœì í™”ëœ ë²„ì „ - ë¯¸ë¦¬ í•„í„°ë§ëœ ì—”í‹°í‹°ì—ì„œ AD3 ì°¾ê¸°
    """
    ad3_candidates = []
    common_point = dim_pair['common_point']
    
    excluded_handles = set()
    for ad1 in ad1_entities:
        excluded_handles.add(get_entity_handle(ad1))
    for ad2 in ad2_entities:
        excluded_handles.add(get_entity_handle(ad2))
    
    for ent in all_line_entities:
        if not ent.dxf.layer.startswith(DIM_LAYER_PREFIX):
            continue
            
        if get_entity_handle(ent) in excluded_handles:
            continue
            
        if isinstance(ent, LWPolyline):
            points = list(ent.get_points("xy"))
        else:
            points = [v.dxf.location for v in ent.vertices]
        
        if len(points) != 3:
            continue
        
        pts = [to2d(p) for p in points]
        min_dist_to_cp = min(distance(pt, common_point) for pt in pts)
        
        if min_dist_to_cp <= tolerance:
            ad3_candidates.append((ent, min_dist_to_cp))
    
    if ad3_candidates:
        ad3_candidates.sort(key=lambda x: x[1])
        return [ad3_candidates[0][0]]
    
    return []

def find_ad3_touching_dims(all_line_entities, dim1_ent, dim2_ent, ad1_entities, ad2_entities, tolerance=0.1):
    """
    DIM1ì´ë‚˜ DIM2 ì„ ë¶„ì— ì ‘í•˜ëŠ” AD3 ì—”í‹°í‹°ë“¤ì„ ì°¾ëŠ” í•¨ìˆ˜ (AD1, AD2 ì œì™¸)
    """
    touching_ad3 = []
    
    # DIM1, DIM2 ì„ ë¶„ ì •ë³´ ì¶”ì¶œ
    dim1_segments = extract_segments(dim1_ent)
    dim2_segments = extract_segments(dim2_ent)
    
    if not dim1_segments or not dim2_segments:
        return []
    
    dim1_start, dim1_end = to2d(dim1_segments[0][0]), to2d(dim1_segments[0][1])
    dim2_start, dim2_end = to2d(dim2_segments[0][0]), to2d(dim2_segments[0][1])
    
    # DIM1, DIM2, AD1, AD2 ì œì™¸
    excluded_handles = {get_entity_handle(dim1_ent), get_entity_handle(dim2_ent)}
    
    # AD1, AD2 í•¸ë“¤ ì¶”ê°€í•˜ì—¬ ì‚­ì œ ëŒ€ìƒì—ì„œ ì œì™¸
    for ad1 in ad1_entities:
        excluded_handles.add(get_entity_handle(ad1))
    for ad2 in ad2_entities:
        excluded_handles.add(get_entity_handle(ad2))
    
    for ent in all_line_entities:
        if not ent.dxf.layer.startswith(DIM_LAYER_PREFIX):
            continue
            
        if get_entity_handle(ent) in excluded_handles:
            continue
            
        # 3ì  í´ë¦¬ë¼ì¸ì¸ì§€ í™•ì¸
        if isinstance(ent, LWPolyline):
            points = list(ent.get_points("xy"))
        else:
            points = [v.dxf.location for v in ent.vertices]
        
        if len(points) != 3:
            continue
        
        pts = [to2d(p) for p in points]
        
        # AD3ì˜ ê° ì ì´ DIM1 ë˜ëŠ” DIM2 ì„ ë¶„ì— ì ‘í•˜ëŠ”ì§€ í™•ì¸
        is_touching = False
        
        for pt in pts:
            # DIM1 ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬
            dist_to_dim1 = point_to_line_distance(pt, dim1_start, dim1_end)
            # DIM2 ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬
            dist_to_dim2 = point_to_line_distance(pt, dim2_start, dim2_end)
            
            if dist_to_dim1 <= tolerance or dist_to_dim2 <= tolerance:
                is_touching = True
                break
        
        if is_touching:
            touching_ad3.append(ent)
    
    return touching_ad3

def find_g1_entities_optimized(all_line_entities, dim1_ent, dim2_ent, dim_pair, tolerance=0.2):
    """
    ìµœì í™”ëœ ë²„ì „ - ë¯¸ë¦¬ í•„í„°ë§ëœ ì—”í‹°í‹°ì—ì„œ G1 ì°¾ê¸°
    """
    g1_candidates = []
    
    dim1_segments = extract_segments(dim1_ent)
    dim2_segments = extract_segments(dim2_ent)
    
    if not dim1_segments or not dim2_segments:
        return []
    
    dim1_start, dim1_end = to2d(dim1_segments[0][0]), to2d(dim1_segments[0][1])
    dim2_start, dim2_end = to2d(dim2_segments[0][0]), to2d(dim2_segments[0][1])
    
    common_point = dim_pair['common_point']
    dim1_common = dim_pair['DIM1_common']
    dim1_opposite = dim_pair['DIM1_opposite']
    dim2_common = dim_pair['DIM2_common'] 
    dim2_opposite = dim_pair['DIM2_opposite']
    
    excluded_handles = {get_entity_handle(dim1_ent), get_entity_handle(dim2_ent)}
    
    for ent in all_line_entities:
        if not ent.dxf.layer.startswith(DIM_LAYER_PREFIX):
            continue
        
        if get_entity_handle(ent) in excluded_handles:
            continue
            
        segments = extract_segments(ent)
        if len(segments) != 1:
            continue
        
        p0, p1 = segments[0]
        v0, v1 = to2d(p0), to2d(p1)
        
        min_dist_to_far_ends = min(
            distance(v0, dim1_opposite), distance(v1, dim1_opposite),
            distance(v0, dim2_opposite), distance(v1, dim2_opposite)
        )
        
        far_end_exclusion_distance = 0.5
        if min_dist_to_far_ends <= far_end_exclusion_distance:
            continue
        
        min_dist_to_valid_area = float('inf')
        
        for g1_pt in [v0, v1]:
            dist_to_common = distance(g1_pt, common_point)
            if dist_to_common < min_dist_to_valid_area:
                min_dist_to_valid_area = dist_to_common
        
        for g1_pt in [v0, v1]:
            dist_to_dim1_common = distance(g1_pt, dim1_common)
            dist_to_dim1_line = point_to_line_distance(g1_pt, dim1_start, dim1_end)
            min_dist_dim1 = min(dist_to_dim1_common, dist_to_dim1_line)
            
            if min_dist_dim1 < min_dist_to_valid_area:
                min_dist_to_valid_area = min_dist_dim1
        
        for g1_pt in [v0, v1]:
            dist_to_dim2_common = distance(g1_pt, dim2_common)
            dist_to_dim2_line = point_to_line_distance(g1_pt, dim2_start, dim2_end)
            min_dist_dim2 = min(dist_to_dim2_common, dist_to_dim2_line)
            
            if min_dist_dim2 < min_dist_to_valid_area:
                min_dist_to_valid_area = min_dist_dim2
        
        if min_dist_to_valid_area <= tolerance:
            g1_candidates.append((ent, v0, v1, min_dist_to_valid_area))
    
    if g1_candidates:
        g1_candidates.sort(key=lambda x: x[3])
        closest_g1 = g1_candidates[0]
        return [(closest_g1[0], closest_g1[1], closest_g1[2])]
    
    return []

def find_ct_texts(msp, g1_entities, text_entities, dim_pair, search_radius=10.0):
    """
    G1 ì§€ì‹œì„ ì˜ DIM1, DIM2 êµì°¨ì ì—ì„œ ë¨¼ ìª½ ëì—ì„œ 10mm ë‚´ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ íšŒì „ì´ 0ì¸ ìˆ«ì ì¹˜ìˆ˜ í…ìŠ¤íŠ¸ ì°¾ê¸°
    RED í…ìŠ¤íŠ¸ë‚˜ WDNO ë ˆì´ì–´ëŠ” ì œì™¸í•˜ê³ , 2ê°œ ì´ìƒì´ë©´ í° ê°’ì„ ì„ íƒ (ë¡œê·¸ ìµœì†Œí™”)
    """
    ct_texts = []
    
    common_point = dim_pair['common_point']
    
    for g1_ent, v0, v1 in g1_entities:
        dist_to_common_v0 = distance(v0, common_point)
        dist_to_common_v1 = distance(v1, common_point)
        
        if dist_to_common_v0 > dist_to_common_v1:
            search_point = v0
        else:
            search_point = v1
        
        candidates = []
        
        for txt in text_entities:
            try:
                # RED í…ìŠ¤íŠ¸ ì œì™¸
                if hasattr(txt.dxf, 'color') and txt.dxf.color == 1:
                    continue
                
                # WDNO ë ˆì´ì–´ ì œì™¸
                if hasattr(txt.dxf, 'layer') and 'WDNO' in txt.dxf.layer.upper():
                    continue
                
                if hasattr(txt.dxf, 'insert') and txt.dxf.insert is not None:
                    txt_pt = to2d(txt.dxf.insert)
                elif (hasattr(txt.dxf, 'align_point') and txt.dxf.align_point is not None):
                    txt_pt = to2d(txt.dxf.align_point)
                else:
                    continue
            except:
                continue
            
            dist = distance(txt_pt, search_point)
            if dist > search_radius:
                continue
            
            text_val = txt.plain_text() if hasattr(txt, "plain_text") else txt.dxf.text
            
            if not text_val.isdigit():
                continue
            
            rotation = float(getattr(txt.dxf, "rotation", 0.0))
            if abs(rotation) > 0.1:
                continue
            
            if is_enclosed(txt_pt, msp):
                continue
            
            try:
                text_numeric_value = int(text_val)
                candidates.append((dist, txt, text_numeric_value))
            except:
                continue
        
        if candidates:
            if len(candidates) > 1:
                # í° ê°’ ìš°ì„ , ê°™ì€ ê°’ì´ë©´ ê°€ê¹Œìš´ ê±°ë¦¬ ìš°ì„ 
                candidates.sort(key=lambda x: (-x[2], x[0]))
                selected_candidate = candidates[0]
            else:
                candidates.sort(key=lambda x: x[0])
                selected_candidate = candidates[0]
            
            closest_txt = selected_candidate[1]
            ct_texts.append(closest_txt)
            break
    
    return ct_texts

def calculate_chain_direction(dim1_ent, dim2_ent):
    """
    DIM1, DIM2ë¡œë¶€í„° ì²´ì¸ ë°©í–¥ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
    """
    # DIM1ì˜ ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ ì²´ì¸ ë°©í–¥ ê³„ì‚°
    dim1_segments = extract_segments(dim1_ent)
    if dim1_segments:
        p0, p1 = dim1_segments[0]
        v0, v1 = to2d(p0), to2d(p1)
        chain_dir = angle_deg(v0, v1)
        return chain_dir
    return 0.0

def calculate_text_angle(chain_dir):
    """
    ì²´ì¸ ë°©í–¥ìœ¼ë¡œë¶€í„° í…ìŠ¤íŠ¸ ê°ë„ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
    """
    angle = chain_dir % 360
    
    # ìˆ˜ì§(ìœ„/ì•„ë˜) ë°©í–¥ì¼ ë•Œ í…ìŠ¤íŠ¸ í—¤ë“œë¥¼ ì™¼ìª½(90Â°)ìœ¼ë¡œ ê³ ì •
    if abs(angle - 90) <= ANGLE_TOLERANCE or abs(angle - 270) <= ANGLE_TOLERANCE:
        angle = 90.0
    else:
        # í…ìŠ¤íŠ¸ê°€ ë’¤ì§‘íˆì§€ ì•Šë„ë¡, 90~270Â° êµ¬ê°„ì€ +180Â° ë³´ì •
        if 90 < angle < 270:
            angle = (angle + 180) % 360
    
    return angle

def find_parallel_polylines_for_ang(msp, dim_pair, tolerance=0.5):
    """
    CP ë°˜ëŒ€í¸ ì ì—ì„œ 2ì ì„ ê°€ì§„ í´ë¦¬ë¼ì¸ì„ ì°¾ì•„ ANG ê°ë„ ê³„ì‚° (DIM1, DIM2 ì œì™¸)
    ìµœì í™”: ì „ì²´ ìŠ¤ìº” ëŒ€ì‹  í•„ìš”ì‹œì—ë§Œ í˜¸ì¶œ
    """
    dim1_opposite = dim_pair['DIM1_opposite']
    dim2_opposite = dim_pair['DIM2_opposite']
    
    # DIM1, DIM2 ì œì™¸ ëª©ë¡ ì¶”ê°€
    excluded_handles = {
        get_entity_handle(dim_pair['DIM1']),
        get_entity_handle(dim_pair['DIM2'])
    }
    
    # DIM1ê³¼ DIM2 ë°˜ëŒ€í¸ ì ë“¤ ê·¼ì²˜ì—ì„œ í´ë¦¬ë¼ì¸ ì°¾ê¸°
    search_points = [dim1_opposite, dim2_opposite]
    found_polylines = []
    
    # í•„ìš”ì‹œì—ë§Œ ì¿¼ë¦¬ ì‹¤í–‰ (ANG ê°ë„ ê³„ì‚°ì‹œì—ë§Œ)
    for search_point in search_points:
        for ent in msp.query("LWPOLYLINE POLYLINE"):
            if not ent.dxf.layer.startswith(DIM_LAYER_PREFIX):
                continue
            
            # DIM1, DIM2 ì œì™¸
            if get_entity_handle(ent) in excluded_handles:
                continue
            
            # í´ë¦¬ë¼ì¸ì˜ ì ë“¤ ì¶”ì¶œ
            if isinstance(ent, LWPolyline):
                points = list(ent.get_points("xy"))
            else:
                points = [v.dxf.location for v in ent.vertices]
            
            if len(points) != 2:  # ì •í™•íˆ 2ê°œì˜ ì ë§Œ ê²€ìƒ‰
                continue
            
            # í´ë¦¬ë¼ì¸ì˜ ê° ì ì´ ê²€ìƒ‰ ì  ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸
            pts = [to2d(p) for p in points]
            min_distance = min(distance(pt, search_point) for pt in pts)
            
            if min_distance <= tolerance:
                # í´ë¦¬ë¼ì¸ì˜ ë°©í–¥ ê°ë„ ê³„ì‚° (ì²« ë²ˆì§¸ì™€ ë‘ ë²ˆì§¸ ì  ê¸°ì¤€)
                polyline_angle = angle_deg(pts[0], pts[1])
                found_polylines.append((ent, polyline_angle, min_distance, search_point))
    
    # ê°€ì¥ ê°€ê¹Œìš´ í´ë¦¬ë¼ì¸ì˜ ê°ë„ë¥¼ ANGë¡œ ì‚¬ìš©
    if found_polylines:
        # ê±°ë¦¬ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
        found_polylines.sort(key=lambda x: x[2])
        closest_polyline = found_polylines[0]
        ang_angle = closest_polyline[1]
        return ang_angle
    else:
        return 0.0

def get_text_dimensions(txt):
    """
    í…ìŠ¤íŠ¸ì˜ í¬ê¸° ì •ë³´ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ (ê¸¸ì´ë§Œ ë°˜í™˜)
    """
    try:
        if txt.dxftype() == "TEXT":
            # TEXT ì—”í‹°í‹°ì˜ ê²½ìš°
            text_val = txt.dxf.text
            height = float(txt.dxf.height)
            # ëŒ€ëµì ì¸ ë¬¸ì í­ ê³„ì‚° (ë†’ì´ì˜ 0.6ë°°ë¡œ ì¶”ì •)
            char_width = height * 0.6
            text_length = len(text_val) * char_width
            return text_length, height
            
        elif txt.dxftype() == "MTEXT":
            # MTEXT ì—”í‹°í‹°ì˜ ê²½ìš°
            text_val = txt.plain_text() if hasattr(txt, "plain_text") else txt.dxf.text
            height = float(txt.dxf.char_height) if hasattr(txt.dxf, 'char_height') else 1.0
            # ëŒ€ëµì ì¸ ë¬¸ì í­ ê³„ì‚°
            char_width = height * 0.6
            text_length = len(text_val) * char_width
            return text_length, height
            
    except Exception as e:
        return 0.0, 0.0
    
    return 0.0, 0.0

def process_ct_text_positioning(txt, g1_ent, v0, v1, text_angle, common_point, dim_pair, msp):
    """
    CT í…ìŠ¤íŠ¸ ìœ„ì¹˜ ê³„ì‚° ë° ì´ë™ ì²˜ë¦¬
    CPì ì—ì„œ í…ìŠ¤íŠ¸ ë°•ìŠ¤ ì¤‘ì‹¬ê¹Œì§€ì˜ ì§ì„  ê±°ë¦¬ê°€ 2mmê°€ ë˜ë„ë¡ ë°°ì¹˜
    """
    try:
        # DIM1, DIM2 ê¸¸ì´ í™•ì¸
        dim_length = dim_pair['length']
        use_ang_angle = 1.5 <= dim_length <= 2.0
        
        if use_ang_angle:
            # ANG ê°ë„ ê³„ì‚°
            ang_angle = find_parallel_polylines_for_ang(msp, dim_pair)
            final_angle = ang_angle
        else:
            # ê¸°ì¡´ text_angle ì‚¬ìš©
            final_angle = text_angle
        
        # í…ìŠ¤íŠ¸ ë°©í–¥ ë‹¨ìœ„ë²¡í„° ê³„ì‚° (final_angle ê¸°ì¤€)
        text_angle_rad = math.radians(final_angle)
        text_direction = np.array([math.cos(text_angle_rad), math.sin(text_angle_rad)])
        
        # í…ìŠ¤íŠ¸ ê¸¸ì´ ê³„ì‚°
        text_length = get_text_dimensions(txt)[0]
        text_half_length = text_length / 2.0
        
        # í˜„ì¬ í…ìŠ¤íŠ¸ ìœ„ì¹˜ì—ì„œ í…ìŠ¤íŠ¸ ë°•ìŠ¤ ì¤‘ì‹¬ì  ê³„ì‚°
        if txt.dxftype() == "TEXT":
            current_text_start = to2d(txt.dxf.insert)
        elif txt.dxftype() == "MTEXT":
            current_text_start = to2d(txt.dxf.insert)
        else:
            current_text_start = to2d(txt.dxf.insert)
        
        # í˜„ì¬ í…ìŠ¤íŠ¸ ë°•ìŠ¤ì˜ ì¤‘ì‹¬ì  ê³„ì‚°
        current_text_center = current_text_start + text_direction * text_half_length
        
        # CPì—ì„œ í˜„ì¬ í…ìŠ¤íŠ¸ ë°•ìŠ¤ ì¤‘ì‹¬ì ìœ¼ë¡œì˜ ë°©í–¥ ë²¡í„°
        cp_to_text_center_vec = current_text_center - common_point
        cp_to_text_center_distance = np.linalg.norm(cp_to_text_center_vec)
        
        if cp_to_text_center_distance > 0:
            # CPì—ì„œ í…ìŠ¤íŠ¸ ë°•ìŠ¤ ì¤‘ì‹¬ì  ë°©í–¥ì˜ ë‹¨ìœ„ë²¡í„°
            cp_to_text_center_direction = cp_to_text_center_vec / cp_to_text_center_distance
        else:
            # CPì™€ í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì ì´ ê°™ìœ¼ë©´ í…ìŠ¤íŠ¸ ë°©í–¥ì„ ê¸°ë³¸ ë°©í–¥ìœ¼ë¡œ ì‚¬ìš©
            cp_to_text_center_direction = text_direction
        
        # CPì—ì„œ ì •í™•íˆ 1mm ë–¨ì–´ì§„ ê³³ì— í…ìŠ¤íŠ¸ ë°•ìŠ¤ ì¤‘ì‹¬ ë°°ì¹˜
        target_text_center = common_point + cp_to_text_center_direction * 1
        
        # í…ìŠ¤íŠ¸ ì‹œì‘ì  ê³„ì‚° (ë°•ìŠ¤ ì¤‘ì‹¬ì—ì„œ í…ìŠ¤íŠ¸ ë°©í–¥ ë°˜ëŒ€ë¡œ ë°˜ ê¸¸ì´ë§Œí¼)
        final_position = target_text_center - text_direction * text_half_length
        
        # í…ìŠ¤íŠ¸ ì´ë™ ë° íšŒì „ ì²˜ë¦¬
        if txt.dxftype() == "TEXT":
            old_z = float(txt.dxf.insert[2]) if len(txt.dxf.insert) > 2 else 0.0
            txt.dxf.insert = (float(final_position[0]), float(final_position[1]), old_z)
            txt.dxf.halign = 0
            txt.dxf.valign = 0
            try:
                if hasattr(txt.dxf, 'align_point'):
                    delattr(txt.dxf, 'align_point')
            except:
                pass
            txt.dxf.rotation = float(final_angle)
            
        elif txt.dxftype() == "MTEXT":
            old_z = float(txt.dxf.insert[2]) if len(txt.dxf.insert) > 2 else 0.0
            txt.dxf.insert = (float(final_position[0]), float(final_position[1]), old_z)
            txt.dxf.attachment_point = 1
            txt.dxf.rotation = float(final_angle)
            
    except Exception as e:
        # ì—ëŸ¬ ë°œìƒ ì‹œ ê¸°ë³¸ ì²˜ë¦¬
        pass

def process_dimension_system(msp, text_entities):
    """
    DB1, CH1 ì¹˜ìˆ˜ì„  ì‹œìŠ¤í…œ ì²˜ë¦¬ (AD1/AD2 ë³´í˜¸, ë‹¨ìˆœ CT ì´ë™)
    """
    # ğŸš€ ì¿¼ë¦¬ ìµœì í™”: í•œ ë²ˆë§Œ ìŠ¤ìº” í›„ ë¶„ë¥˜
    all_line_entities = list(msp.query("LINE LWPOLYLINE POLYLINE"))
    
    # find_dim_pairs í•¨ìˆ˜ì— ë¯¸ë¦¬ ìŠ¤ìº”ëœ ì—”í‹°í‹° ì „ë‹¬
    dim_pairs, overlapped_entities = find_dim_pairs_optimized(all_line_entities)
    
    all_processed_entities = []
    all_ct_texts = []
    g1_entities_to_delete = []
    ad3_entities_to_delete = []
    
    all_processed_entities.extend(overlapped_entities)
    
    for i, dim_pair in enumerate(dim_pairs):
        dim1 = dim_pair['DIM1']
        dim2 = dim_pair['DIM2']
        dim1_opposite = dim_pair['DIM1_opposite']
        dim2_opposite = dim_pair['DIM2_opposite']
        
        # ì²´ì¸ ë°©í–¥ ê³„ì‚°
        chain_dir = calculate_chain_direction(dim1, dim2)
        text_angle = calculate_text_angle(chain_dir)
        
        # DIM1, DIM2ë¥¼ GREENìœ¼ë¡œ í‘œì‹œ
        dim1.dxf.color = 3
        dim2.dxf.color = 3
        all_processed_entities.extend([dim1, dim2])
        
        # AD1, AD2 ì°¾ê¸° (ìµœì í™”ëœ ë²„ì „)
        ad1_entities = find_arrow_entities_optimized(all_line_entities, dim1_opposite)
        ad2_entities = find_arrow_entities_optimized(all_line_entities, dim2_opposite)
        
        # AD1, AD2ë¥¼ YELLOWë¡œ í‘œì‹œ
        for ad1 in ad1_entities:
            ad1.dxf.color = 2
            all_processed_entities.append(ad1)
        
        for ad2 in ad2_entities:
            ad2.dxf.color = 2
            all_processed_entities.append(ad2)
        
        # AD3 ì°¾ê¸° (ìµœì í™”ëœ ë²„ì „)
        ad3_entities = find_ad3_entities_optimized(all_line_entities, dim_pair, ad1_entities, ad2_entities)
        
        # G1 ì°¾ê¸° (ìµœì í™”ëœ ë²„ì „)
        g1_entities = find_g1_entities_optimized(all_line_entities, dim1, dim2, dim_pair)
        
        # CT ì°¾ê¸° ë° ì²˜ë¦¬
        ct_found = False
        for g1_ent, v0, v1 in g1_entities:
            g1_ent.dxf.color = 1
            all_processed_entities.append(g1_ent)
            g1_entities_to_delete.append(g1_ent)
            
            # CT ì°¾ê¸°
            ct_texts = find_ct_texts(msp, [(g1_ent, v0, v1)], text_entities, dim_pair)
            
            if ct_texts:
                ct_found = True
                for ct in ct_texts:
                    ct.dxf.color = 2
                    all_ct_texts.append(ct)
                    # ë‹¨ìˆœ í…ìŠ¤íŠ¸ ì´ë™ ì²˜ë¦¬
                    process_ct_text_positioning(
                        ct, g1_ent, v0, v1, text_angle, dim_pair['common_point'], dim_pair, msp
                    )
        
        # CTë¥¼ ì°¾ì•˜ì„ ë•Œë§Œ AD3 ì‚­ì œ
        if ct_found:
            for ad3 in ad3_entities:
                ad3.dxf.color = 4
                all_processed_entities.append(ad3)
                ad3_entities_to_delete.append(ad3)
        else:
            for ad3 in ad3_entities:
                ad3.dxf.color = 2
                all_processed_entities.append(ad3)
        
        # DIM1, DIM2 ì„ ë¶„ì— ì ‘í•˜ëŠ” AD3 ì°¾ê¸° ë° ì‚­ì œ ëª©ë¡ì— ì¶”ê°€ (AD1, AD2 ì œì™¸)
        touching_ad3 = find_ad3_touching_dims(all_line_entities, dim1, dim2, ad1_entities, ad2_entities)
        for touching_ad3_ent in touching_ad3:
            if touching_ad3_ent not in ad3_entities_to_delete:
                touching_ad3_ent.dxf.color = 4  # ì‚­ì œ ì˜ˆì • í‘œì‹œ
                all_processed_entities.append(touching_ad3_ent)
                ad3_entities_to_delete.append(touching_ad3_ent)
    
    # ì—”í‹°í‹° ì‚­ì œ
    for ad3_ent in ad3_entities_to_delete:
        try:
            msp.delete_entity(ad3_ent)
        except:
            pass
    
    for g1_ent in g1_entities_to_delete:
        try:
            msp.delete_entity(g1_ent)
        except:
            pass
    
    return all_processed_entities, all_ct_texts


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë©”ì¸ íŒŒì´í”„ë¼ì¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def auto_align_dxf(input_dxf, output_dxf):
    """
    DB1, CH1ë§Œ ì²˜ë¦¬í•˜ëŠ” ë‹¨ì¼ DXF íŒŒì¼ ì²˜ë¦¬ í•¨ìˆ˜ (ë¡œê·¸ ìµœì†Œí™”)
    """
    if not os.path.isfile(input_dxf):
        return False
    
    try:
        doc = ezdxf.readfile(input_dxf)
        msp = doc.modelspace()

        # í…ìŠ¤íŠ¸ ì—”í‹°í‹° ìˆ˜ì§‘
        text_entities = list(msp.query("TEXT MTEXT"))
        
        # DB1, CH1 ì¹˜ìˆ˜ì„  ì‹œìŠ¤í…œ ì²˜ë¦¬
        processed_entities, ct_texts = process_dimension_system(msp, text_entities)

        # ì €ì¥
        doc.saveas(output_dxf)
        
        return True
        
    except Exception as e:
        return False

def process_multiple_files():
    """
    ì—¬ëŸ¬ DXF íŒŒì¼ì„ ì²˜ë¦¬í•˜ëŠ” ë©”ì¸ í•¨ìˆ˜ (ë¡œê·¸ ìµœì†Œí™”)
    """
    selected_files = select_dxf_files()
    
    if not selected_files:
        return
    
    progress_window, progress_var, file_label, progress_text = show_progress_window(len(selected_files))
    
    success_count = 0
    failed_files = []
    
    try:
        for i, input_file in enumerate(selected_files):
            update_progress(progress_window, progress_var, file_label, progress_text, 
                          i, len(selected_files), input_file)
            
            file_dir = os.path.dirname(input_file)
            file_name = os.path.splitext(os.path.basename(input_file))[0]
            output_file = os.path.join(file_dir, f"{file_name}_aligned.dxf")
            
            if auto_align_dxf(input_file, output_file):
                success_count += 1
            else:
                failed_files.append(os.path.basename(input_file))
        
        update_progress(progress_window, progress_var, file_label, progress_text, 
                      len(selected_files), len(selected_files), "ì™„ë£Œ")
        
    finally:
        close_progress_window(progress_window)
    
    # ìµœì¢… ê²°ê³¼ ì¶œë ¥
    print(f"âœ… ì„±ê³µ: {success_count}ê°œ íŒŒì¼")
    if failed_files:
        print(f"âŒ ì‹¤íŒ¨: {len(failed_files)}ê°œ íŒŒì¼")
        for file_name in failed_files:
            print(f"  - {file_name}")
    
    print("í”„ë¡œê·¸ë¨ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")


if __name__ == "__main__":
    if len(sys.argv) == 3:
        auto_align_dxf(sys.argv[1], sys.argv[2])
    else:
        process_multiple_files()