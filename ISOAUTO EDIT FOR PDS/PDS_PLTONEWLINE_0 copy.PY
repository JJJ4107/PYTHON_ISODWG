import ezdxf
from pathlib import Path
import tkinter as tk
from tkinter import filedialog
from typing import List, Tuple, Optional
import math
from dataclasses import dataclass

def has_bulge(ent):
    if ent.dxftype() == 'LWPOLYLINE':
        for x, y, bulge in ent.get_points('xyb'):
            if abs(bulge) > 1e-7:
                return True
        return False
    elif ent.dxftype() == 'POLYLINE':
        for v in ent.vertices:
            if hasattr(v.dxf, 'bulge') and abs(v.dxf.bulge) > 1e-7:
                return True
        return False
    return False

def get_bulge_radius(ent):
    pts = polypoints(ent)
    n = len(pts)
    if n < 2:
        return None

    if ent.dxftype() == 'LWPOLYLINE':
        points = list(ent.get_points('xyb'))
        for idx, (x, y, bulge) in enumerate(points[:-1]):
            if abs(bulge) > 1e-7:
                chord = distance(pts[idx], pts[idx+1])
                theta = 4 * math.atan(abs(bulge))
                if theta == 0:
                    continue
                return abs(chord / (2 * math.sin(theta/2)))
    else:
        verts = list(ent.vertices)
        for idx, v in enumerate(verts[:-1]):
            if hasattr(v.dxf, 'bulge') and abs(v.dxf.bulge) > 1e-7:
                chord = distance(pts[idx], pts[idx+1])
                theta = 4 * math.atan(abs(v.dxf.bulge))
                if theta == 0:
                    continue
                return abs(chord / (2 * math.sin(theta/2)))
    return None

def get_arc_center_from_bulge(p1, p2, bulge):
    """ë‘ ì ê³¼ bulge ê°’ìœ¼ë¡œë¶€í„° í˜¸ì˜ ì¤‘ì‹¬ì ì„ ê³„ì‚°"""
    if abs(bulge) < 1e-7:
        return None
    
    # í˜„ì˜ ì¤‘ì 
    mid_x = (p1[0] + p2[0]) / 2
    mid_y = (p1[1] + p2[1]) / 2
    
    # í˜„ì˜ ê¸¸ì´ì™€ ë°©í–¥
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    chord_length = math.sqrt(dx*dx + dy*dy)
    
    if chord_length < 1e-7:
        return None
    
    # bulgeë¡œë¶€í„° ì¤‘ì‹¬ê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
    theta = 4 * math.atan(abs(bulge))
    radius = chord_length / (2 * math.sin(theta/2))
    
    # sagitta (í˜¸ì˜ ë†’ì´) ê³„ì‚°
    sagitta = radius * (1 - math.cos(theta/2))
    if bulge < 0:
        sagitta = -sagitta
    
    # í˜„ì— ìˆ˜ì§ì¸ ë°©í–¥ ë²¡í„° (ì™¼ìª½ìœ¼ë¡œ 90ë„ íšŒì „)
    perp_x = -dy / chord_length
    perp_y = dx / chord_length
    
    # í˜¸ì˜ ë†’ì´ë¥¼ ê³ ë ¤í•œ ì˜¤í”„ì…‹
    h = radius - sagitta
    
    # ì¤‘ì‹¬ì  ê³„ì‚°
    center_x = mid_x + h * perp_x
    center_y = mid_y + h * perp_y
    
    return (center_x, center_y)

def get_polyline_arc_center_and_radius_with_bulge(ent):
    """bulgeê°€ ìˆëŠ” í´ë¦¬ë¼ì¸ì˜ ì¤‘ì‹¬ì ê³¼ ë°˜ì§€ë¦„ ê³„ì‚°"""
    pts = polypoints(ent)
    
    if ent.dxftype() == 'LWPOLYLINE':
        points = list(ent.get_points('xyb'))
        print(f"  LWPOLYLINE bulge ì •ë³´:")
        for idx, (x, y, bulge) in enumerate(points):
            print(f"    ì {idx+1}: ({x:.3f}, {y:.3f}), bulge={bulge:.6f}")
        
        # ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ í™•ì¸ (ë‹«íŒ í´ë¦¬ë¼ì¸ í¬í•¨)
        for idx in range(len(points)):
            x1, y1, bulge = points[idx]
            # ë‹¤ìŒ ì  (ë§ˆì§€ë§‰ ì ì˜ ê²½ìš° ì²« ë²ˆì§¸ ì ìœ¼ë¡œ)
            next_idx = (idx + 1) % len(points)
            x2, y2, _ = points[next_idx]
            
            if abs(bulge) > 1e-7:
                print(f"  bulge ë°œê²¬: ì {idx+1}â†’ì {next_idx+1}, bulge={bulge:.6f}")
                center = get_arc_center_from_bulge((x1, y1), (x2, y2), bulge)
                if center:
                    radius = distance(center, (x1, y1))
                    print(f"  ê³„ì‚°ëœ ì¤‘ì‹¬: ({center[0]:.3f}, {center[1]:.3f}), ë°˜ì§€ë¦„: {radius:.3f}")
                    return center, radius
    else:  # POLYLINE
        verts = list(ent.vertices)
        print(f"  POLYLINE bulge ì •ë³´:")
        for idx, v in enumerate(verts):
            bulge = v.dxf.bulge if hasattr(v.dxf, 'bulge') else 0
            print(f"    ì {idx+1}: ({v.dxf.location.x:.3f}, {v.dxf.location.y:.3f}), bulge={bulge:.6f}")
        
        # ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ í™•ì¸ (ë‹«íŒ í´ë¦¬ë¼ì¸ í¬í•¨)
        for idx in range(len(verts)):
            v1 = verts[idx]
            # ë‹¤ìŒ ì  (ë§ˆì§€ë§‰ ì ì˜ ê²½ìš° ì²« ë²ˆì§¸ ì ìœ¼ë¡œ)
            next_idx = (idx + 1) % len(verts)
            v2 = verts[next_idx]
            
            if hasattr(v1.dxf, 'bulge') and abs(v1.dxf.bulge) > 1e-7:
                p1 = (v1.dxf.location.x, v1.dxf.location.y)
                p2 = (v2.dxf.location.x, v2.dxf.location.y)
                print(f"  bulge ë°œê²¬: ì {idx+1}â†’ì {next_idx+1}, bulge={v1.dxf.bulge:.6f}")
                center = get_arc_center_from_bulge(p1, p2, v1.dxf.bulge)
                if center:
                    radius = distance(center, p1)
                    print(f"  ê³„ì‚°ëœ ì¤‘ì‹¬: ({center[0]:.3f}, {center[1]:.3f}), ë°˜ì§€ë¦„: {radius:.3f}")
                    return center, radius
    
    print(f"  âš ï¸ bulgeê°€ ìˆëŠ” ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    return None, None

def circle_exists_at_position(msp, center, radius, tolerance=0.1):
    """íŠ¹ì • ìœ„ì¹˜ì— ë™ì¼í•œ ë°˜ì§€ë¦„ì˜ ì›ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    for circle in msp.query('CIRCLE'):
        existing_center = (circle.dxf.center.x, circle.dxf.center.y)
        existing_radius = circle.dxf.radius
        
        # ì¤‘ì‹¬ì ê³¼ ë°˜ì§€ë¦„ì´ ëª¨ë‘ í—ˆìš© ì˜¤ì°¨ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
        center_distance = distance(existing_center, center)
        if (center_distance < tolerance and 
            abs(existing_radius - radius) < tolerance):
            return True
    return False

def centroid(pts):
    return (sum(p[0] for p in pts)/len(pts), sum(p[1] for p in pts)/len(pts))

def scale_triangle(pts, center, scale):
    return [(center[0]+(x-center[0])*scale, center[1]+(y-center[1])*scale) for x,y in pts]

def distance(p1, p2):
    return math.dist(p1, p2)
          
def draw_line(msp, p1, p2, color=7, layer=None):
    attrib = {"color": color}
    if layer:
        attrib["layer"] = layer
    msp.add_line(p1, p2, dxfattribs=attrib)

def polypoints(ent):
    if ent.dxftype()=='LWPOLYLINE':
        return [(pt[0], pt[1]) for pt in ent.get_points('xy')]
    elif ent.dxftype()=='POLYLINE':
        return [(v.dxf.location.x, v.dxf.location.y) for v in ent.vertices]
    return []

def all_pair_distances(pts):
    return [distance(pts[i], pts[i+1]) for i in range(len(pts)-1)]

def line_exists_between_points(msp, p1, p2, tolerance=1e-6):
    """ë‘ ì  ì‚¬ì´ì— ì´ë¯¸ LINEì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    for line in msp.query('LINE'):
        start = (line.dxf.start.x, line.dxf.start.y)
        end = (line.dxf.end.x, line.dxf.end.y)
        
        # ì–‘ë°©í–¥ ëª¨ë‘ ì²´í¬
        if ((abs(start[0] - p1[0]) < tolerance and 
             abs(start[1] - p1[1]) < tolerance and
             abs(end[0] - p2[0]) < tolerance and 
             abs(end[1] - p2[1]) < tolerance) or
            (abs(start[0] - p2[0]) < tolerance and 
             abs(start[1] - p2[1]) < tolerance and
             abs(end[0] - p1[0]) < tolerance and 
             abs(end[1] - p1[1]) < tolerance)):
            return True
    return False

def calculate_polyline_area(points):
    """í´ë¦¬ë¼ì¸ì˜ ë©´ì ì„ ê³„ì‚° (Shoelace formula)"""
    n = len(points)
    if n < 3:
        return 0
    
    area = 0
    for i in range(n):
        j = (i + 1) % n
        area += points[i][0] * points[j][1]
        area -= points[j][0] * points[i][1]
    
    return abs(area) / 2.0

def stretch_entities_in_range(msp, header_x, header_y, stretch_x=39):
    """
    í—¤ë” ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ íŠ¹ì • ë²”ìœ„ ë‚´ì˜ YELLOW TEXTì™€ ë¼ì¸ë“¤ì„ STRETCH
    ë²”ìœ„: X: header_x-5 ~ header_x+170, Y: header_y ~ header_y-250
    STRETCH: ë²”ìœ„ ë‚´ì˜ ì ë“¤ë§Œ ì´ë™, ë²”ìœ„ë¥¼ ê°€ë¡œì§€ë¥´ëŠ” ê°ì²´ëŠ” ëŠ˜ì–´ë‚¨
    """
    # ë²”ìœ„ ì •ì˜
    x_min = header_x - 5
    x_max = header_x + 170
    y_min = header_y - 250
    y_max = header_y
    
    print(f"\nğŸ“ STRETCH ë²”ìœ„:")
    print(f"  X ë²”ìœ„: {x_min:.3f} ~ {x_max:.3f}")
    print(f"  Y ë²”ìœ„: {y_min:.3f} ~ {y_max:.3f}")
    print(f"  STRETCH ê±°ë¦¬: Xì¶• +{stretch_x}mm")
    
    stretched_count = 0
    
    # ì ì´ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
    def point_in_range(x, y):
        return x_min <= x <= x_max and y_min <= y <= y_max
    
    # 1. YELLOW TEXT (color=2) - ì™„ì „íˆ ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ ì´ë™
    for text in msp.query('TEXT'):
        if text.dxf.color == 2:  # YELLOW
            x, y = text.dxf.insert[0], text.dxf.insert[1]
            if point_in_range(x, y):
                text.dxf.insert = (x + stretch_x, y, text.dxf.insert[2] if len(text.dxf.insert) > 2 else 0)
                stretched_count += 1
    
    # 2. LINE STRETCH
    for line in msp.query('LINE'):
        start_x, start_y = line.dxf.start.x, line.dxf.start.y
        end_x, end_y = line.dxf.end.x, line.dxf.end.y
        
        start_in_range = point_in_range(start_x, start_y)
        end_in_range = point_in_range(end_x, end_y)
        
        # ì‹œì‘ì ë§Œ ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ ì‹œì‘ì ë§Œ ì´ë™ (STRETCH)
        if start_in_range and not end_in_range:
            line.dxf.start = (start_x + stretch_x, start_y, line.dxf.start.z)
            stretched_count += 1
        # ëì ë§Œ ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ ëì ë§Œ ì´ë™ (STRETCH)
        elif not start_in_range and end_in_range:
            line.dxf.end = (end_x + stretch_x, end_y, line.dxf.end.z)
            stretched_count += 1
        # ì–‘ìª½ ëª¨ë‘ ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ ì „ì²´ ì´ë™
        elif start_in_range and end_in_range:
            line.dxf.start = (start_x + stretch_x, start_y, line.dxf.start.z)
            line.dxf.end = (end_x + stretch_x, end_y, line.dxf.end.z)
            stretched_count += 1
    
    # 3. POLYLINE, LWPOLYLINE STRETCH
    for ent in msp:
        if ent.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
            modified = False
            
            if ent.dxftype() == 'LWPOLYLINE':
                # LWPOLYLINEì˜ ê²½ìš°
                new_points = []
                for x, y, *rest in ent.get_points('xyb'):
                    if point_in_range(x, y):
                        new_points.append((x + stretch_x, y) + tuple(rest))
                        modified = True
                    else:
                        new_points.append((x, y) + tuple(rest))
                if modified:
                    ent.set_points(new_points)
                    stretched_count += 1
            else:
                # POLYLINEì˜ ê²½ìš°
                for vertex in ent.vertices:
                    loc = vertex.dxf.location
                    if point_in_range(loc.x, loc.y):
                        vertex.dxf.location = (loc.x + stretch_x, loc.y, loc.z)
                        modified = True
                if modified:
                    stretched_count += 1
    
    # 4. ARC STRETCH - ì¤‘ì‹¬ì ì´ ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ ì´ë™
    for arc in msp.query('ARC'):
        center_x, center_y = arc.dxf.center.x, arc.dxf.center.y
        if point_in_range(center_x, center_y):
            arc.dxf.center = (center_x + stretch_x, center_y, arc.dxf.center.z)
            stretched_count += 1
    
    # 5. CIRCLE STRETCH - ì¤‘ì‹¬ì ì´ ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ ì´ë™
    for circle in msp.query('CIRCLE'):
        center_x, center_y = circle.dxf.center.x, circle.dxf.center.y
        if point_in_range(center_x, center_y):
            circle.dxf.center = (center_x + stretch_x, center_y, circle.dxf.center.z)
            stretched_count += 1
    
    print(f"âœ… ì´ {stretched_count}ê°œì˜ ì—”í‹°í‹°ë¥¼ STRETCHí–ˆìŠµë‹ˆë‹¤.")

def find_and_process_weld_header(msp):
    """
    WELD SHOP WELD WELD í—¤ë”ë¥¼ ì°¾ì•„ì„œ ê´€ë ¨ ë¼ì¸ë“¤ì„ ì²˜ë¦¬
    """
    print("\nğŸ” WELD í—¤ë” ì²˜ë¦¬ ì‹œì‘...")
    
    # ë””ë²„ê¹…ì„ ìœ„í•´ ëª¨ë“  í…ìŠ¤íŠ¸ ì¶œë ¥
    print("\nğŸ“ ë„ë©´ ë‚´ ëª¨ë“  í…ìŠ¤íŠ¸ í™•ì¸:")
    all_texts = []
    for text in msp.query('TEXT'):
        if text.dxf.text:
            all_texts.append(text)
            # WELD ë˜ëŠ” SHOPì´ í¬í•¨ëœ í…ìŠ¤íŠ¸ë§Œ ì¶œë ¥
            if 'WELD' in text.dxf.text.upper() or 'SHOP' in text.dxf.text.upper():
                print(f"   í…ìŠ¤íŠ¸: '{text.dxf.text}' at X={text.dxf.insert[0]:.1f}, Y={text.dxf.insert[1]:.1f}")
    
    # 1. ë‹¤ì–‘í•œ ë°©ë²•ìœ¼ë¡œ WELD íŒ¨í„´ ì°¾ê¸°
    first_weld = None
    pattern_found = False
    
    # ë°©ë²• 1: í•œ ì¤„ì— ì „ì²´ íŒ¨í„´ì´ ìˆëŠ” ê²½ìš°
    for text in all_texts:
        text_upper = text.dxf.text.upper()
        # ê³µë°±ì„ ì œê±°í•˜ê±°ë‚˜ ì¶•ì†Œí•˜ì—¬ ë¹„êµ
        text_compressed = ' '.join(text_upper.split())
        
        if 'WELD' in text_compressed and 'SHOP' in text_compressed:
            # WELD SHOP WELD WELD ìˆœì„œ í™•ì¸
            if text_compressed.count('WELD') >= 3 and 'WELD SHOP' in text_compressed:
                first_weld = text
                pattern_found = True
                print(f"âœ… í•œ ì¤„ì—ì„œ WELD íŒ¨í„´ ë°œê²¬: '{text.dxf.text}'")
                break
    
    # ë°©ë²• 2: ê°œë³„ í…ìŠ¤íŠ¸ë¡œ ë‚˜ë‰˜ì–´ ìˆëŠ” ê²½ìš°
    if not pattern_found:
        # Y ì¢Œí‘œë¡œ ê·¸ë£¹í™” (ê°™ì€ ì¤„ì— ìˆëŠ” í…ìŠ¤íŠ¸ë“¤)
        y_groups = {}
        for text in all_texts:
            y = round(text.dxf.insert[1], 1)  # 0.1 ë‹¨ìœ„ë¡œ ë°˜ì˜¬ë¦¼
            if y not in y_groups:
                y_groups[y] = []
            y_groups[y].append(text)
        
        # ê° ê·¸ë£¹ì—ì„œ WELD SHOP WELD WELD íŒ¨í„´ ì°¾ê¸°
        for y, texts in y_groups.items():
            # X ì¢Œí‘œë¡œ ì •ë ¬
            texts.sort(key=lambda t: t.dxf.insert[0])
            
            # í…ìŠ¤íŠ¸ ë‚´ìš© ì—°ê²°
            combined = ' '.join([t.dxf.text.upper().strip() for t in texts])
            
            # íŒ¨í„´ í™•ì¸
            if 'WELD' in combined and 'SHOP' in combined:
                words = combined.split()
                # WELD SHOP WELD WELD ìˆœì„œ ì°¾ê¸°
                for i in range(len(words) - 3):
                    if (words[i] == 'WELD' and 
                        words[i+1] == 'SHOP' and 
                        words[i+2] == 'WELD' and 
                        i+3 < len(words) and words[i+3] == 'WELD'):
                        # ì²« ë²ˆì§¸ WELD ì°¾ê¸°
                        for t in texts:
                            if 'WELD' in t.dxf.text.upper():
                                first_weld = t
                                pattern_found = True
                                print(f"âœ… ê°œë³„ í…ìŠ¤íŠ¸ì—ì„œ WELD íŒ¨í„´ ë°œê²¬!")
                                print(f"   Y={y}ì—ì„œ ë°œê²¬: {combined}")
                                break
                        break
                if pattern_found:
                    break
    
    # ë°©ë²• 3: ë” ìœ ì—°í•œ ê²€ìƒ‰ (WELDê°€ 3ê°œ ì´ìƒ, SHOPì´ 1ê°œ ì´ìƒ)
    if not pattern_found:
        print("\nğŸ’¡ ìœ ì—°í•œ ê²€ìƒ‰ ì‹œë„...")
        for y, texts in y_groups.items():
            combined = ' '.join([t.dxf.text.upper().strip() for t in texts])
            weld_count = combined.count('WELD')
            shop_count = combined.count('SHOP')
            
            if weld_count >= 3 and shop_count >= 1:
                # ì²« ë²ˆì§¸ WELD í…ìŠ¤íŠ¸ ì°¾ê¸°
                for t in texts:
                    if 'WELD' in t.dxf.text.upper():
                        first_weld = t
                        pattern_found = True
                        print(f"âœ… ìœ ì—°í•œ ê²€ìƒ‰ìœ¼ë¡œ íŒ¨í„´ ë°œê²¬!")
                        print(f"   Y={y}ì—ì„œ WELD {weld_count}ê°œ, SHOP {shop_count}ê°œ")
                        break
                if pattern_found:
                    break
    
    if not first_weld:
        print("âš ï¸ WELD íŒ¨í„´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        print("   ê°€ëŠ¥í•œ ì›ì¸:")
        print("   - í…ìŠ¤íŠ¸ê°€ ë‹¤ë¥¸ ë ˆì´ì–´ì— ìˆìŒ")
        print("   - ëŒ€ì†Œë¬¸ìë‚˜ ê³µë°± ë¬¸ì œ")
        print("   - WELD/SHOP í…ìŠ¤íŠ¸ê°€ ë„ë©´ì— ì—†ìŒ")
        return
    
    # 2. ì²« ë²ˆì§¸ WELD ìœ„ë¡œ ìˆ«ì í…ìŠ¤íŠ¸ ì°¾ê¸°
    weld_y = first_weld.dxf.insert[1]
    weld_x = first_weld.dxf.insert[0]
    
    print(f"\nğŸ“ ì²« ë²ˆì§¸ WELD ìœ„ì¹˜: X={weld_x:.3f}, Y={weld_y:.3f}")
    
    numeric_texts = []
    for text in msp.query('TEXT'):
        if text.dxf.text:
            # ìˆ«ì íŒë³„ì„ ë” ìœ ì—°í•˜ê²Œ
            text_content = text.dxf.text.strip()
            # ìˆ«ì, ì , ëŒ€ì‹œ, ê³µë°± ì œê±° í›„ ìˆ«ìì¸ì§€ í™•ì¸
            cleaned = text_content.replace('.', '').replace('-', '').replace(' ', '')
            
            if cleaned and (cleaned.isdigit() or 
                           (cleaned.replace(',', '').isdigit()) or  # ì‰¼í‘œ í¬í•¨
                           (text_content.count('.') <= 1 and cleaned.replace('.', '').isdigit())):  # ì†Œìˆ˜ì 
                
                text_x = text.dxf.insert[0]
                text_y = text.dxf.insert[1]
                
                # WELD ìœ„ìª½, Xì¶• ê·¼ì²˜
                if (text_y > weld_y and 
                    abs(text_x - weld_x) < 10 and  # X ë²”ìœ„ Â±10mmë¡œ ì¶•ì†Œ
                    text_y - weld_y < 200):  # Y ë²”ìœ„ í™•ëŒ€
                    numeric_texts.append((text_y, text))
                    print(f"   ìˆ«ì í…ìŠ¤íŠ¸ ë°œê²¬: '{text_content}' at Y={text_y:.3f}")
    
    if not numeric_texts:
        print("âš ï¸ WELD ìœ„ì— ìˆ«ì í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        print("   í•˜ì§€ë§Œ ì‘ì—…ì„ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤...")
        # ìˆ«ì í…ìŠ¤íŠ¸ê°€ ì—†ì–´ë„ WELD Y ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê³„ì† ì§„í–‰
        top_text_y = weld_y + 10  # WELD ìœ„ 10mmë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
    else:
        # Yê°’ìœ¼ë¡œ ì •ë ¬
        numeric_texts.sort(key=lambda x: x[0])
        print(f"\nâœ… ìˆ«ì í…ìŠ¤íŠ¸ {len(numeric_texts)}ê°œ ë°œê²¬")
        top_text_y = numeric_texts[-1][0]
    
    # 3. ê°€ì¥ ìœ„ ìˆ«ì í…ìŠ¤íŠ¸ + Y ë°©í–¥ìœ¼ë¡œ 60mm ì´í•˜ì˜ ì²« ë²ˆì§¸ ìˆ˜í‰ì„  ì°¾ê¸°
    bline = None
    horizontal_lines = []
    
    # ëª¨ë“  ìˆ˜í‰ì„  ê²€ìƒ‰ (ë‹¤ë¥¸ ê°ì²´ê°€ ìˆì–´ë„ ê³„ì†)
    print("\nğŸ” ìˆ˜í‰ì„  ê²€ìƒ‰ ì¤‘...")
    for line in msp.query('LINE'):
        try:
            start_x, start_y = line.dxf.start.x, line.dxf.start.y
            end_x, end_y = line.dxf.end.x, line.dxf.end.y
            
            # ìˆ˜í‰ì„ ì¸ì§€ í™•ì¸ (Y ì¢Œí‘œê°€ ê±°ì˜ ê°™ìŒ)
            if abs(start_y - end_y) < 0.1:
                line_length = abs(end_x - start_x)
                # 60mm ì´í•˜ì´ê³  ê¸°ì¤€ì  ìœ„ì— ìˆëŠ” ë¼ì¸
                if line_length <= 60 and start_y > top_text_y:
                    horizontal_lines.append((start_y, line, line_length))
                    print(f"   ìˆ˜í‰ì„  ë°œê²¬: Y={start_y:.3f}, ê¸¸ì´={line_length:.3f}mm")
        except Exception as e:
            print(f"   ë¼ì¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œí•˜ê³  ê³„ì†): {e}")
            continue
    
    if horizontal_lines:
        # Yê°’ì´ ê°€ì¥ ì‘ì€ (ê°€ì¥ ì•„ë˜) ìˆ˜í‰ì„ ì„ BLINEìœ¼ë¡œ
        horizontal_lines.sort(key=lambda x: x[0])
        bline = horizontal_lines[0][1]
        bline_y = horizontal_lines[0][0]
        bline_length = horizontal_lines[0][2]
        
        # BLINEì˜ ë ˆì´ì–´ë¥¼ 'BLINE'ìœ¼ë¡œ ë³€ê²½
        try:
            bline.dxf.layer = 'BLINE'
            print(f"âœ… BLINE ë°œê²¬ ë° ë ˆì´ì–´ ë³€ê²½: Y={bline_y:.3f}, ê¸¸ì´={bline_length:.3f}mm")
        except Exception as e:
            print(f"âš ï¸ BLINE ë ˆì´ì–´ ë³€ê²½ ì‹¤íŒ¨: {e}")
    else:
        print("âš ï¸ ì¡°ê±´ì— ë§ëŠ” BLINEì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        print("   BLINE ê´€ë ¨ ì‘ì—…ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
        return
    
    # 4. BLINEì— ìˆ˜ì§ìœ¼ë¡œ êµì°¨í•˜ëŠ” ë¼ì¸ ì°¾ê¸° (ì¢Œì¸¡ë¶€í„° 4ê°œ)
    bline_start_x = min(bline.dxf.start.x, bline.dxf.end.x)
    bline_end_x = max(bline.dxf.start.x, bline.dxf.end.x)
    bline_y = bline.dxf.start.y
    
    print(f"\nğŸ“ BLINE ë²”ìœ„: X={bline_start_x:.3f} ~ {bline_end_x:.3f}, Y={bline_y:.3f}")
    
    vertical_lines = []
    all_vertical_count = 0
    
    print("\nğŸ” ìˆ˜ì§ì„  ê²€ìƒ‰ ì¤‘...")
    for line in msp.query('LINE'):
        try:
            start_x, start_y = line.dxf.start.x, line.dxf.start.y
            end_x, end_y = line.dxf.end.x, line.dxf.end.y
            
            # ìˆ˜ì§ì„ ì¸ì§€ í™•ì¸ (X ì¢Œí‘œê°€ ê±°ì˜ ê°™ìŒ)
            if abs(start_x - end_x) < 0.1:
                all_vertical_count += 1
                x_pos = start_x
                
                # ë””ë²„ê¹…ì„ ìœ„í•œ ìƒì„¸ ì •ë³´
                if bline_start_x - 10 <= x_pos <= bline_end_x + 10:  # ë²”ìœ„ë¥¼ ì•½ê°„ í™•ëŒ€í•˜ì—¬ í™•ì¸
                    print(f"   í›„ë³´ ìˆ˜ì§ì„ : X={x_pos:.3f}, Y={min(start_y, end_y):.3f}~{max(start_y, end_y):.3f}")
                
                # BLINEê³¼ êµì°¨í•˜ëŠ”ì§€ í™•ì¸ (í—ˆìš© ì˜¤ì°¨ ì¶”ê°€)
                tolerance = 0.5  # êµì°¨ íŒë‹¨ í—ˆìš© ì˜¤ì°¨
                if (bline_start_x - tolerance <= x_pos <= bline_end_x + tolerance and 
                    min(start_y, end_y) <= bline_y <= max(start_y, end_y)):
                    vertical_lines.append((x_pos, line))
                    print(f"   âœ… êµì°¨í•˜ëŠ” ìˆ˜ì§ì„  ë°œê²¬: X={x_pos:.3f}")
        except Exception as e:
            print(f"   ìˆ˜ì§ì„  ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œí•˜ê³  ê³„ì†): {e}")
            continue
    
    print(f"   ì „ì²´ ìˆ˜ì§ì„  ìˆ˜: {all_vertical_count}ê°œ")
    
    # X ì¢Œí‘œë¡œ ì •ë ¬ (ì¢Œì¸¡ë¶€í„°)
    vertical_lines.sort(key=lambda x: x[0])
    
    # ì²˜ìŒ 4ê°œë§Œ ì„ íƒ
    selected_verticals = vertical_lines[:4]
    print(f"âœ… ìˆ˜ì§ì„  {len(selected_verticals)}ê°œ ì„ íƒ")
    
    if len(selected_verticals) == 0:
        print("   âš ï¸ BLINEê³¼ êµì°¨í•˜ëŠ” ìˆ˜ì§ì„ ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
        print("   ê°€ëŠ¥í•œ ì›ì¸:")
        print("   - BLINEì´ ë„ˆë¬´ ì§§ìŒ (7.225mm)")
        print("   - ìˆ˜ì§ì„ ì´ BLINE ë†’ì´ì— ë„ë‹¬í•˜ì§€ ì•ŠìŒ")
        print("   - ìˆ˜ì§ì„ ì´ BLINEì˜ X ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨")
    
    # 5. ì„ íƒëœ 4ê°œ ìˆ˜ì§ì„ ì˜ BLINE ì•„ë˜ ë¶€ë¶„ë§Œ ë‚¨ê¸°ë„ë¡ TRIM (ë°˜ëŒ€ë¡œ ìˆ˜ì •)
    trim_count = 0
    for x_pos, line in selected_verticals:
        try:
            start_y = line.dxf.start.y
            end_y = line.dxf.end.y
            
            # BLINE ì•„ë˜ìª½ ë¶€ë¶„ë§Œ ë‚¨ê¸°ë„ë¡ ìˆ˜ì •
            if start_y < bline_y < end_y:
                # ìœ„ìª½ ëì ì„ BLINE ìœ„ì¹˜ë¡œ ìˆ˜ì • (ì•„ë˜ ë¶€ë¶„ë§Œ ë‚¨ê¹€)
                line.dxf.end = (line.dxf.end.x, bline_y, line.dxf.end.z)
                trim_count += 1
                print(f"   ìˆ˜ì§ì„  TRIM ì„±ê³µ: X={x_pos:.3f} (ì•„ë˜ ë¶€ë¶„ ìœ ì§€)")
            elif end_y < bline_y < start_y:
                # ì•„ë˜ìª½ ëì ì„ BLINE ìœ„ì¹˜ë¡œ ìˆ˜ì • (ì•„ë˜ ë¶€ë¶„ë§Œ ë‚¨ê¹€)
                line.dxf.start = (line.dxf.start.x, bline_y, line.dxf.start.z)
                trim_count += 1
                print(f"   ìˆ˜ì§ì„  TRIM ì„±ê³µ: X={x_pos:.3f} (ì•„ë˜ ë¶€ë¶„ ìœ ì§€)")
        except Exception as e:
            print(f"   ìˆ˜ì§ì„  TRIM ì‹¤íŒ¨ (ë¬´ì‹œí•˜ê³  ê³„ì†): {e}")
            continue
    
    print(f"âœ… {trim_count}ê°œì˜ ìˆ˜ì§ì„  TRIM ì™„ë£Œ")
    
    # 6. BLINEê³¼ ìœ ì‚¬í•œ ìœ„ì¹˜ì˜ ë¼ì¸ë“¤ ì°¾ì•„ì„œ ì‚­ì œ (ë²”ìœ„ í™•ëŒ€)
    lines_to_delete = []
    line_info = []  # ì‚­ì œí•  ë¼ì¸ì˜ ì •ë³´ë¥¼ ë¯¸ë¦¬ ì €ì¥
    
    print("\nğŸ” ì‚­ì œí•  ìˆ˜í‰ì„  ê²€ìƒ‰ ì¤‘...")
    print(f"   BLINE ì •ë³´: Y={bline_y:.3f}, X={bline_start_x:.3f}~{bline_end_x:.3f}, ê¸¸ì´={bline_length:.3f}mm")
    
    # ë¨¼ì € BLINEê³¼ ë™ì¼í•œ X ë²”ìœ„ë¥¼ ê°€ì§„ ëª¨ë“  ìˆ˜í‰ì„  ì°¾ê¸°
    for line in msp.query('LINE'):
        try:
            if line == bline:  # BLINEì€ ì œì™¸
                continue
                
            start_x, start_y = line.dxf.start.x, line.dxf.start.y
            end_x, end_y = line.dxf.end.x, line.dxf.end.y
            
            # ìˆ˜í‰ì„ ì´ê³  BLINE ìœ„ìª½ì— ìˆëŠ”ì§€ í™•ì¸
            if (abs(start_y - end_y) < 0.1 and  # ìˆ˜í‰ì„ 
                start_y > bline_y):  # BLINE ìœ„ìª½ (ê±°ë¦¬ ì œí•œ ì—†ìŒ)
                
                # BLINEê³¼ X ë²”ìœ„ê°€ ë¹„ìŠ·í•œì§€ í™•ì¸
                line_start_x = min(start_x, end_x)
                line_end_x = max(start_x, end_x)
                line_length = abs(end_x - start_x)
                
                # BLINEê³¼ ê¸¸ì´ê°€ ë¹„ìŠ·í•˜ê³  X ë²”ìœ„ê°€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
                if (abs(line_length - bline_length) < 5 and  # ê¸¸ì´ ì°¨ì´ 5mm ì´ë‚´
                    line_start_x <= bline_end_x and line_end_x >= bline_start_x):  # X ë²”ìœ„ ê²¹ì¹¨
                    
                    # Y ê°„ê²© í™•ì¸ (6-7mm ê°„ê²©ì˜ ë°°ìˆ˜ì¸ì§€)
                    y_gap = start_y - bline_y
                    
                    # 6-7mm ê°„ê²©ìœ¼ë¡œ ë°˜ë³µë˜ëŠ” ëª¨ë“  ë¼ì¸ ì°¾ê¸°
                    gap_interval = 6.5  # í‰ê·  ê°„ê²©
                    tolerance = 1.5  # í—ˆìš© ì˜¤ì°¨
                    
                    # gapì´ 6.5ì˜ ë°°ìˆ˜ì— ê°€ê¹Œìš´ì§€ í™•ì¸
                    if y_gap > 0:
                        multiple = round(y_gap / gap_interval)
                        expected_y = bline_y + (multiple * gap_interval)
                        
                        if abs(start_y - expected_y) < tolerance:
                            lines_to_delete.append(line)
                            line_info.append({'y': start_y, 'gap': y_gap})
                            print(f"   ì‚­ì œ ëŒ€ìƒ ë¼ì¸ ë°œê²¬: Y={start_y:.3f} (BLINE+{y_gap:.1f}mm)")
        except Exception as e:
            print(f"   ë¼ì¸ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œí•˜ê³  ê³„ì†): {e}")
            continue
    
    # ì¶”ê°€ë¡œ BLINEê³¼ ì •í™•íˆ ê°™ì€ ê¸¸ì´ì™€ X ìœ„ì¹˜ë¥¼ ê°€ì§„ ë¼ì¸ ì°¾ê¸°
    for line in msp.query('LINE'):
        try:
            if line == bline or line in lines_to_delete:  # ì´ë¯¸ ì²˜ë¦¬ëœ ë¼ì¸ ì œì™¸
                continue
                
            start_x, start_y = line.dxf.start.x, line.dxf.start.y
            end_x, end_y = line.dxf.end.x, line.dxf.end.y
            
            # ìˆ˜í‰ì„ ì´ê³  BLINEê³¼ ì •í™•íˆ ê°™ì€ X ì¢Œí‘œë¥¼ ê°€ì§„ ê²½ìš°
            if (abs(start_y - end_y) < 0.1 and  # ìˆ˜í‰ì„ 
                abs(start_x - bline.dxf.start.x) < 0.1 and  # ì‹œì‘ X ë™ì¼
                abs(end_x - bline.dxf.end.x) < 0.1 and  # ë X ë™ì¼
                start_y > bline_y):  # BLINE ìœ„ìª½
                
                # ì´ë¯¸ ë¦¬ìŠ¤íŠ¸ì— ì—†ëŠ” ê²½ìš°ë§Œ ì¶”ê°€
                already_exists = False
                for existing_line in lines_to_delete:
                    if existing_line == line:
                        already_exists = True
                        break
                
                if not already_exists:
                    lines_to_delete.append(line)
                    y_gap = start_y - bline_y
                    line_info.append({'y': start_y, 'gap': y_gap})
                    print(f"   ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ë¼ì¸ ë°œê²¬: Y={start_y:.3f} (BLINE+{y_gap:.1f}mm)")
        except Exception as e:
            print(f"   ë¼ì¸ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œí•˜ê³  ê³„ì†): {e}")
            continue
    
    # ë¼ì¸ ì‚­ì œ
    print(f"\nğŸ—‘ï¸ ì´ {len(lines_to_delete)}ê°œì˜ ë¼ì¸ ì‚­ì œ ì˜ˆì •")
    deleted_count = 0
    for i, line in enumerate(lines_to_delete):
        try:
            # ì‚­ì œí•˜ê¸° ì „ì— ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            info = line_info[i] if i < len(line_info) else {'y': 0, 'gap': 0}
            msp.delete_entity(line)
            deleted_count += 1
            print(f"   ë¼ì¸ ì‚­ì œ ì™„ë£Œ: Y={info['y']:.3f} (BLINE+{info['gap']:.1f}mm)")
        except Exception as e:
            print(f"   ë¼ì¸ ì‚­ì œ ì‹¤íŒ¨ (ë¬´ì‹œí•˜ê³  ê³„ì†): {e}")
    
    print(f"âœ… {deleted_count}ê°œì˜ ë¼ì¸ ì‹¤ì œ ì‚­ì œ ì™„ë£Œ")
    print(f"\nâœ… WELD í—¤ë” ì²˜ë¦¬ ì™„ë£Œ!")

def process_pl97_and_pl31(msp):
    """
    PL97 ë ˆì´ì–´ ì²˜ë¦¬ ë° PL31 ë©´ì  ê¸°ë°˜ ì‚­ì œ
    """
    print("\nğŸ” PL97 ë° PL31 ë ˆì´ì–´ ì²˜ë¦¬ ì‹œì‘...")
    
    # 1. PL97 ë ˆì´ì–´ ì°¾ê¸°
    pl97_entities = []
    for ent in msp:
        if ent.dxftype() in ['LWPOLYLINE', 'POLYLINE'] and ent.dxf.layer == 'PL97':
            pl97_entities.append(ent)
    
    if not pl97_entities:
        print("âš ï¸ PL97 ë ˆì´ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    else:
        print(f"âœ… PL97 ë ˆì´ì–´ {len(pl97_entities)}ê°œ ë°œê²¬")
        
        # ê° PL97 ì—”í‹°í‹° ì²˜ë¦¬
        for idx, ent in enumerate(pl97_entities):
            pts = polypoints(ent)
            if pts:
                # ì¤‘ì‹¬ì  ê³„ì‚°
                center = centroid(pts)
                print(f"\n   PL97 #{idx+1} ì¤‘ì‹¬: ({center[0]:.3f}, {center[1]:.3f})")
                
                # ë‹¤ì–‘í•œ ì§€ë¦„ì˜ ì› ê·¸ë¦¬ê¸°
                diameters = [2.5, 2.0, 1.5, 1.0, 0.5]
                for diameter in diameters:
                    radius = diameter / 2.0
                    try:
                        circle = msp.add_circle(
                            center=center,
                            radius=radius,
                            dxfattribs={'layer': 'WELD', 'color': 2}  # YELLOW
                        )
                        print(f"   âœ… ì§€ë¦„ {diameter}mm ì› ì¶”ê°€ (ë°˜ì§€ë¦„ {radius}mm)")
                    except Exception as e:
                        print(f"   âŒ ì§€ë¦„ {diameter}mm ì› ì¶”ê°€ ì‹¤íŒ¨: {e}")
                
                # PL97 ì‚­ì œ
                try:
                    msp.delete_entity(ent)
                    print(f"   âœ… PL97 ì—”í‹°í‹° ì‚­ì œ ì™„ë£Œ")
                except Exception as e:
                    print(f"   âŒ PL97 ì‚­ì œ ì‹¤íŒ¨: {e}")
    
    # 2. PL31 ë ˆì´ì–´ì—ì„œ ë©´ì  3.9 ì´í•˜ì¸ ì—”í‹°í‹° ì°¾ì•„ ì‚­ì œ
    print("\nğŸ” PL31 ë ˆì´ì–´ ë©´ì  ê¸°ë°˜ ì‚­ì œ...")
    pl31_to_delete = []
    
    for ent in msp:
        if ent.dxftype() in ['LWPOLYLINE', 'POLYLINE'] and ent.dxf.layer == 'PL31':
            pts = polypoints(ent)
            if len(pts) >= 3:  # ë©´ì  ê³„ì‚°ì´ ê°€ëŠ¥í•œ ê²½ìš°
                area = calculate_polyline_area(pts)
                print(f"   PL31 ë°œê²¬: ì  {len(pts)}ê°œ, ë©´ì  {area:.3f}")
                
                if area <= 3.9:
                    pl31_to_delete.append(ent)
                    print(f"   âœ… ì‚­ì œ ëŒ€ìƒ (ë©´ì  {area:.3f} â‰¤ 3.9)")
    
    # PL31 ì‚­ì œ
    if pl31_to_delete:
        print(f"\nğŸ—‘ï¸ ë©´ì  3.9 ì´í•˜ì¸ PL31 {len(pl31_to_delete)}ê°œ ì‚­ì œ")
        for ent in pl31_to_delete:
            try:
                msp.delete_entity(ent)
                print(f"   âœ… PL31 ì‚­ì œ ì™„ë£Œ")
            except Exception as e:
                print(f"   âŒ PL31 ì‚­ì œ ì‹¤íŒ¨: {e}")
    else:
        print("   ë©´ì  3.9 ì´í•˜ì¸ PL31ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

def calculate_line_angle(start, end):
    """ë¼ì¸ì˜ ê¸°ìš¸ê¸°ë¥¼ ê³„ì‚° (0~360ë„)"""
    dx = end[0] - start[0]
    dy = end[1] - start[1]
    
    if abs(dx) < 1e-10 and abs(dy) < 1e-10:  # ì‹œì‘ì ê³¼ ëì ì´ ê°™ì€ ê²½ìš°
        return None
    
    # atan2ëŠ” -Ï€ ~ Ï€ ë²”ìœ„ë¥¼ ë°˜í™˜, ì´ë¥¼ 0~360ë„ë¡œ ë³€í™˜
    angle_rad = math.atan2(dy, dx)
    angle_deg = math.degrees(angle_rad)
    
    # 0~360ë„ ë²”ìœ„ë¡œ ì •ê·œí™”
    if angle_deg < 0:
        angle_deg += 360
    
    return angle_deg

def process_layer3_lines_and_texts(msp):
    """ë ˆì´ì–´ 3ì¸ LINEê³¼ TEXT ì²˜ë¦¬"""
    print("\nğŸ” ë ˆì´ì–´ 3 LINE ë° TEXT ì²˜ë¦¬ ì‹œì‘...")
    
    # ISO ë„ë©´ í‘œì¤€ ê°ë„ë“¤ (30ë„ ê°„ê²©)
    iso_angles = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330]
    angle_tolerance = 1.0  # ê°ë„ í—ˆìš© ì˜¤ì°¨ (Â±1ë„)
    
    # 1. ë ˆì´ì–´ 3ì¸ LINE ì²˜ë¦¬
    dim_count = 0
    g1_count = 0
    
    for line in msp.query('LINE'):
        if line.dxf.layer == '3':
            start = (line.dxf.start.x, line.dxf.start.y)
            end = (line.dxf.end.x, line.dxf.end.y)
            
            angle = calculate_line_angle(start, end)
            if angle is not None:
                # ISO ê°ë„ì¸ì§€ í™•ì¸
                is_iso_angle = False
                for iso_angle in iso_angles:
                    # ê°ë„ ì°¨ì´ ê³„ì‚° (0ë„ì™€ 360ë„ ê·¼ì²˜ ì²˜ë¦¬)
                    angle_diff = abs(angle - iso_angle)
                    if angle_diff > 180:
                        angle_diff = 360 - angle_diff
                    
                    if angle_diff <= angle_tolerance:
                        is_iso_angle = True
                        break
                
                if is_iso_angle:
                    line.dxf.layer = 'DIM'
                    dim_count += 1
                    print(f"   LINE ê°ë„ {angle:.1f}Â° â†’ DIM ë ˆì´ì–´")
                else:
                    line.dxf.layer = 'G1'
                    g1_count += 1
                    print(f"   LINE ê°ë„ {angle:.1f}Â° â†’ G1 ë ˆì´ì–´")
    
    print(f"âœ… DIM ë ˆì´ì–´ë¡œ ë³€ê²½: {dim_count}ê°œ")
    print(f"âœ… G1 ë ˆì´ì–´ë¡œ ë³€ê²½: {g1_count}ê°œ")
    
    # 2. ë ˆì´ì–´ 3ì´ê³  ê¸°ìš¸ê¸° 0ì¸ ìˆ«ì TEXT ì²˜ë¦¬
    cp_count = 0
    
    for text in msp.query('TEXT'):
        if text.dxf.layer == '3':
            # í…ìŠ¤íŠ¸ ë‚´ìš©ì´ ìˆ«ìì¸ì§€ í™•ì¸
            text_content = text.dxf.text.strip()
            cleaned = text_content.replace('.', '').replace('-', '').replace(' ', '').replace(',', '')
            
            is_numeric = False
            if cleaned and (cleaned.isdigit() or 
                           (text_content.count('.') <= 1 and cleaned.isdigit())):
                is_numeric = True
            
            if is_numeric:
                # í…ìŠ¤íŠ¸ íšŒì „ ê°ë„ í™•ì¸ (ê¸°ë³¸ê°’ 0)
                rotation = text.dxf.rotation if hasattr(text.dxf, 'rotation') else 0
                
                # 0ë„ ë˜ëŠ” 360ë„ ê·¼ì²˜ì¸ì§€ í™•ì¸ (í—ˆìš© ì˜¤ì°¨ Â±1ë„)
                if abs(rotation) <= 1.0 or abs(rotation - 360) <= 1.0:
                    text.dxf.layer = 'CP'
                    cp_count += 1
                    print(f"   ìˆ«ì TEXT '{text_content}' ê¸°ìš¸ê¸° {rotation:.1f}Â° â†’ CP ë ˆì´ì–´")
    
    print(f"âœ… CP ë ˆì´ì–´ë¡œ ë³€ê²½: {cp_count}ê°œ")

def process_red_dim_lines(msp, doc):
    """ìƒ‰ìƒì´ REDì´ê³  ë ˆì´ì–´ê°€ DIMì¸ LINE ì²˜ë¦¬"""
    print("\nğŸ” RED ìƒ‰ìƒ DIM ë ˆì´ì–´ LINE ì²˜ë¦¬...")
    
    # ë¼ì¸íƒ€ì…ì´ ì—†ìœ¼ë©´ ìƒì„±
    if 'HIDDEN' not in doc.linetypes:
        try:
            # HIDDEN ë¼ì¸íƒ€ì… ìƒì„± (ìˆ¨ì€ì„  íŒ¨í„´)
            doc.linetypes.new('HIDDEN', dxfattribs={
                'description': '- - - - - -',
                'pattern': [6.35, -3.175]  # ì‹¤ì„  6.35mm, ê³µë°± 3.175mm ë°˜ë³µ
            })
            print("   HIDDEN ë¼ì¸íƒ€ì… ìƒì„±")
        except:
            print("   âš ï¸ HIDDEN ë¼ì¸íƒ€ì…ì´ ì´ë¯¸ ì¡´ì¬í•˜ê±°ë‚˜ ìƒì„± ì‹¤íŒ¨")
    
    modified_count = 0
    
    for line in msp.query('LINE'):
        if line.dxf.layer == 'DIM' and line.dxf.color == 1:  # RED = 1
            try:
                # ìƒ‰ìƒì„ YELLOWë¡œ ë³€ê²½
                line.dxf.color = 2  # YELLOW = 2
                
                # ë ˆì´ì–´ë¥¼ CONTë¡œ ë³€ê²½
                line.dxf.layer = 'CONT'
                
                # ë¼ì¸íƒ€ì…ì„ HIDDENìœ¼ë¡œ ë³€ê²½
                line.dxf.linetype = 'HIDDEN'
                
                # LTSCALEì„ 5ë¡œ ì„¤ì •
                line.dxf.ltscale = 5.0
                
                modified_count += 1
                print(f"   LINE ìˆ˜ì •: ìƒ‰ìƒ REDâ†’YELLOW, ë ˆì´ì–´ DIMâ†’CONT, ë¼ì¸íƒ€ì…â†’HIDDEN, LTSCALEâ†’5")
                
            except Exception as e:
                print(f"   âŒ LINE ìˆ˜ì • ì‹¤íŒ¨: {e}")
    
    print(f"âœ… ì´ {modified_count}ê°œì˜ LINE ìˆ˜ì • ì™„ë£Œ")

def process_dxf(filepath: str):
    print(f"\nğŸ“ ì²˜ë¦¬ ì¤‘: {Path(filepath).name}")
    doc = ezdxf.readfile(filepath)
    msp = doc.modelspace()

    # ì²˜ë¦¬ëœ ì—”í‹°í‹°ë¥¼ ì¶”ì í•˜ê¸° ìœ„í•œ ì„¸íŠ¸
    processed_entities = set()

    # 1. ë ˆì´ì–´ 1ì´ê³  ìƒ‰ìƒì´ REDì¸ LINEì„ PIPE ë ˆì´ì–´ë¡œ ë³€ê²½
    for line in msp.query('LINE'):
        if line.dxf.layer == '1' and line.dxf.color == 1:  # RED = 1
            line.dxf.layer = 'PIPE'
            print(f"LINEì„ PIPE ë ˆì´ì–´ë¡œ ë³€ê²½")

    # 2. ë ˆì´ì–´ 1ì´ê³  RED ìƒ‰ìƒì˜ ARCë¥¼ ELBO ë ˆì´ì–´ë¡œ ë³€ê²½
    for arc in msp.query('ARC'):
        if arc.dxf.layer == '1' and arc.dxf.color == 1:  # RED = 1
            arc.dxf.layer = 'ELBO'
            print(f"ARCë¥¼ ELBO ë ˆì´ì–´ë¡œ ë³€ê²½")

    # 3. PL ì²˜ë¦¬: ë‹¤ì–‘í•œ ì  ê°œìˆ˜ë³„ ë ˆì´ì–´ ë³€ê²½
    entities_to_delete = []  # ì‚­ì œí•  ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸
    
    for ent in list(msp):
        if ent.dxftype() not in ['LWPOLYLINE','POLYLINE']: 
            continue
        
        pts = polypoints(ent)
        n = len(pts)
        
        # ì²˜ë¦¬ëœ ì—”í‹°í‹° ì¶”ì 
        processed_entities.add(id(ent))
        
        # 3ì  polyline (PL3)
        if n==3:
            if has_bulge(ent):
                r = get_bulge_radius(ent)
                if r and 2 <= r <= 3:
                    ent.dxf.layer = 'WELDNO'
                    ent.dxf.color = 2
                elif r and 5 <= r <= 8:
                    # INSTNO ì²˜ë¦¬ - ì›ìœ¼ë¡œ ëŒ€ì²´
                    print(f"\nINSTNO í´ë¦¬ë¼ì¸ ë°œê²¬: bulge ë°˜ì§€ë¦„ = {r:.3f}")
                    
                    # bulgeë¥¼ ì‚¬ìš©í•˜ì—¬ ì •í™•í•œ ì›ì˜ ì¤‘ì‹¬ì ê³¼ ë°˜ì§€ë¦„ ê³„ì‚°
                    center, calculated_radius = get_polyline_arc_center_and_radius_with_bulge(ent)
                    
                    if center and calculated_radius:
                        print(f"í´ë¦¬ë¼ì¸ íƒ€ì…: {ent.dxftype()}")
                        print(f"3ì  ì¢Œí‘œ: {pts}")
                        print(f"ê³„ì‚°ëœ ì¤‘ì‹¬: ({center[0]:.3f}, {center[1]:.3f}), ë°˜ì§€ë¦„: {calculated_radius:.3f}")
                        
                        # ë™ì¼í•œ ìœ„ì¹˜ì— ë™ì¼í•œ ì›ì´ ìˆëŠ”ì§€ í™•ì¸
                        if not circle_exists_at_position(msp, center, calculated_radius):
                            # ì› ê·¸ë¦¬ê¸° - CYAN ìƒ‰ìƒ(4)
                            circle = msp.add_circle(
                                center=center,
                                radius=calculated_radius,
                                dxfattribs={'layer': 'INSTNO', 'color': 4}  # CYAN
                            )
                            print(f"âœ… CYAN ì› ì¶”ê°€ ì™„ë£Œ: ì¤‘ì‹¬ ({center[0]:.3f}, {center[1]:.3f}), ë°˜ì§€ë¦„ {calculated_radius:.3f}")
                            
                            # ì›ë³¸ í´ë¦¬ë¼ì¸ì„ ì‚­ì œ ëª©ë¡ì— ì¶”ê°€
                            entities_to_delete.append(ent)
                            print(f"í´ë¦¬ë¼ì¸ì„ ì‚­ì œ ëª©ë¡ì— ì¶”ê°€")
                        else:
                            print(f"âš ï¸ ì›ì´ ì´ë¯¸ ì¡´ì¬ (SKIP)")
                    else:
                        print(f"âŒ ì›ì˜ ì¤‘ì‹¬ì  ê³„ì‚° ì‹¤íŒ¨")
                        # ê³„ì‚° ì‹¤íŒ¨ì‹œì—ë„ ë ˆì´ì–´ëŠ” ì„¤ì •
                        ent.dxf.layer = 'INSTNO'
                        ent.dxf.color = 2
                else:
                    ent.dxf.layer = 'PL3'
            else:
                ent.dxf.layer = 'PL3'

        # 4ì  polyline (PL4) - FALL ì¡°ê±´ ì¶”ê°€
        elif n==4:
            # ì ê°„ ê±°ë¦¬ ê³„ì‚° (ë§ˆì§€ë§‰ ì ì—ì„œ ì²« ì ìœ¼ë¡œì˜ ê±°ë¦¬ í¬í•¨)
            dists = all_pair_distances(pts)
            last_to_first = distance(pts[3], pts[0])
            
            # FALL íŒ¨í„´ í™•ì¸ (í—ˆìš© ì˜¤ì°¨ 0.1mm)
            tolerance = 0.1
            if (len(dists) >= 3 and
                abs(dists[0] - 7.445) <= tolerance and  # ì 1â†’ì 2
                abs(dists[1] - 1.612) <= tolerance and  # ì 2â†’ì 3
                abs(dists[2] - 7.592) <= tolerance and  # ì 3â†’ì 4
                abs(last_to_first - 0) <= tolerance):   # ì 4â†’ì 1
                ent.dxf.layer = 'FALL'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL4'
                ent.dxf.color = 7

        # 5ì  polyline (PL5)
        elif n==5:
            dists = all_pair_distances(pts)
            if all(d<=4.5 for d in dists):
                ent.dxf.layer = 'itemno'
            elif any(d>=30 for d in dists):
                ent.dxf.layer = 'spoolno'
            else:
                ent.dxf.layer = 'PL5'
            ent.dxf.color = 7

        # 6ì  polyline (PL6)
        elif n==6:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ëª¨ë“  ì ê°„ ê±°ë¦¬ì˜ í•©
            
            # ê¸¸ì´ê°’ í•©ê³„ ê¸°ì¤€ìœ¼ë¡œ ë ˆì´ì–´ ì§€ì •
            if 10 <= total_dist <= 11:
                ent.dxf.layer = 'SFW'
                ent.dxf.color = 2
            elif 17.5 <= total_dist <= 22:
                ent.dxf.layer = 'REDU'
                ent.dxf.color = 2
            elif 16 <= total_dist <= 16.5:
                ent.dxf.layer = 'REDU'
                ent.dxf.color = 2
            elif 17 <= total_dist <= 17.3:
                ent.dxf.layer = 'FLOW'
                ent.dxf.color = 2
            elif 12 <= total_dist <= 13.3:
                ent.dxf.layer = 'OLET'
                ent.dxf.color = 2
            elif any(d<=1.0 for d in dists):
                ent.dxf.layer = 'FLAN'
                ent.dxf.color = 2
            elif sum(1 for d in dists if 6<=d<=15)>=2:
                ent.dxf.layer = 'VALV'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL6'
                ent.dxf.color = 7

        elif n==7:
            dists = all_pair_distances(pts)
            mov_idx = [i for i,d in enumerate(dists) if 3<=d<=5]
            if len(mov_idx)>=2:
                ent.dxf.layer = 'MOV'
                ent.dxf.color = 2
            elif all(d<=2.2 for d in dists):
                ent.dxf.layer='weld'
                ent.dxf.color=2
            else:
                ent.dxf.layer = 'PL7'
                ent.dxf.color = 4

        elif n==8:
            dists = all_pair_distances(pts)
            if sum(1 for d in dists if 1.5<=d<=4)>=5:
                ent.dxf.layer = 'WOLET'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL8'
                ent.dxf.color = 7

        elif n==9:
            dists = all_pair_distances(pts)
            if all(d<=5 for d in dists):
                ent.dxf.layer = 'CV'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL9'
                ent.dxf.color = 7

        elif n==10:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ëª¨ë“  ì ê°„ ê±°ë¦¬ì˜ í•©
            
            if 13.5 <= total_dist <= 14.5:
                ent.dxf.layer = 'CAP'
                ent.dxf.color = 2  # Yellow
            else:
                ent.dxf.layer = 'PL10'
                ent.dxf.color = 7

        elif n==12:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ëª¨ë“  ì ê°„ ê±°ë¦¬ì˜ í•©
            
            if 34 <= total_dist <= 35:
                ent.dxf.layer = 'SFW'
                ent.dxf.color = 2  # Yellow
            else:
                ent.dxf.layer = 'PL12'
                ent.dxf.color = 7

        elif n==2:
            ent.dxf.layer = 'PL2'
            ent.dxf.color = 7
            
        # ìœ„ì—ì„œ ì •ì˜ë˜ì§€ ì•Šì€ ì  ê°œìˆ˜ì˜ í´ë¦¬ë¼ì¸ ì²˜ë¦¬
        else:
            ent.dxf.layer = f'PL{n}'
            ent.dxf.color = 7
            print(f"ì •ì˜ë˜ì§€ ì•Šì€ {n}ì  í´ë¦¬ë¼ì¸ -> {ent.dxf.layer} ë ˆì´ì–´")
    
    # ì‚­ì œ ì˜ˆì •ì¸ ì—”í‹°í‹°ë“¤ì„ ì‹¤ì œë¡œ ì‚­ì œ
    print(f"\nì‚­ì œ ëŒ€ìƒ ì—”í‹°í‹° ìˆ˜: {len(entities_to_delete)}ê°œ")
    for idx, ent in enumerate(entities_to_delete):
        try:
            msp.delete_entity(ent)
            print(f"  [{idx+1}] INSTNO í´ë¦¬ë¼ì¸ ì‚­ì œ ì™„ë£Œ")
        except Exception as e:
            print(f"  [{idx+1}] ì‚­ì œ ì‹¤íŒ¨: {e}")
    
    # 4. TEXT ë ˆì´ì–´ ì§€ì • ë° ìƒ‰ìƒ ì„¤ì •
    for ent in msp.query('TEXT'):
        txt = ent.dxf.text.upper()
        if '<' in txt and '>' in txt:
            ent.dxf.layer = 'itemno'
        elif any(tag in txt for tag in ['EL+','EL-','FL+','FL-']):
            ent.dxf.layer = 'ELEV'
        elif any(letter in txt for letter in ['F','G']):
            ent.dxf.layer = 'FLAN'
        elif 'FALL' in txt:
            ent.dxf.layer = 'FALL'
        
        # ëª¨ë“  í…ìŠ¤íŠ¸ë¥¼ ë…¸ë€ìƒ‰ìœ¼ë¡œ ì„¤ì •
        ent.dxf.color = 2

    # 5. SP3, SP7 ì²˜ë¦¬ (ë ˆì´ì–´ë§Œ ì§€ì •)
    for ent in msp:
        if ent.dxftype() not in ['LWPOLYLINE','POLYLINE']: continue
        pts = polypoints(ent)
        n = len(pts)
        
        # ARROW ì„ ê¸‹ê¸° - ì¤‘ë³µ ì²´í¬ ì¶”ê°€
        if n==3:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ì ê°„ ê±°ë¦¬ì˜ í•© ê³„ì‚°
            
            if total_dist <= 5:  # ìƒˆë¡œìš´ ì¡°ê±´: ì ê°„ ê±°ë¦¬ í•©ì´ 5 ì´í•˜
                # LINEì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                if not line_exists_between_points(msp, pts[2], pts[0]):
                    # ì›ë˜ ì‚¼ê°í˜• ì„¸ ë³€
                    line20 = msp.add_line(pts[2], pts[0], dxfattribs={'color': 7, 'layer': 'ARROW'})
                    print(f"ìƒˆ LINE ì¶”ê°€: {pts[2]} -> {pts[0]}")
                else:
                    print(f"LINE ì´ë¯¸ ì¡´ì¬: {pts[2]} -> {pts[0]} (SKIP)")
        elif n==7:
            dists = all_pair_distances(pts)
            if any(d>30 for d in dists):
                ent.dxf.layer = 'SUPP'

    # 6. FALL ë ˆì´ì–´ì˜ 2ì  í´ë¦¬ë¼ì¸ ìƒ‰ìƒì„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½
    for ent in list(msp):
        if ent.dxftype() in ['LWPOLYLINE','POLYLINE'] and ent.dxf.layer=='FALL':
            pts = polypoints(ent)
            if len(pts) == 2:
                ent.dxf.color = 7  # í°ìƒ‰

    # 7. 'PT            COMPONENT              SIZE' í—¤ë” ì°¾ì•„ì„œ STRETCH ì²˜ë¦¬
    # Xê°’ì´ 620ë³´ë‹¤ ì‘ì€ ê²½ìš°ì—ë§Œ ì‹¤í–‰
    header_found = False
    for text in msp.query('TEXT'):
        if text.dxf.text and 'PT' in text.dxf.text and 'COMPONENT' in text.dxf.text and 'SIZE' in text.dxf.text:
            header_x = text.dxf.insert[0]
            header_y = text.dxf.insert[1]
            print(f"\nğŸ“ HEADER ì°¾ìŒ: '{text.dxf.text.strip()}'")
            print(f"   ìœ„ì¹˜: X={header_x:.3f}, Y={header_y:.3f}")
            
            # Xê°’ì´ 620ë³´ë‹¤ ì‘ì€ì§€ í™•ì¸
            if header_x < 620:
                print(f"   âœ… Xê°’({header_x:.3f})ì´ 620ë³´ë‹¤ ì‘ìœ¼ë¯€ë¡œ STRETCH ì‹¤í–‰")
                # í•´ë‹¹ ë²”ìœ„ì˜ ì—”í‹°í‹°ë“¤ì„ STRETCH (Xì¶•ìœ¼ë¡œ +39mm)
                stretch_entities_in_range(msp, header_x, header_y, stretch_x=39)
            else:
                print(f"   âš ï¸ Xê°’({header_x:.3f})ì´ 620 ì´ìƒì´ë¯€ë¡œ STRETCH ê±´ë„ˆëœ€")
            
            header_found = True
            break
    
    if not header_found:
        print("\nâš ï¸ 'PT            COMPONENT              SIZE' í—¤ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    # 8. WELD í—¤ë” ê´€ë ¨ ì²˜ë¦¬
    find_and_process_weld_header(msp)

    # 9. PL97 ë° PL31 ì²˜ë¦¬
    process_pl97_and_pl31(msp)

    # 10. ë ˆì´ì–´ 3 LINE ë° TEXT ì²˜ë¦¬
    process_layer3_lines_and_texts(msp)

    # 11. RED ìƒ‰ìƒ DIM ë ˆì´ì–´ LINE ì²˜ë¦¬
    process_red_dim_lines(msp, doc)

    # 12. íŒŒì¼ ì €ì¥
    outname = Path(filepath).with_stem(Path(filepath).stem + '_PL')
    doc.saveas(str(outname))
    print(f"âœ… ì €ì¥ ì™„ë£Œ: {outname}")

def select_files_and_process():
    root = tk.Tk()
    root.withdraw()
    files = filedialog.askopenfilenames(filetypes=[('DXF files','*.dxf')])
    for f in files:
        process_dxf(f)

if __name__ == '__main__':
    select_files_and_process()