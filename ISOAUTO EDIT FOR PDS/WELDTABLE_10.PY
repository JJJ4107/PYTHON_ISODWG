import os
import re
import ezdxf
import tkinter as tk
from tkinter import filedialog
from math import hypot, sqrt, radians, cos, sin
import time
import shutil

def get_selected_dxf_files():
    root = tk.Tk()
    root.withdraw()
    return list(filedialog.askopenfilenames(
        title="DXF íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”",
        filetypes=[("DXF files", "*.dxf")]
    ))

def extract_text_entities(doc):
    return [e for e in doc.modelspace() if e.dxftype() == 'TEXT']

def get_texts_by_position(entities):
    texts = []
    for e in entities:
        pos = e.dxf.insert
        texts.append((e.plain_text().strip(), round(pos.x, 2), round(pos.y, 2), e))
    return sorted(texts, key=lambda t: (-t[2], t[1]))

def extract_bore_from_size(size_text):
    match = re.search(r'(\d+)', size_text)
    return int(match.group(1)) if match else 100

def find_size_value_near_materials(all_texts):
    """FABRICATION MATERIALS ë˜ëŠ” ERECTION MATERIALS ê·¼ì²˜ì—ì„œ SIZE ê°’ ì°¾ê¸°"""
    materials_pos = None
    materials_type = None
    
    # ë¨¼ì € FABRICATION MATERIALS ì°¾ê¸°
    for text, x, y, _ in all_texts:
        if "FABRICATION MATERIAL" in text.upper():
            materials_pos = (x, y)
            materials_type = "FABRICATION"
            print(f"âœ… FABRICATION MATERIALS ì°¾ìŒ: ({x:.2f}, {y:.2f})")
            break
    
    # FABRICATION MATERIALSê°€ ì—†ìœ¼ë©´ ERECTION MATERIALS ì°¾ê¸°
    if not materials_pos:
        for text, x, y, _ in all_texts:
            if "ERECTION MATERIAL" in text.upper():
                materials_pos = (x, y)
                materials_type = "ERECTION"
                print(f"âœ… ERECTION MATERIALS ì°¾ìŒ: ({x:.2f}, {y:.2f})")
                break
    
    if not materials_pos:
        print("âš  'FABRICATION MATERIALS' ë° 'ERECTION MATERIALS' í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return None
    
    # SIZE í…ìŠ¤íŠ¸ ì°¾ê¸°
    size_candidates = [
        (text, x, y) for text, x, y, _ in all_texts
        if "SIZE" in text.upper() and hypot(x - materials_pos[0], y - materials_pos[1]) <= 100
    ]
    if not size_candidates:
        print(f"âš  SIZE í…ìŠ¤íŠ¸ê°€ '{materials_type} MATERIALS' ë°˜ê²½ 100mm ë‚´ì— ì—†ìŠµë‹ˆë‹¤.")
        return None
    
    size_text, size_x, size_y = sorted(size_candidates, key=lambda t: hypot(t[1] - materials_pos[0], t[2] - materials_pos[1]))[0]
    below_texts = [t for t in all_texts if abs(t[1] - size_x) < 1 and t[2] < size_y]
    if not below_texts:
        print("âš  SIZE ì•„ë˜ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.")
        return None
    
    size_value = sorted(below_texts, key=lambda t: size_y - t[2])[0][0]
    print(f"âœ… SIZE ê°’ ì°¾ìŒ: {size_value} ({materials_type} MATERIALS ê¸°ì¤€)")
    return size_value

def find_dn_header_x(all_texts):
    """ 'NO', '/FLD', 'DN' í—¤ë”ê°€ ìˆ˜í‰ìœ¼ë¡œ ë‚˜ì—´ëœ ê²½ìš° ê·¸ ì¤‘ DN í…ìŠ¤íŠ¸ì˜ X ì¢Œí‘œë¥¼ ë°˜í™˜ """
    header_groups = []
    texts_by_y = {}
    for text, x, y, _ in all_texts:
        texts_by_y.setdefault(round(y, 1), []).append((text.strip().upper(), x))

    for y, items in texts_by_y.items():
        headers = {t[0]: t[1] for t in items}
        if all(k in headers for k in ['NO', '/FLD', 'DN']):
            dn_x = headers['DN']
            return dn_x  # DN í…ìŠ¤íŠ¸ X ì¢Œí‘œ ë°˜í™˜

    return None

def find_header_positions(all_texts):
    headers = {}
    for text, x, y, _ in all_texts:
        txt = text.strip().upper()
        for key in ['NO', 'TYPE', '/FLD']:
            if key in txt:
                headers[key] = (round(x, 2), round(y, 2))
    return headers

def find_circle_entities(doc, radius):
    """ì£¼ì–´ì§„ ë°˜ì§€ë¦„ì˜ ì›ì„ ì°¾ëŠ” í•¨ìˆ˜"""
    circles = []
    msp = doc.modelspace()
    for e in msp:
        if e.dxftype() == 'CIRCLE' and abs(e.dxf.radius - radius) < 0.5:
            circles.append(e)
    return circles

def find_text_in_circle(all_texts, circle_center, radius):
    """ì› ì•ˆì— ìˆëŠ” í…ìŠ¤íŠ¸ë¥¼ ì°¾ëŠ” í•¨ìˆ˜"""
    texts_in_circle = []
    for text, x, y, e in all_texts:
        dist = hypot(x - circle_center[0], y - circle_center[1])
        if dist <= radius:
            texts_in_circle.append((text, x, y, e))
    return texts_in_circle

def find_entities_by_layer(doc, layer_names):
    """íŠ¹ì • ë ˆì´ì–´ì˜ ì—”í‹°í‹°ë¥¼ ì°¾ëŠ” í•¨ìˆ˜"""
    entities = []
    msp = doc.modelspace()
    for e in msp:
        if hasattr(e, 'dxf') and hasattr(e.dxf, 'layer'):
            layer_upper = e.dxf.layer.upper()
            # TEE_ íŒ¨í„´ ì²˜ë¦¬
            if any(layer_upper.startswith('TEE_') for name in layer_names if name == 'TEE_'):
                entities.append(e)
                print(f"  TEE ë ˆì´ì–´ {e.dxf.layer} ì—”í‹°í‹° ë°œê²¬: {e.dxftype()}")
            # ì¼ë°˜ ë ˆì´ì–´ ì²˜ë¦¬
            elif layer_upper in [l.upper() for l in layer_names if l != 'TEE_']:
                entities.append(e)
                print(f"  ë ˆì´ì–´ {e.dxf.layer} ì—”í‹°í‹° ë°œê²¬: {e.dxftype()}")
    return entities

def get_entity_position(entity):
    """ì—”í‹°í‹°ì˜ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜"""
    if entity.dxftype() in ['TEXT', 'MTEXT']:
        return (entity.dxf.insert.x, entity.dxf.insert.y)
    elif entity.dxftype() == 'INSERT':  # ë¸”ë¡ ì°¸ì¡°
        return (entity.dxf.insert.x, entity.dxf.insert.y)
    elif entity.dxftype() == 'CIRCLE':
        return (entity.dxf.center.x, entity.dxf.center.y)
    elif entity.dxftype() == 'LINE':
        # ì„ ì˜ ì¤‘ì 
        return ((entity.dxf.start.x + entity.dxf.end.x) / 2,
                (entity.dxf.start.y + entity.dxf.end.y) / 2)
    elif entity.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
        # í´ë¦¬ë¼ì¸ì˜ ì²« ì 
        if entity.dxftype() == 'LWPOLYLINE':
            points = list(entity.get_points())
            if points:
                return (points[0][0], points[0][1])
        else:
            vertices = list(entity.vertices)
            if vertices:
                return (vertices[0].dxf.location.x, vertices[0].dxf.location.y)
    elif entity.dxftype() == 'ARC':
        return (entity.dxf.center.x, entity.dxf.center.y)
    return None

def find_circles_by_layer(doc, layer_name):
    """íŠ¹ì • ë ˆì´ì–´ì˜ ì›ì„ ì°¾ëŠ” í•¨ìˆ˜"""
    circles = []
    msp = doc.modelspace()
    for e in msp:
        if e.dxftype() == 'CIRCLE' and hasattr(e, 'dxf') and hasattr(e.dxf, 'layer'):
            if e.dxf.layer.upper() == layer_name.upper():
                circles.append(e)
    return circles

def find_entities_touching_circle(doc, circle, layer_names):
    """ì›ì— ì ‘í•˜ëŠ” íŠ¹ì • ë ˆì´ì–´ì˜ ì—”í‹°í‹°ë¥¼ ì°¾ëŠ” í•¨ìˆ˜"""
    entities = []
    center = (circle.dxf.center.x, circle.dxf.center.y)
    radius = circle.dxf.radius
    
    layer_entities = find_entities_by_layer(doc, layer_names)
    
    for e in layer_entities:
        pos = get_entity_position(e)
        if pos:
            dist = hypot(pos[0] - center[0], pos[1] - center[1])
            # ì›ì— ì ‘í•˜ëŠ” ì¡°ê±´: ê±°ë¦¬ê°€ ë°˜ì§€ë¦„ê³¼ ë¹„ìŠ· (Â±2mm í—ˆìš©)
            if abs(dist - radius) <= 2:
                entities.append(e)
    
    return entities

def has_bulge(entity):
    """í´ë¦¬ë¼ì¸ì´ ê³¡ì„ (bulge)ì„ í¬í•¨í•˜ëŠ”ì§€ í™•ì¸"""
    if entity.dxftype() == 'LWPOLYLINE':
        # LWPOLYLINEì˜ ê²½ìš° get_pointsë¡œ bulge ì •ë³´ í™•ì¸
        points_with_bulge = list(entity.get_points('xyb'))
        for point in points_with_bulge:
            if len(point) > 2 and point[2] != 0:  # bulgeê°€ 0ì´ ì•„ë‹ˆë©´ ê³¡ì„ 
                return True
    elif entity.dxftype() == 'POLYLINE':
        # POLYLINEì˜ ê²½ìš° ê° vertexì˜ bulge í™•ì¸
        for vertex in entity.vertices:
            if hasattr(vertex.dxf, 'bulge') and vertex.dxf.bulge != 0:
                return True
    return False

def find_polylines_touching_entity(doc, entity, exclude_layers=[]):
    """ì—”í‹°í‹°ì˜ ì„ ë¶„ì— ì ‘í•˜ëŠ” 2-3ì  í´ë¦¬ë¼ì¸ì„ ì°¾ëŠ” í•¨ìˆ˜ (ìµœì†Œ ê¸¸ì´ 5mm)"""
    polylines = []
    msp = doc.modelspace()
    
    # ì—”í‹°í‹°ì˜ ì„ ë¶„ë“¤ì„ êµ¬í•¨
    entity_segments = []
    if entity.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
        if entity.dxftype() == 'LWPOLYLINE':
            points = list(entity.get_points())
        else:
            points = [(v.dxf.location.x, v.dxf.location.y) for v in entity.vertices]
        
        for i in range(len(points) - 1):
            entity_segments.append(((points[i][0], points[i][1]), 
                                  (points[i+1][0], points[i+1][1])))
    elif entity.dxftype() == 'LINE':
        entity_segments.append(((entity.dxf.start.x, entity.dxf.start.y),
                              (entity.dxf.end.x, entity.dxf.end.y)))
    
    # ëª¨ë“  í´ë¦¬ë¼ì¸ ê²€ì‚¬
    for e in msp:
        if e.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
            if hasattr(e.dxf, 'layer') and e.dxf.layer.upper() in [l.upper() for l in exclude_layers]:
                continue
            
            # ê³¡ì„ (bulge)ì´ ìˆëŠ” í´ë¦¬ë¼ì¸ì€ ì œì™¸
            if has_bulge(e):
                continue
            
            # í´ë¦¬ë¼ì¸ì˜ ì ë“¤
            if e.dxftype() == 'LWPOLYLINE':
                poly_points = list(e.get_points())
            else:
                poly_points = [(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
            
            # 2-3ì ì¸ ê²½ìš°ë§Œ
            if 2 <= len(poly_points) <= 3:
                # ê¸¸ì´ ê³„ì‚°
                total_length = 0
                for i in range(len(poly_points) - 1):
                    dist = hypot(poly_points[i+1][0] - poly_points[i][0], 
                               poly_points[i+1][1] - poly_points[i][1])
                    total_length += dist
                
                # ê¸¸ì´ê°€ 5mm ì´ìƒì¸ ê²½ìš°ë§Œ
                if total_length >= 5:
                    # ì—”í‹°í‹°ì˜ ì„ ë¶„ê³¼ ì ‘í•˜ëŠ”ì§€ í™•ì¸
                    touching = False
                    for seg_start, seg_end in entity_segments:
                        for px, py, *_ in poly_points:
                            # ì ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
                            dist = point_to_line_distance((px, py), seg_start, seg_end)
                            if dist <= 1:  # 1mm ì´ë‚´ë©´ ì ‘ì´‰
                                touching = True
                                break
                        if touching:
                            break
                    
                    if touching:
                        polylines.append(e)
    
    return polylines

def point_to_line_distance(point, line_start, line_end):
    """ì ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°"""
    px, py = point
    x1, y1 = line_start
    x2, y2 = line_end
    
    # ì„ ë¶„ì˜ ê¸¸ì´
    line_length = hypot(x2 - x1, y2 - y1)
    if line_length == 0:
        return hypot(px - x1, py - y1)
    
    # ë§¤ê°œë³€ìˆ˜ t ê³„ì‚°
    t = max(0, min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / (line_length ** 2)))
    
    # ì„ ë¶„ ìœ„ì˜ ê°€ì¥ ê°€ê¹Œìš´ ì 
    closest_x = x1 + t * (x2 - x1)
    closest_y = y1 + t * (y2 - y1)
    
    return hypot(px - closest_x, py - closest_y)

def get_segment_lengths(entity):
    """ì—”í‹°í‹°ì˜ ê° ì„ ë¶„ ê¸¸ì´ë¥¼ ê³„ì‚°í•˜ì—¬ ë°˜í™˜"""
    segments = []
    if entity.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
        if entity.dxftype() == 'LWPOLYLINE':
            points = list(entity.get_points())
        else:
            points = [(v.dxf.location.x, v.dxf.location.y) for v in entity.vertices]
        
        for i in range(len(points) - 1):
            start = (points[i][0], points[i][1])
            end = (points[i+1][0], points[i+1][1])
            length = hypot(end[0] - start[0], end[1] - start[1])
            segments.append({
                'start': start,
                'end': end,
                'length': length,
                'index': i
            })
    elif entity.dxftype() == 'LINE':
        start = (entity.dxf.start.x, entity.dxf.start.y)
        end = (entity.dxf.end.x, entity.dxf.end.y)
        length = hypot(end[0] - start[0], end[1] - start[1])
        segments.append({
            'start': start,
            'end': end,
            'length': length,
            'index': 0
        })
    
    return segments

def find_all_touching_segments(circle_center, radius, segments):
    """ì›ì´ ì ‘í•˜ëŠ” ëª¨ë“  ì„ ë¶„ì„ ì°¾ê³ , ê° ì„ ë¶„ì˜ ì ‘ì´‰ ë¶€ë¶„ ê¸¸ì´ë¥¼ ê³„ì‚°"""
    touching_segments = []
    for seg in segments:
        dist = point_to_line_distance(circle_center, seg['start'], seg['end'])
        if abs(dist - radius) <= 3:  # 3mm í—ˆìš© ë²”ìœ„
            # ì‹¤ì œ ì ‘ì´‰ êµ¬ê°„ì˜ ê¸¸ì´ ê³„ì‚° (ê°„ë‹¨í•œ ê·¼ì‚¬: ì „ì²´ ì„ ë¶„ì´ ì ‘ì´‰í•œë‹¤ê³  ê°€ì •)
            contact_length = seg['length']
            touching_segments.append({
                'segment': seg,
                'contact_length': contact_length,
                'full_length': seg['length']
            })
    return touching_segments

def get_total_contact_length(circle_center, radius, segments):
    """ì›ì´ ì ‘í•˜ëŠ” ëª¨ë“  ì„ ë¶„ì˜ ê¸¸ì´ í•© ê³„ì‚°"""
    touching_segments = find_all_touching_segments(circle_center, radius, segments)
    total_length = sum(seg['contact_length'] for seg in touching_segments)
    return total_length, touching_segments

def find_pipe_entities_near_center(doc, center, search_radius):
    """ì¤‘ì‹¬ì ì—ì„œ ì§€ì •ëœ ë°˜ê²½ ë‚´ì˜ PIPE_ ë ˆì´ì–´ 2ì  ìš”ì†Œ ì°¾ê¸°"""
    msp = doc.modelspace()
    pipe_entities = []
    
    for e in msp:
        if e.dxftype() in ['LINE', 'POLYLINE', 'LWPOLYLINE']:
            if hasattr(e, 'dxf') and hasattr(e.dxf, 'layer'):
                if 'PIPE_' in e.dxf.layer.upper():
                    # ì  ê°œìˆ˜ í™•ì¸
                    point_count = 0
                    if e.dxftype() == 'LINE':
                        point_count = 2
                    elif e.dxftype() == 'LWPOLYLINE':
                        point_count = len(list(e.get_points()))
                    elif e.dxftype() == 'POLYLINE':
                        point_count = len(list(e.vertices))
                    
                    # 2ì ì¸ ê²½ìš°ë§Œ
                    if point_count == 2:
                        # ì–‘ ëì ì˜ ê±°ë¦¬ í™•ì¸
                        include_entity = False
                        
                        if e.dxftype() == 'LINE':
                            start = (e.dxf.start.x, e.dxf.start.y)
                            end = (e.dxf.end.x, e.dxf.end.y)
                            dist_start = hypot(start[0] - center[0], start[1] - center[1])
                            dist_end = hypot(end[0] - center[0], end[1] - center[1])
                            if dist_start <= search_radius or dist_end <= search_radius:
                                include_entity = True
                        elif e.dxftype() == 'LWPOLYLINE':
                            points = list(e.get_points())
                            if len(points) == 2:
                                dist_start = hypot(points[0][0] - center[0], points[0][1] - center[1])
                                dist_end = hypot(points[1][0] - center[0], points[1][1] - center[1])
                                if dist_start <= search_radius or dist_end <= search_radius:
                                    include_entity = True
                        elif e.dxftype() == 'POLYLINE':
                            vertices = list(e.vertices)
                            if len(vertices) == 2:
                                dist_start = hypot(vertices[0].dxf.location.x - center[0], 
                                                 vertices[0].dxf.location.y - center[1])
                                dist_end = hypot(vertices[1].dxf.location.x - center[0], 
                                               vertices[1].dxf.location.y - center[1])
                                if dist_start <= search_radius or dist_end <= search_radius:
                                    include_entity = True
                        
                        if include_entity:
                            pipe_entities.append(e)
    
    return pipe_entities

def extract_wd_from_pipe_layer(layer_name):
    """PIPE_ ë ˆì´ì–´ëª…ì—ì„œ WD ê°’ ì¶”ì¶œ"""
    match = re.search(r'PIPE_(\d+)', layer_name.upper())
    if match:
        return int(match.group(1))
    return None

def extract_td_from_tee_layer(layer_name):
    """TEE_ ë ˆì´ì–´ëª…ì—ì„œ TD ê°’ ì¶”ì¶œ"""
    match = re.search(r'TEE_(\d+)', layer_name.upper())
    if match:
        return int(match.group(1))
    return None

def find_tee_entities_touching_circle(doc, circle):
    """TEE_ ë ˆì´ì–´ì˜ ì—”í‹°í‹° ì¤‘ ì–´ëŠ í•œ ì ì´ë¼ë„ ì›ì— ì ‘í•˜ëŠ” ê²ƒì„ ì°¾ëŠ” í•¨ìˆ˜"""
    entities = []
    center = (circle.dxf.center.x, circle.dxf.center.y)
    radius = circle.dxf.radius
    msp = doc.modelspace()
    
    for e in msp:
        if hasattr(e, 'dxf') and hasattr(e.dxf, 'layer'):
            layer_upper = e.dxf.layer.upper()
            if layer_upper.startswith('TEE_'):
                touching = False
                
                # ì—”í‹°í‹° íƒ€ì…ë³„ë¡œ ëª¨ë“  ì  ê²€ì‚¬
                if e.dxftype() == 'LINE':
                    # ì‹œì‘ì ê³¼ ëì  ê²€ì‚¬
                    points = [(e.dxf.start.x, e.dxf.start.y), 
                              (e.dxf.end.x, e.dxf.end.y)]
                    for px, py in points:
                        dist = hypot(px - center[0], py - center[1])
                        if abs(dist - radius) <= 2:
                            touching = True
                            break
                
                elif e.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
                    # ëª¨ë“  ì  ê²€ì‚¬
                    if e.dxftype() == 'LWPOLYLINE':
                        points = list(e.get_points())
                    else:
                        points = [(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
                    
                    for point in points:
                        px, py = point[0], point[1]
                        dist = hypot(px - center[0], py - center[1])
                        if abs(dist - radius) <= 2:
                            touching = True
                            break
                
                elif e.dxftype() == 'CIRCLE':
                    # ì›ì˜ ì¤‘ì‹¬ ê²€ì‚¬
                    dist = hypot(e.dxf.center.x - center[0], e.dxf.center.y - center[1])
                    if abs(dist - radius) <= 2:
                        touching = True
                
                elif e.dxftype() in ['TEXT', 'MTEXT', 'INSERT']:
                    # ì‚½ì…ì  ê²€ì‚¬
                    dist = hypot(e.dxf.insert.x - center[0], e.dxf.insert.y - center[1])
                    if abs(dist - radius) <= 2:
                        touching = True
                
                elif e.dxftype() == 'ARC':
                    # ì•„í¬ì˜ ê²½ìš° ì¤‘ì‹¬ì ê³¼ ì‹œì‘/ë ê°ë„ì˜ ì ë“¤ ê²€ì‚¬
                    cx, cy = e.dxf.center.x, e.dxf.center.y
                    r = e.dxf.radius
                    
                    # ì¤‘ì‹¬ì  ê²€ì‚¬
                    dist = hypot(cx - center[0], cy - center[1])
                    if abs(dist - radius) <= 2:
                        touching = True
                    else:
                        # ì‹œì‘ì ê³¼ ëì  ê²€ì‚¬
                        start_angle = radians(e.dxf.start_angle)
                        end_angle = radians(e.dxf.end_angle)
                        
                        # ì‹œì‘ì 
                        sx = cx + r * cos(start_angle)
                        sy = cy + r * sin(start_angle)
                        dist = hypot(sx - center[0], sy - center[1])
                        if abs(dist - radius) <= 2:
                            touching = True
                        
                        # ëì 
                        if not touching:
                            ex = cx + r * cos(end_angle)
                            ey = cy + r * sin(end_angle)
                            dist = hypot(ex - center[0], ey - center[1])
                            if abs(dist - radius) <= 2:
                                touching = True
                
                if touching:
                    entities.append(e)
                    print(f"  TEE ë ˆì´ì–´ {e.dxf.layer} ì—”í‹°í‹° ë°œê²¬ (ëª¨ë“  ì  ê²€ì‚¬): {e.dxftype()}")
    
    return entities

def find_sfw_polylines_near_point(doc, point, search_radius):
    """íŠ¹ì • ì ì—ì„œ ì§€ì •ëœ ë°˜ê²½ ë‚´ì˜ SFW ë ˆì´ì–´ 6ì  í´ë¦¬ë¼ì¸ ì°¾ê¸°"""
    msp = doc.modelspace()
    sfw_polylines = []
    
    for e in msp:
        if e.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
            if hasattr(e, 'dxf') and hasattr(e.dxf, 'layer'):
                if e.dxf.layer.upper() == 'SFW':
                    # ì  ê°œìˆ˜ í™•ì¸
                    if e.dxftype() == 'LWPOLYLINE':
                        points = list(e.get_points())
                        # ì¤‘ì‹¬ì  ê³„ì‚°
                        center_x = sum(p[0] for p in points) / 6
                        center_y = sum(p[1] for p in points) / 6
                        # ê° ì ê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
                        min_point_dist = float('inf')
                        for p in points:
                            dist = hypot(p[0] - point[0], p[1] - point[1])
                            min_point_dist = min(min_point_dist, dist)
                    else:
                        points = list(e.vertices)
                        # ì¤‘ì‹¬ì  ê³„ì‚°
                        center_x = sum(v.dxf.location.x for v in points) / 6
                        center_y = sum(v.dxf.location.y for v in points) / 6
                        # ê° ì ê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬ ê³„ì‚°
                        min_point_dist = float('inf')
                        for v in points:
                            dist = hypot(v.dxf.location.x - point[0], v.dxf.location.y - point[1])
                            min_point_dist = min(min_point_dist, dist)
                    
                    if len(points) == 6:
                        # ì¤‘ì‹¬ì ê¹Œì§€ì˜ ê±°ë¦¬
                        center_dist = hypot(center_x - point[0], center_y - point[1])
                        
                        # ìµœì†Œ ê±°ë¦¬ê°€ ê²€ìƒ‰ ë°˜ê²½ ë‚´ì— ìˆìœ¼ë©´ ì¶”ê°€
                        if min_point_dist <= search_radius:
                            sfw_polylines.append({
                                'entity': e,
                                'center': (center_x, center_y),
                                'center_distance': center_dist,
                                'min_point_distance': min_point_dist
                            })
    
    return sorted(sfw_polylines, key=lambda x: x['min_point_distance'])

# ìƒˆë¡œìš´ í•¨ìˆ˜ ì¶”ê°€ - ê²€ìƒ‰ ê±°ë¦¬ë¥¼ 5mmë¡œ ë³€ê²½
def find_a2_polylines_near_sfw_center(doc, sfw_center, search_radius=5.0):
    """SFW ì¤‘ì‹¬ì—ì„œ ì§€ì •ëœ ë°˜ê²½ ë‚´ì— ëì ì´ ìˆëŠ” 2-3ì  í´ë¦¬ë¼ì¸ ì°¾ê¸° (PIPE ë ˆì´ì–´ ì œì™¸)"""
    msp = doc.modelspace()
    a2_candidates = []
    
    for e in msp:
        if e.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
            # PIPE ë ˆì´ì–´ëŠ” ì œì™¸
            if hasattr(e.dxf, 'layer') and e.dxf.layer.upper() == 'PIPE':
                continue
                
            # ê³¡ì„ (bulge)ì´ ìˆëŠ” í´ë¦¬ë¼ì¸ì€ ì œì™¸
            if has_bulge(e):
                continue
                
            # ì ë“¤ ê°€ì ¸ì˜¤ê¸°
            if e.dxftype() == 'LWPOLYLINE':
                points = list(e.get_points())
            else:
                points = [(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
            
            # 2-3ì ì¸ ê²½ìš°ë§Œ
            if 2 <= len(points) <= 3:
                # ì ê°„ ê±°ë¦¬ ê³„ì‚°
                total_length = 0
                for i in range(len(points) - 1):
                    dist = hypot(points[i+1][0] - points[i][0], 
                               points[i+1][1] - points[i][1])
                    total_length += dist
                
                # ì ê°„ ê±°ë¦¬ê°€ 5mm ì´ìƒì¸ ê²½ìš°ë§Œ
                if total_length >= 5:
                    # ëì  ì¤‘ í•˜ë‚˜ê°€ SFW ì¤‘ì‹¬ 5mm ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                    first_point = (points[0][0], points[0][1])
                    last_point = (points[-1][0], points[-1][1])
                    
                    dist_first = hypot(first_point[0] - sfw_center[0], 
                                     first_point[1] - sfw_center[1])
                    dist_last = hypot(last_point[0] - sfw_center[0], 
                                    last_point[1] - sfw_center[1])
                    
                    if dist_first <= search_radius or dist_last <= search_radius:
                        # SFWì—ì„œ ê°€ì¥ ë¨¼ ëì  ì°¾ê¸°
                        if dist_first < dist_last:
                            far_point = last_point
                            far_dist = dist_last
                        else:
                            far_point = first_point
                            far_dist = dist_first
                        
                        a2_candidates.append({
                            'entity': e,
                            'points': points,
                            'far_point': far_point,
                            'far_distance': far_dist,
                            'total_length': total_length
                        })
    
    return a2_candidates

def find_sftype_for_wno(all_texts, wno_x, wno_y):
    """WNO ìœ„ì¹˜ì—ì„œ +X 25mm, Y Â±1mm ë²”ìœ„ ë‚´ì—ì„œ ê¸°ìš¸ê¸° 0ì¸ 'S', 'F', 'FF' í…ìŠ¤íŠ¸ ì°¾ê¸°"""
    for text, x, y, e in all_texts:
        # XëŠ” WNOë³´ë‹¤ 25mm ì˜¤ë¥¸ìª½, YëŠ” Â±1mm ë²”ìœ„
        if (wno_x < x <= wno_x + 25 and 
            abs(y - wno_y) <= 1 and 
            abs(e.dxf.rotation) < 0.1):  # íšŒì „ê° 0
            
            text_upper = text.strip().upper()
            if text_upper in ['S', 'F', 'FF']:
                print(f"  ğŸ“ SFTYPE ì°¾ìŒ: {text_upper} at ({x:.2f}, {y:.2f})")
                return text_upper
    return None

def process_weld_data(doc, all_texts, headers, dn_x, materials_x, bore_value):
    """ìš©ì ‘ ê´€ë ¨ ë°ì´í„° ì²˜ë¦¬ ë° ìˆ˜ì§‘ - materials_xëŠ” FABRICATION ë˜ëŠ” ERECTION MATERIALSì˜ x ì¢Œí‘œ"""
    if 'NO' not in headers:
        return {}
    
    msp = doc.modelspace()
    no_x, no_y = headers['NO']
    weld_data = {}  # ê° í–‰ì˜ WBOREì™€ WTYPE ì •ë³´ë¥¼ ì €ì¥
    redu_sw_data = {}  # REDUì— ëŒ€í•œ SW ì •ë³´ ì €ì¥
    all_sw_info = {}  # ëª¨ë“  WNOì˜ SW ì •ë³´ë¥¼ ì €ì¥ (REDU ì²˜ë¦¬ìš©)
    skip_wtype_search = None  # REDU ì²˜ë¦¬ë¡œ WTYPE ê²€ìƒ‰ì„ ê±´ë„ˆë›¸ WNO
    all_wno_sw_info = {}  # ëª¨ë“  WNOì˜ SW ì •ë³´ ì €ì¥ (TEE í›„ì²˜ë¦¬ìš©)
    
    # ì „ì—­ ì¶”ì  ë³€ìˆ˜ - ì‚¬ìš©ëœ ì—”í‹°í‹°ë“¤ ì¶”ì 
    global_used_sw = set()  # ì‚¬ìš©ëœ SW ì› ID
    global_used_wtype = set()  # ì‚¬ìš©ëœ OLET/WOLET/REDU ì—”í‹°í‹° ID
    global_used_sfw = set()  # ì‚¬ìš©ëœ SFW ì—”í‹°í‹° ID
    
    # NO ì•„ë˜ì˜ ìˆ«ìë“¤ ì°¾ê¸° (WNO)
    wno_list = []
    y_positions = sorted(
        set(t[2] for t in all_texts if abs(t[1] - no_x) < 1 and t[2] < no_y and t[0].strip()),
        reverse=True
    )
    
    for y in y_positions:
        no_texts = [t for t in all_texts if abs(t[1] - no_x) < 1 and abs(t[2] - y) < 0.5]
        for text, x, y2, e in no_texts:
            if text.strip().isdigit():  # ì •ê·œì‹ ëŒ€ì‹  isdigit() ì‚¬ìš©
                wno_list.append((text.strip(), x, y2, e))
                e.dxf.color = 4  # CYAN
                print(f"âœ… WNO ì°¾ìŒ: {text.strip()} at ({x}, {y2})")
    
    # ê° WNOì— ëŒ€í•´ ì²˜ë¦¬
    for idx, (wno, wno_x, wno_y, wno_entity) in enumerate(wno_list):
        # ê° WNOë§ˆë‹¤ ì‚¬ìš©ëœ í…ìŠ¤íŠ¸ ì¶”ì  (ë…ë¦½ì )
        local_used_texts = set()
        
        # WNOì— ëŒ€í•œ SFTYPE ì°¾ê¸°
        sftype = find_sftype_for_wno(all_texts, wno_x, wno_y)
        
        # REDU ì²˜ë¦¬ë¡œ ì¸í•´ WTYPE ê²€ìƒ‰ì„ ê±´ë„ˆë›¸ì§€ í™•ì¸
        skip_wtype_for_this_wno = (skip_wtype_search is not None and int(wno) == skip_wtype_search)
        if skip_wtype_for_this_wno:
            print(f"ğŸ” WNO {wno}ëŠ” REDU ì²˜ë¦¬ë¡œ ì¸í•´ WTYPE ê²€ìƒ‰ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
            skip_wtype_search = None  # í•œ ë²ˆë§Œ ê±´ë„ˆë›°ê¸°
            
        # SWNO ì°¾ê¸°
        swno_candidates = []
        for text, x, y, e in all_texts:
            # ì¡°ê±´: materials_x - 10ë³´ë‹¤ ì‘ê³ , no_yë³´ë‹¤ ìœ„ì— ìˆê³ , íšŒì „ê° 0, WNOì™€ ê°™ì€ ìˆ«ì
            if (x < materials_x - 10 and y > no_y and 
                text.strip() == wno and 
                abs(e.dxf.rotation) < 0.1):  # íšŒì „ê° 0
                
                # 3mm ì´í•˜ ì› ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
                circles_3mm = find_circle_entities(doc, 3)
                for circle in circles_3mm:
                    center = (circle.dxf.center.x, circle.dxf.center.y)
                    if hypot(x - center[0], y - center[1]) <= 3:
                        swno_candidates.append((text, x, y, e, center))
                        e.dxf.color = 4  # CYAN
                        e.dxf.layer = 'WDNO'
                        print(f"âœ… SWNO ì°¾ìŒ: {text} at ({x}, {y})")
                        break
        
        # ê° SWNOì— ëŒ€í•´ ì²˜ë¦¬
        for swno_text, swno_x, swno_y, swno_entity, circle_center in swno_candidates:
            print(f"\n  SWNO {swno_text} ì²˜ë¦¬ ì¤‘...")
            
            # 1. SWNOë¡œë¶€í„° 30mm ë‚´ì— ê°€ì¥ ê°€ê¹Œìš´ SW ë ˆì´ì–´ ì› ì°¾ê¸°
            sw_circles = find_circles_by_layer(doc, 'SW')
            print(f"  SW ë ˆì´ì–´ ì› ê°œìˆ˜: {len(sw_circles)}")
            
            closest_sw_circle = None
            min_sw_dist = float('inf')
            
            for circle in sw_circles:
                # ì´ë¯¸ ì‚¬ìš©ëœ SWëŠ” ì œì™¸
                if id(circle) in global_used_sw:
                    continue
                    
                center = (circle.dxf.center.x, circle.dxf.center.y)
                dist = hypot(center[0] - swno_x, center[1] - swno_y)
                if dist <= 30 and dist < min_sw_dist:
                    min_sw_dist = dist
                    closest_sw_circle = circle
            
            # SW ì›ì„ ì°¾ì•˜ê³  SFTYPEì´ ìˆìœ¼ë©´ ë ˆì´ì–´ ë³€ê²½
            if closest_sw_circle and sftype:
                if sftype == 'F':
                    closest_sw_circle.dxf.layer = 'FW'
                    print(f"  ğŸ”„ SW ë ˆì´ì–´ë¥¼ FWë¡œ ë³€ê²½ (SFTYPE: F)")
                elif sftype == 'FF':
                    closest_sw_circle.dxf.layer = 'FFW'
                    print(f"  ğŸ”„ SW ë ˆì´ì–´ë¥¼ FFWë¡œ ë³€ê²½ (SFTYPE: FF)")
                # sftype == 'S'ì¸ ê²½ìš°ëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ
            
            # 2. SWNO 30mm ë‚´ì—ì„œ SFW 6ì  í´ë¦¬ë¼ì¸(SD) ì°¾ê¸°
            sfw_polylines = find_sfw_polylines_near_point(doc, (swno_x, swno_y), 30)
            
            # ì‚¬ìš©ë˜ì§€ ì•Šì€ SFWë§Œ í•„í„°ë§
            available_sfw = []
            for sfw in sfw_polylines:
                if id(sfw['entity']) not in global_used_sfw:
                    available_sfw.append(sfw)
            
            # 3. SWì™€ SFW ì¤‘ ë” ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
            use_sfw = False
            selected_sfw = None
            
            if available_sfw and closest_sw_circle:
                # ë‘˜ ë‹¤ ìˆì„ ë•Œ: SFWì˜ ê°€ì¥ ê°€ê¹Œìš´ ì ê³¼ SW ì¤‘ì‹¬ ê±°ë¦¬ ë¹„êµ
                closest_sfw = available_sfw[0]  # ê°€ì¥ ê°€ê¹Œìš´ ì  ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ë¨
                if closest_sfw['min_point_distance'] < min_sw_dist:
                    use_sfw = True
                    selected_sfw = closest_sfw
                    print(f"  ğŸ”„ SFWê°€ SWë³´ë‹¤ ê°€ê¹Œì›€ (SFW ì : {closest_sfw['min_point_distance']:.2f}mm vs SW: {min_sw_dist:.2f}mm)")
            elif available_sfw and not closest_sw_circle:
                # SFWë§Œ ìˆì„ ë•Œ
                use_sfw = True
                selected_sfw = available_sfw[0]
                print(f"  ğŸ”„ SW ì—†ìŒ, SFW ì‚¬ìš©")
            
            # 4. SFW ì²˜ë¦¬
            if use_sfw and selected_sfw:
                sd_entity = selected_sfw['entity']
                sd_center = selected_sfw['center']
                sd_entity.dxf.color = 1  # REDë¡œ ë³€ê²½
                
                print(f"  ğŸ“ SD ì¤‘ì‹¬: ({sd_center[0]:.2f}, {sd_center[1]:.2f})")
                print(f"  ğŸ”´ SFW ìƒ‰ìƒì„ REDë¡œ ë³€ê²½")
                
                # SD ì¤‘ì‹¬ì—ì„œ 0~13mm ë‚´ PIPE_ ë ˆì´ì–´ ì°¾ê¸°
                pipe_entities = find_pipe_entities_near_center(doc, sd_center, 13.0)
                
                if pipe_entities:
                    # ì²« ë²ˆì§¸ PIPE_ ì—”í‹°í‹° ì²˜ë¦¬
                    pipe_entity = pipe_entities[0]
                    
                    # WD ì¶”ì¶œ
                    wd = extract_wd_from_pipe_layer(pipe_entity.dxf.layer)
                    if wd is not None:
                        # WDê°€ 55ë¥¼ ë„˜ìœ¼ë©´ SKIPí•˜ê³  SW ì²˜ë¦¬ë¡œ ì „í™˜
                        if wd > 55:
                            print(f"  âš  WD ê°’ì´ 55ë¥¼ ì´ˆê³¼ (WD={wd}), SFW ì¤‘ì‹¬ì—ì„œ SW ì› ê²€ìƒ‰ìœ¼ë¡œ ì „í™˜")
                            
                            # SFW ì¤‘ì‹¬ì—ì„œ 10mm ë²”ìœ„ì— SW ì› ì°¾ê¸°
                            sw_circles_near_sfw = []
                            sw_circles = find_circles_by_layer(doc, 'SW')
                            
                            for circle in sw_circles:
                                # ì´ë¯¸ ì‚¬ìš©ëœ SWëŠ” ì œì™¸
                                if id(circle) in global_used_sw:
                                    continue
                                    
                                center = (circle.dxf.center.x, circle.dxf.center.y)
                                dist = hypot(center[0] - sd_center[0], center[1] - sd_center[1])
                                if dist <= 10:  # 10mm ë²”ìœ„
                                    sw_circles_near_sfw.append((circle, dist))
                            
                            if sw_circles_near_sfw:
                                # ê°€ì¥ ê°€ê¹Œìš´ SW ì› ì„ íƒ
                                sw_circle, sw_dist = min(sw_circles_near_sfw, key=lambda x: x[1])
                                sw_circle.dxf.color = 1  # RED
                                sw_center = (sw_circle.dxf.center.x, sw_circle.dxf.center.y)
                                sw_radius = sw_circle.dxf.radius
                                print(f"  âœ… SFW ì¤‘ì‹¬ì—ì„œ SW ì› ì°¾ìŒ (ê±°ë¦¬: {sw_dist:.2f}mm)")
                                
                                # SFTYPEì— ë”°ë¼ ë ˆì´ì–´ ë³€ê²½
                                if sftype == 'F':
                                    sw_circle.dxf.layer = 'FW'
                                    print(f"  ğŸ”„ SW ë ˆì´ì–´ë¥¼ FWë¡œ ë³€ê²½ (SFTYPE: F)")
                                elif sftype == 'FF':
                                    sw_circle.dxf.layer = 'FFW'
                                    print(f"  ğŸ”„ SW ë ˆì´ì–´ë¥¼ FFWë¡œ ë³€ê²½ (SFTYPE: FF)")
                                
                                # ì‚¬ìš©ëœ SW ì¶”ì ì— ì¶”ê°€
                                global_used_sw.add(id(sw_circle))
                                
                                # SW ì›ì— ì ‘í•˜ëŠ” OLET ì°¾ê¸°
                                touching_entities = find_entities_touching_circle(doc, sw_circle, ['OLET'])
                                
                                # ì‚¬ìš©ë˜ì§€ ì•Šì€ ì—”í‹°í‹°ë§Œ í•„í„°ë§
                                available_entities = []
                                for entity in touching_entities:
                                    if id(entity) not in global_used_wtype:
                                        available_entities.append(entity)
                                
                                for wtype_entity in available_entities:
                                    wtype_entity.dxf.color = 4  # CYAN
                                    wtype_found = wtype_entity.dxf.layer.upper()
                                    wtype_pos = get_entity_position(wtype_entity)
                                    print(f"  âœ… OLET ì°¾ìŒ, ìƒ‰ìƒì„ CYANìœ¼ë¡œ ë³€ê²½")
                                    
                                    # ì‚¬ìš©ëœ OLET ì¶”ì ì— ì¶”ê°€
                                    global_used_wtype.add(id(wtype_entity))
                                    
                                    # OLETì˜ ì„ ë¶„ì— ì ‘í•˜ëŠ” 2-3ì  í´ë¦¬ë¼ì¸(A2) ì°¾ê¸°
                                    a2_polylines = find_polylines_touching_entity(doc, wtype_entity, exclude_layers=['PIPE'])
                                    
                                    for poly in a2_polylines:
                                        poly.dxf.color = 4  # CYAN
                                        print(f"  A2 í´ë¦¬ë¼ì¸ ì°¾ìŒ, ìƒ‰ìƒì„ CYANìœ¼ë¡œ ë³€ê²½")
                                        
                                        # A2ì˜ ì ë“¤ ì¤‘ OLETì—ì„œ ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
                                        if poly.dxftype() == 'LWPOLYLINE':
                                            points = list(poly.get_points())
                                        else:
                                            points = [(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                                        
                                        max_dist = 0
                                        far_point = None
                                        for p in points:
                                            px, py = p[0], p[1]
                                            dist = hypot(px - wtype_pos[0], py - wtype_pos[1])
                                            if dist > max_dist:
                                                max_dist = dist
                                                far_point = (px, py)
                                        
                                        if far_point:
                                            # ê°€ì¥ ë¨¼ ì ì—ì„œ xê°€ í¬í•¨ëœ ìˆ«ì ì°¾ê¸°
                                            for text, x, y, e in all_texts:
                                                if hypot(x - far_point[0], y - far_point[1]) < 25:
                                                    if 'x' in text.lower() and re.search(r'\d+', text):
                                                        # ì´ SWNO ë‚´ì—ì„œ ì‚¬ìš©ëœ í…ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
                                                        if id(e) not in local_used_texts:
                                                            e.dxf.color = 4  # CYAN
                                                            print(f"  x í¬í•¨ í…ìŠ¤íŠ¸ ì°¾ìŒ: {text}")
                                                            
                                                            # x ë’¤ì˜ ìˆ«ìë§Œ ì¶”ì¶œ
                                                            wbore_match = re.search(r'[xX]\s*(\d+)', text)
                                                            if wbore_match:
                                                                wbore = wbore_match.group(1)
                                                                wtype = '  OLET'
                                                                
                                                                weld_data[wno_y] = {
                                                                    'wbore': wbore,
                                                                    'wtype': wtype
                                                                }
                                                                print(f"  âœ… SFWâ†’SWâ†’OLET ë°©ì‹ìœ¼ë¡œ WBORE: {wbore}, WTYPE: {wtype} ë°ì´í„° ì €ì¥ ì™„ë£Œ")
                                                                
                                                                # ì´ SWNO ë‚´ì—ì„œë§Œ ì¶”ì 
                                                                local_used_texts.add(id(e))
                                                                # ì‚¬ìš©ëœ SFW ì¶”ì ì— ì¶”ê°€
                                                                global_used_sfw.add(id(sd_entity))
                                                                break
                                    break  # ì²« ë²ˆì§¸ OLETë§Œ ì²˜ë¦¬
                                
                                if wno_y in weld_data:
                                    continue  # ë‹¤ìŒ SWNOë¡œ
                                else:
                                    print(f"  âš  SFWâ†’SWâ†’OLET ì²˜ë¦¬ ì‹¤íŒ¨")
                            else:
                                print(f"  âš  SFW ì¤‘ì‹¬ 10mm ë‚´ì— SW ì›ì„ ì°¾ì§€ ëª»í•¨")
                        else:
                            # WDê°€ 55 ì´í•˜ì¸ ê²½ìš° ê¸°ì¡´ ì²˜ë¦¬
                            pipe_entity.dxf.color = 4  # CYAN
                            wbore = str(wd)
                            wtype = '  BW' if wd >= 51 else '  SW'
                            
                            weld_data[wno_y] = {
                                'wbore': wbore,
                                'wtype': wtype
                            }
                            print(f"  âœ… SFW(SD) ë°©ì‹ìœ¼ë¡œ WBORE: {wbore}, WTYPE: {wtype} ë°ì´í„° ì €ì¥ ì™„ë£Œ")
                            print(f"     ë ˆì´ì–´ëª…: {pipe_entity.dxf.layer}")
                            
                            # ì‚¬ìš©ëœ SFW ì¶”ì ì— ì¶”ê°€
                            global_used_sfw.add(id(sd_entity))
                            continue  # ë‹¤ìŒ SWNOë¡œ
                else:
                    print(f"  âš  SD ì¤‘ì‹¬ 13mm ë‚´ì— PIPE_ ë ˆì´ì–´ë¥¼ ì°¾ì§€ ëª»í•¨.")
                    
                    # ìƒˆë¡œìš´ A2 ì²˜ë¦¬ ì¶”ê°€
                    print(f"  ğŸ” SFW ì¤‘ì‹¬ì—ì„œ A2 í´ë¦¬ë¼ì¸ ê²€ìƒ‰ ì‹œì‘...")
                    a2_polylines = find_a2_polylines_near_sfw_center(doc, sd_center, 5.0)  # 5mmë¡œ ë³€ê²½
                    
                    if a2_polylines:
                        print(f"  âœ… {len(a2_polylines)}ê°œì˜ A2 í´ë¦¬ë¼ì¸ ë°œê²¬")
                        
                        a2_text_found = False
                        for idx, a2_info in enumerate(a2_polylines):
                            a2_entity = a2_info['entity']
                            far_point = a2_info['far_point']
                            
                            print(f"    A2 #{idx+1}: ê¸¸ì´={a2_info['total_length']:.2f}mm")
                            print(f"    ê°€ì¥ ë¨¼ ì : ({far_point[0]:.2f}, {far_point[1]:.2f})")
                            
                            # A2ë¥¼ ì¦‰ì‹œ REDë¡œ ë³€ê²½
                            a2_entity.dxf.color = 1  # RED
                            print(f"    ğŸ”´ A2 í´ë¦¬ë¼ì¸ ìƒ‰ìƒì„ REDë¡œ ë³€ê²½")
                            
                            # ê°€ì¥ ë¨¼ ëì ì—ì„œ 30mm ë‚´ 'x' í¬í•¨ í…ìŠ¤íŠ¸ ì°¾ê¸° (SWì™€ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ë³€ê²½)
                            for text, x, y, e in all_texts:
                                if hypot(x - far_point[0], y - far_point[1]) <= 30:
                                    # SWì™€ ë™ì¼í•œ ì¡°ê±´ìœ¼ë¡œ ë³€ê²½: xê°€ í¬í•¨ë˜ê³  ìˆ«ìê°€ ìˆëŠ” í…ìŠ¤íŠ¸
                                    if 'x' in text.lower() and re.search(r'\d+', text):
                                        # ì´ SWNO ë‚´ì—ì„œ ì‚¬ìš©ëœ í…ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
                                        if id(e) not in local_used_texts:
                                            # x ë’¤ì˜ ìˆ«ì ì¶”ì¶œ (SWì™€ ë™ì¼í•œ íŒ¨í„´)
                                            match = re.search(r'[xX]\s*(\d+)', text)
                                            if match:
                                                wbore = match.group(1)
                                                wtype = '  SW'  # í•­ìƒ SWë¡œ ì„¤ì •
                                                
                                                # ë°ì´í„° ì €ì¥
                                                weld_data[wno_y] = {
                                                    'wbore': wbore,
                                                    'wtype': wtype
                                                }
                                                
                                                print(f"    âœ… x í…ìŠ¤íŠ¸ ë°œê²¬: {text}")
                                                print(f"    âœ… SFWâ†’A2 ë°©ì‹ìœ¼ë¡œ WBORE: {wbore}, WTYPE: {wtype}")
                                                
                                                # ì´ SWNO ë‚´ì—ì„œë§Œ ì¶”ì 
                                                local_used_texts.add(id(e))
                                                global_used_sfw.add(id(sd_entity))
                                                a2_text_found = True
                                                break
                            
                            if a2_text_found:
                                break
                        
                        if not a2_text_found:
                            print(f"  âš  A2 í´ë¦¬ë¼ì¸ì€ ì°¾ì•˜ìœ¼ë‚˜ x í…ìŠ¤íŠ¸ë¥¼ ì°¾ì§€ ëª»í•¨")
                            print(f"  ğŸ”„ SFW ëŒ€ì‹  SWë¡œ ì „í™˜í•˜ì—¬ ì²˜ë¦¬ ì‹œë„...")
                            use_sfw = False  # SW ì²˜ë¦¬ë¡œ ì „í™˜
                    else:
                        print(f"  âš  SFW ì¤‘ì‹¬ 5mm ë‚´ì— ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” A2ë¥¼ ì°¾ì§€ ëª»í•¨")
                        print(f"  ğŸ”„ SFW ëŒ€ì‹  SWë¡œ ì „í™˜í•˜ì—¬ ì²˜ë¦¬ ì‹œë„...")
                        use_sfw = False  # SW ì²˜ë¦¬ë¡œ ì „í™˜
            
            # 5. SW ì²˜ë¦¬ (SFWë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²½ìš°)
            if closest_sw_circle and not use_sfw:
                closest_sw_circle.dxf.color = 1  # RED
                sw_center = (closest_sw_circle.dxf.center.x, closest_sw_circle.dxf.center.y)
                sw_radius = closest_sw_circle.dxf.radius
                print(f"âœ… SW ì› ì°¾ìŒ (ê±°ë¦¬: {min_sw_dist:.2f}mm), ìƒ‰ìƒì„ REDë¡œ ë³€ê²½")
                
                # ì‚¬ìš©ëœ SW ì¶”ì ì— ì¶”ê°€
                global_used_sw.add(id(closest_sw_circle))
                
                # ëª¨ë“  WNOì˜ SW ì •ë³´ ì €ì¥ (REDU ì²˜ë¦¬ë¥¼ ìœ„í•´)
                all_sw_info[int(wno)] = {
                    'circle': closest_sw_circle,
                    'center': sw_center,
                    'radius': sw_radius,
                    'wno_y': wno_y
                }
                
                # TEE í›„ì²˜ë¦¬ë¥¼ ìœ„í•œ SW ì •ë³´ ì €ì¥
                all_wno_sw_info[wno_y] = {
                    'wno': wno,
                    'circle': closest_sw_circle,
                    'center': sw_center,
                    'radius': sw_radius
                }
                
                # WTYPE ê²€ìƒ‰ì„ ê±´ë„ˆë›°ì–´ì•¼ í•˜ëŠ” ê²½ìš°
                if skip_wtype_for_this_wno:
                    print(f"  â­ï¸ WNO {wno}ì˜ WTYPE ê²€ìƒ‰ì„ ê±´ë„ˆëœë‹ˆë‹¤ (REDU í›„ì²˜ë¦¬ì—ì„œ ì²˜ë¦¬ë¨)")
                    continue
                
                # 2. SW ì›ì— ì ‘í•˜ëŠ” OLET/WOLET/REDU ë ˆì´ì–´ ì°¾ê¸°
                touching_entities = find_entities_touching_circle(doc, closest_sw_circle, ['OLET', 'WOLET', 'REDU'])
                
                # ì‚¬ìš©ë˜ì§€ ì•Šì€ ì—”í‹°í‹°ë§Œ í•„í„°ë§
                available_entities = []
                for entity in touching_entities:
                    if id(entity) not in global_used_wtype:
                        available_entities.append(entity)
                
                for wtype_entity in available_entities:
                    wtype_entity.dxf.color = 4  # CYAN
                    wtype_found = wtype_entity.dxf.layer.upper()
                    wtype_pos = get_entity_position(wtype_entity)
                    print(f"âœ… WTYPE ì°¾ìŒ: {wtype_found}, ìƒ‰ìƒì„ CYANìœ¼ë¡œ ë³€ê²½")
                    
                    # ì‚¬ìš©ëœ WTYPE ì¶”ì ì— ì¶”ê°€
                    global_used_wtype.add(id(wtype_entity))
                    
                    # REDUì¸ ê²½ìš° íŠ¹ë³„ ì²˜ë¦¬
                    if wtype_found == 'REDU':
                        print(f"\n  âš¡ REDU íŠ¹ë³„ ì²˜ë¦¬ ì‹œì‘!")
                        print(f"  ğŸ”´ REDU ë°œê²¬! WNO: {wno}")
                        
                        # ë‹¤ìŒ WNOëŠ” WTYPE ê²€ìƒ‰ì„ ê±´ë„ˆë›°ë„ë¡ ì„¤ì •
                        skip_wtype_search = int(wno) + 1
                        print(f"  â­ï¸ ë‹¤ìŒ WNO {skip_wtype_search}ëŠ” WTYPE ê²€ìƒ‰ì„ ê±´ë„ˆë›¸ ì˜ˆì •")
                        
                        # REDUì˜ ì„ ë¶„ë“¤ êµ¬í•˜ê¸°
                        segments = get_segment_lengths(wtype_entity)
                        print(f"  ğŸ“ REDU ì„ ë¶„ ê°œìˆ˜: {len(segments)}")
                        for i, seg in enumerate(segments):
                            print(f"     ì„ ë¶„ {i+1}: ê¸¸ì´ = {seg['length']:.2f}mm")
                        
                        # SWê°€ ì ‘í•˜ëŠ” ì„ ë¶„ ì°¾ê¸° (ëª¨ë“  ì ‘ì´‰ ì„ ë¶„ì˜ ì •ë³´ ì €ì¥)
                        total_length, touching_segs = get_total_contact_length(sw_center, sw_radius, segments)
                        
                        if total_length > 0:
                            print(f"  ğŸ¯ SW ì›ì´ ì ‘í•˜ëŠ” ì„ ë¶„ {len(touching_segs)}ê°œ, ì´ ê¸¸ì´ = {total_length:.2f}mm")
                            
                            # REDU ì •ë³´ ì €ì¥ - ê° REDUë§ˆë‹¤ ê³ ìœ í•œ ID ì‚¬ìš©
                            redu_key = f"{id(wtype_entity)}_{int(wno)}"  # REDU ì—”í‹°í‹° IDì™€ WNO ì¡°í•©
                            print(f"  ğŸ’¾ REDU ì—”í‹°í‹° ë“±ë¡ (í‚¤: {redu_key})")
                            redu_sw_data[redu_key] = {
                                'entity': wtype_entity,
                                'segments': segments,
                                'sw_circles': [],
                                'rsize_text': None,
                                'first_wno': int(wno)  # ì´ REDUì˜ ì²« ë²ˆì§¸ WNO
                            }
                            
                            redu_sw_data[redu_key]['sw_circles'].append({
                                'circle': closest_sw_circle,
                                'center': sw_center,
                                'touching_segments': touching_segs,
                                'total_length': total_length,
                                'wno': wno,
                                'wno_y': wno_y,
                                'idx': idx
                            })
                            print(f"  â• SW ì› ì •ë³´ ì¶”ê°€ - WNO: {wno}, ì ‘ì´‰ ì´ ê¸¸ì´: {total_length:.2f}mm")
                        else:
                            print(f"  âŒ SW ì›ì´ ì ‘í•˜ëŠ” ì„ ë¶„ì„ ì°¾ì§€ ëª»í•¨")
                    
                    # 3. WTYPEì˜ ì„ ë¶„ì— ì ‘í•˜ëŠ” 2-3ì  í´ë¦¬ë¼ì¸ ì°¾ê¸° (PIPE ë ˆì´ì–´ ì œì™¸)
                    a2_polylines = find_polylines_touching_entity(doc, wtype_entity, exclude_layers=['PIPE'])
                    
                    for poly in a2_polylines:
                        poly.dxf.color = 4  # CYAN
                        print(f"  A2 í´ë¦¬ë¼ì¸ ì°¾ìŒ, ìƒ‰ìƒì„ CYANìœ¼ë¡œ ë³€ê²½")
                        
                        # 4. A2ì˜ ì ë“¤ ì¤‘ WTYPEì—ì„œ ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
                        if poly.dxftype() == 'LWPOLYLINE':
                            points = list(poly.get_points())
                        else:
                            points = [(v.dxf.location.x, v.dxf.location.y) for v in poly.vertices]
                        
                        max_dist = 0
                        far_point = None
                        for p in points:
                            px, py = p[0], p[1]
                            dist = hypot(px - wtype_pos[0], py - wtype_pos[1])
                            if dist > max_dist:
                                max_dist = dist
                                far_point = (px, py)
                        
                        if far_point:
                            # 5. ê°€ì¥ ë¨¼ ì ì—ì„œ xê°€ í¬í•¨ëœ ìˆ«ì ì°¾ê¸° (25mm ì´ë‚´ë¡œ ë³€ê²½)
                            for text, x, y, e in all_texts:
                                if hypot(x - far_point[0], y - far_point[1]) < 25:  # 25mm ë‚´
                                    if 'x' in text.lower() and re.search(r'\d+', text):
                                        # ì´ SWNO ë‚´ì—ì„œ ì‚¬ìš©ëœ í…ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
                                        if id(e) not in local_used_texts:
                                            e.dxf.color = 4  # CYAN
                                            print(f"  x í¬í•¨ í…ìŠ¤íŠ¸ ì°¾ìŒ: {text}, ìƒ‰ìƒì„ CYANìœ¼ë¡œ ë³€ê²½")
                                            
                                            # REDUì¸ ê²½ìš° RSIZE í…ìŠ¤íŠ¸ ì €ì¥
                                            if wtype_found == 'REDU':
                                                # í˜„ì¬ REDUì˜ í‚¤ ì°¾ê¸°
                                                for redu_key, redu_info in redu_sw_data.items():
                                                    if redu_info['entity'] == wtype_entity and redu_info['first_wno'] == int(wno):
                                                        redu_sw_data[redu_key]['rsize_text'] = text
                                                        print(f"  ğŸ“ REDU RSIZE í…ìŠ¤íŠ¸ ì €ì¥: {text}")
                                                        break
                                            
                                            # x ë’¤ì˜ ìˆ«ìë§Œ ì¶”ì¶œ (ê¸°ë³¸ WBORE)
                                            wbore_match = re.search(r'[xX]\s*(\d+)', text)
                                            if wbore_match:
                                                wbore = wbore_match.group(1)
                                                
                                                # REDUê°€ ì•„ë‹Œ ê²½ìš° ë°”ë¡œ ì €ì¥
                                                if wtype_found != 'REDU':
                                                    # OLET/WOLETì˜ ê²½ìš° WTYPE ì„¤ì •
                                                    if wtype_found == 'OLET':
                                                        final_wtype = '  OLET'
                                                    elif wtype_found == 'WOLET':
                                                        final_wtype = '  WOLET'
                                                    else:
                                                        final_wtype = wtype_found
                                                    
                                                    weld_data[wno_y] = {
                                                        'wbore': wbore,
                                                        'wtype': final_wtype
                                                    }
                                                    print(f"âœ… WBORE: {wbore}, WTYPE: {final_wtype} ë°ì´í„° ì €ì¥ ì™„ë£Œ")
                                                    
                                                    # ì´ SWNO ë‚´ì—ì„œë§Œ ì¶”ì 
                                                    local_used_texts.add(id(e))
                                                break
                    break  # ì²« ë²ˆì§¸ WTYPEë§Œ ì²˜ë¦¬
                
                # WTYPEì„ ì°¾ì§€ ëª»í•œ ê²½ìš° - ì¶”ê°€ ì²˜ë¦¬ ì‹œì‘
                if not available_entities:
                    print(f"  â„¹ï¸ OLET/WOLET/REDUë¥¼ ì°¾ì§€ ëª»í•¨.")
                    
                    # ìƒˆë¡œìš´ ì¶”ê°€: SW ì¤‘ì‹¬ì—ì„œ 3mm ë‚´ PIPE_ ë ˆì´ì–´ ì°¾ê¸°
                    print(f"  ğŸ” SW ì¤‘ì‹¬ì—ì„œ 3mm ë‚´ PIPE_ ë ˆì´ì–´ ê²€ìƒ‰ ì‹œì‘...")
                    pipe_entities = find_pipe_entities_near_center(doc, sw_center, 3.0)
                    
                    if pipe_entities:
                        # ì²« ë²ˆì§¸ PIPE_ ì—”í‹°í‹° ì²˜ë¦¬
                        pipe_entity = pipe_entities[0]
                        pipe_entity.dxf.color = 4  # CYAN
                        
                        # WD ì¶”ì¶œ
                        wd = extract_wd_from_pipe_layer(pipe_entity.dxf.layer)
                        if wd is not None:
                            wbore = str(wd)
                            wtype = '  BW' if wd >= 51 else '  SW'
                            
                            weld_data[wno_y] = {
                                'wbore': wbore,
                                'wtype': wtype
                            }
                            print(f"  âœ… PIPE_ ë°©ì‹ìœ¼ë¡œ WBORE: {wbore}, WTYPE: {wtype} ë°ì´í„° ì €ì¥ ì™„ë£Œ")
                            print(f"     ë ˆì´ì–´ëª…: {pipe_entity.dxf.layer}")
                            continue  # ë‹¤ìŒ WNOë¡œ ì§„í–‰
                    else:
                        print(f"  â„¹ï¸ SW ì¤‘ì‹¬ 3mm ë‚´ì— PIPE_ ë ˆì´ì–´ë¥¼ ì°¾ì§€ ëª»í•¨.")
                    
                    # ê¸°ì¡´ NG2 ì²˜ë¦¬
                    print(f"  â„¹ï¸ NG2 ê²€ìƒ‰ ì‹œì‘...")
                    print(f"     ì¡°ê±´: SW ì› ì¤‘ì‹¬ 2mm ì´ë‚´ ë˜ëŠ” ì› ë‘˜ë ˆ 1mm ì´ë‚´")
                    
                    # NG2 ì°¾ê¸°: SW ì› ì¤‘ì‹¬ì—ì„œ 2mm ì´ë‚´ ë˜ëŠ” ì› ë‘˜ë ˆì—ì„œ 1mm ì´ë‚´ì¸ 2-3ì  í´ë¦¬ë¼ì¸ (PIPE ë ˆì´ì–´ ì œì™¸, ê¸¸ì´ í•© 10mm ì´ˆê³¼)
                    ng2_list = []  # NG2 ì •ë³´ë¥¼ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸
                    
                    for e in msp:
                        if e.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
                            # PIPE ë ˆì´ì–´ëŠ” ì œì™¸
                            if hasattr(e.dxf, 'layer') and e.dxf.layer.upper() == 'PIPE':
                                continue
                            
                            # ê³¡ì„ (bulge)ì´ ìˆëŠ” í´ë¦¬ë¼ì¸ì€ ì œì™¸
                            if has_bulge(e):
                                continue
                            
                            # í´ë¦¬ë¼ì¸ì˜ ì ë“¤
                            if e.dxftype() == 'LWPOLYLINE':
                                poly_points = list(e.get_points())
                            else:
                                poly_points = [(v.dxf.location.x, v.dxf.location.y) for v in e.vertices]
                            
                            # 2-3ì ì¸ ê²½ìš°ë§Œ
                            if 2 <= len(poly_points) <= 3:
                                # í´ë¦¬ë¼ì¸ì˜ ì¤‘ì‹¬ì  ê³„ì‚°
                                center_x = sum(p[0] for p in poly_points) / len(poly_points)
                                center_y = sum(p[1] for p in poly_points) / len(poly_points)
                                
                                # ì¤‘ì‹¬ì ì´ SW ì› ì¤‘ì‹¬ì—ì„œ 2mm ì´ë‚´ì¸ì§€ í™•ì¸
                                center_to_sw = hypot(center_x - sw_center[0], center_y - sw_center[1])
                                
                                # SW ì›ì— ì ‘í•˜ëŠ”ì§€ í™•ì¸ (ì ë§Œ ê²€ì‚¬)
                                touching = False
                                min_dist_to_circle = float('inf')
                                
                                # 0. ì¤‘ì‹¬ì ì´ SW ì¤‘ì‹¬ì—ì„œ 2mm ì´ë‚´ë©´ ì„ íƒ
                                if center_to_sw <= 2:
                                    touching = True
                                    min_dist_to_circle = center_to_sw
                                    print(f"  NG2 ì¤‘ì‹¬ì ì´ SW ì¤‘ì‹¬ì—ì„œ {center_to_sw:.2f}mm")
                                
                                # 1. ì  ê²€ì‚¬ - SW ì› ë‘˜ë ˆì—ì„œ 1mm ì´ë‚´
                                for p in poly_points:
                                    px, py = p[0], p[1]
                                    dist = hypot(px - sw_center[0], py - sw_center[1])
                                    dist_to_circle = abs(dist - sw_radius)
                                    min_dist_to_circle = min(min_dist_to_circle, dist_to_circle)
                                    if dist_to_circle <= 1:  # 1 mm ê³µì°¨
                                        touching = True
                                
                                if touching:
                                    # ê¸¸ì´ í•© ê³„ì‚°
                                    length_sum = 0
                                    segments = []
                                    for i in range(len(poly_points) - 1):
                                        p1 = (poly_points[i][0], poly_points[i][1])
                                        p2 = (poly_points[i+1][0], poly_points[i+1][1])
                                        length = hypot(p2[0] - p1[0], p2[1] - p1[1])
                                        length_sum += length
                                        segments.append(length)
                                    
                                    # ê¸¸ì´ í•©ì´ 10mm ì´ˆê³¼ì¸ ê²½ìš°ë§Œ
                                    if length_sum > 10:
                                        # SWì—ì„œ ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
                                        max_dist_from_sw = 0
                                        far_point = None
                                        for p in poly_points:
                                            px, py = p[0], p[1]
                                            dist = hypot(px - sw_center[0], py - sw_center[1])
                                            if dist > max_dist_from_sw:
                                                max_dist_from_sw = dist
                                                far_point = (px, py)
                                        
                                        ng2_info = {
                                            'entity': e,
                                            'points': [(p[0], p[1]) for p in poly_points],
                                            'length_sum': length_sum,
                                            'far_point': far_point,
                                            'max_dist': max_dist_from_sw,
                                            'min_dist_to_circle': min_dist_to_circle
                                        }
                                        ng2_list.append(ng2_info)
                                        e.dxf.color = 4  # CYAN
                                        print(f"  âœ… NG2 #{len(ng2_list)} ì°¾ìŒ: {len(poly_points)}ì  í´ë¦¬ë¼ì¸")
                                        print(f"     - ê¸¸ì´ í•©: {length_sum:.2f}mm")
                                        print(f"     - SW ì›ê³¼ì˜ ìµœì†Œ ê±°ë¦¬: {min_dist_to_circle:.2f}mm")
                                        print(f"     - SW ì¤‘ì‹¬ì—ì„œ NG2 ì¤‘ì‹¬ê¹Œì§€: {center_to_sw:.2f}mm")
                                        print(f"     - SWì—ì„œ ê°€ì¥ ë¨¼ ì  ê±°ë¦¬: {max_dist_from_sw:.2f}mm")
                    
                    # ëª¨ë“  NG2 ì²˜ë¦¬ (ì„ íƒ ê¸°ì¤€ ì—†ì´ ëª¨ë‘ ì²˜ë¦¬)
                    if ng2_list:
                        text_found = False
                        
                        for idx, ng2_info in enumerate(ng2_list):
                            print(f"\n  ğŸ” NG2 #{idx+1} ì²˜ë¦¬ ì¤‘...")
                            
                            # NG2ì˜ ë¨¼ ì ì—ì„œ 25mm ë‚´ì—ì„œ x í…ìŠ¤íŠ¸ ì°¾ê¸°
                            for text, x, y, e in all_texts:
                                if hypot(x - ng2_info['far_point'][0], y - ng2_info['far_point'][1]) < 25:
                                    if 'x' in text.lower() and re.search(r'\d+', text):
                                        # ì´ SWNO ë‚´ì—ì„œ ì‚¬ìš©ëœ í…ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
                                        if id(e) not in local_used_texts:
                                            e.dxf.color = 4  # CYAN
                                            print(f"    âœ… NG ê´€ë ¨ x í…ìŠ¤íŠ¸ ì°¾ìŒ: {text}")
                                            
                                            # x ë’¤ì˜ ìˆ«ìë§Œ ì¶”ì¶œ
                                            wbore_match = re.search(r'[xX]\s*(\d+)', text)
                                            if wbore_match:
                                                wbore = wbore_match.group(1)
                                                wtype = '  SW' if int(wbore) < 51 else '  BW'
                                                
                                                # ì²« ë²ˆì§¸ ìœ íš¨í•œ í…ìŠ¤íŠ¸ë§Œ ë°ì´í„°ë¡œ ì €ì¥
                                                if not text_found:
                                                    weld_data[wno_y] = {
                                                        'wbore': wbore,
                                                        'wtype': wtype
                                                    }
                                                    print(f"    âœ… NG ë°©ì‹ìœ¼ë¡œ WBORE: {wbore}, WTYPE: {wtype} ë°ì´í„° ì €ì¥ ì™„ë£Œ")
                                                    text_found = True
                                                    
                                                    # ì´ SWNO ë‚´ì—ì„œë§Œ ì¶”ì 
                                                    local_used_texts.add(id(e))
                                                else:
                                                    print(f"    â„¹ï¸ ì¶”ê°€ í…ìŠ¤íŠ¸ ë°œê²¬ (ì €ì¥ ì•ˆí•¨): WBORE: {wbore}")
                                                break
                            
                            if not text_found and idx == len(ng2_list) - 1:
                                print(f"  âš  ëª¨ë“  NG2ì—ì„œ x í…ìŠ¤íŠ¸ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
                        
                        if text_found:
                            print(f"\n  ğŸ“Š NG2 ì²˜ë¦¬ ì™„ë£Œ: ì´ {len(ng2_list)}ê°œì˜ NG2 ë°œê²¬")
                    else:
                        print(f"  âš  ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” NG2ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
                        print(f"     (SW ì¤‘ì‹¬ 2mm ì´ë‚´ ë˜ëŠ” ì› ë‘˜ë ˆ 1mm ì´ë‚´, ê¸¸ì´ 10mm ì´ˆê³¼)")
                
            else:
                print(f"  âš  SW ë ˆì´ì–´ ì›ì„ 30mm ë‚´ì—ì„œ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
    
    # REDU í›„ì²˜ë¦¬: ì—°ì†ëœ ë‘ WNOì˜ SWê°€ ì ‘í•˜ëŠ” ì„ ë¶„ ë¹„êµ
    print(f"\nğŸ”§ REDU í›„ì²˜ë¦¬ ì‹œì‘...")
    print(f"   ì´ REDU ê·¸ë£¹ ìˆ˜: {len(redu_sw_data)}")
    
    for redu_key, redu_info in redu_sw_data.items():
        print(f"\n   ğŸ“Œ REDU ê·¸ë£¹ ì²˜ë¦¬ ì¤‘ (í‚¤: {redu_key})...")
        print(f"      SW ì› ê°œìˆ˜: {len(redu_info['sw_circles'])}")
        print(f"      RSIZE í…ìŠ¤íŠ¸: {redu_info['rsize_text']}")
        print(f"      ì´ REDUì˜ ì²« WNO: {redu_info['first_wno']}")
        
        # ì´ REDUì˜ ì²« ë²ˆì§¸ WNOì™€ ë‹¤ìŒ WNOì˜ SW ì°¾ê¸°
        first_wno = redu_info['first_wno']
        
        # all_sw_infoì—ì„œ ì²« ë²ˆì§¸ì™€ ë‘ ë²ˆì§¸ SW ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        first_sw = all_sw_info.get(first_wno)
        second_sw = all_sw_info.get(first_wno + 1)
        
        if first_sw and second_sw and redu_info['rsize_text']:
            print(f"      ì²« ë²ˆì§¸ SW (WNO {first_wno}) ì°¾ìŒ")
            print(f"      ë‘ ë²ˆì§¸ SW (WNO {first_wno + 1}) ì°¾ìŒ")
            
            # ê° SWê°€ REDUì˜ ì–´ëŠ ì„ ë¶„ë“¤ì— ì ‘í•˜ëŠ”ì§€ í™•ì¸ (ëª¨ë“  ì ‘ì´‰ ì„ ë¶„ì˜ ê¸¸ì´ í•©)
            first_total_length, first_touching_segs = get_total_contact_length(
                first_sw['center'], 
                first_sw['radius'], 
                redu_info['segments']
            )
            second_total_length, second_touching_segs = get_total_contact_length(
                second_sw['center'], 
                second_sw['radius'], 
                redu_info['segments']
            )
            
            if first_total_length > 0 and second_total_length > 0:
                print(f"      ì²« ë²ˆì§¸ SW: ì ‘ì´‰ ì„ ë¶„ {len(first_touching_segs)}ê°œ, ì´ ê¸¸ì´ = {first_total_length:.2f}mm")
                for seg in first_touching_segs:
                    print(f"         - ì„ ë¶„ {seg['segment']['index']+1}: {seg['contact_length']:.2f}mm")
                    
                print(f"      ë‘ ë²ˆì§¸ SW: ì ‘ì´‰ ì„ ë¶„ {len(second_touching_segs)}ê°œ, ì´ ê¸¸ì´ = {second_total_length:.2f}mm")
                for seg in second_touching_segs:
                    print(f"         - ì„ ë¶„ {seg['segment']['index']+1}: {seg['contact_length']:.2f}mm")
                
                # RSIZEì—ì„œ x ì•ë’¤ ìˆ«ì ì¶”ì¶œ
                rsize_match = re.search(r'(\d+)\s*[xX]\s*(\d+)', redu_info['rsize_text'])
                if rsize_match:
                    bore_before_x = rsize_match.group(1)  # x ì•ì˜ ìˆ«ì
                    bore_after_x = rsize_match.group(2)   # x ë’¤ì˜ ìˆ«ì
                    print(f"      RSIZE íŒŒì‹±: {bore_before_x} x {bore_after_x}")
                    
                    # ì²« ë²ˆì§¸ì™€ ë‘ ë²ˆì§¸ SWì˜ ì ‘ì´‰ ì„ ë¶„ ì´ ê¸¸ì´ ë¹„êµ
                    if first_total_length > second_total_length:
                        # ì²« ë²ˆì§¸ê°€ ê¸´ ì„ ë¶„
                        first_wbore = bore_before_x
                        second_wbore = bore_after_x
                        print(f"      ğŸŸ¢ WNO {first_wno}: ê¸´ ì„ ë¶„ (ì´ {first_total_length:.2f}mm) â†’ WBORE = {first_wbore}")
                        print(f"      ğŸ”µ WNO {first_wno + 1}: ì§§ì€ ì„ ë¶„ (ì´ {second_total_length:.2f}mm) â†’ WBORE = {second_wbore}")
                    else:
                        # ë‘ ë²ˆì§¸ê°€ ê¸´ ì„ ë¶„
                        first_wbore = bore_after_x
                        second_wbore = bore_before_x
                        print(f"      ğŸ”µ WNO {first_wno}: ì§§ì€ ì„ ë¶„ (ì´ {first_total_length:.2f}mm) â†’ WBORE = {first_wbore}")
                        print(f"      ğŸŸ¢ WNO {first_wno + 1}: ê¸´ ì„ ë¶„ (ì´ {second_total_length:.2f}mm) â†’ WBORE = {second_wbore}")
                    
                    # ì²« ë²ˆì§¸ SW ë°ì´í„° ì €ì¥
                    first_wtype = '  BW' if int(first_wbore) >= 51 else '  SW'
                    weld_data[first_sw['wno_y']] = {
                        'wbore': first_wbore,
                        'wtype': first_wtype
                    }
                    print(f"      âœ… WNO {first_wno} ì²˜ë¦¬ ì™„ë£Œ - WBORE: {first_wbore}, WTYPE: {first_wtype}")
                    
                    # ë‘ ë²ˆì§¸ SW ë°ì´í„° ì €ì¥
                    second_wtype = '  BW' if int(second_wbore) >= 51 else '  SW'
                    weld_data[second_sw['wno_y']] = {
                        'wbore': second_wbore,
                        'wtype': second_wtype
                    }
                    print(f"      âœ… WNO {first_wno + 1} ì²˜ë¦¬ ì™„ë£Œ - WBORE: {second_wbore}, WTYPE: {second_wtype}")
                else:
                    print(f"      âŒ RSIZE í…ìŠ¤íŠ¸ íŒŒì‹± ì‹¤íŒ¨: {redu_info['rsize_text']}")
            else:
                print(f"      âš ï¸ SWê°€ REDU ì„ ë¶„ì— ì ‘í•˜ì§€ ì•ŠìŒ")
                if first_total_length == 0:
                    print(f"         - ì²« ë²ˆì§¸ SWê°€ REDUì— ì ‘í•˜ì§€ ì•ŠìŒ")
                if second_total_length == 0:
                    print(f"         - ë‘ ë²ˆì§¸ SWê°€ REDUì— ì ‘í•˜ì§€ ì•ŠìŒ")
        else:
            print(f"      âš ï¸ í•„ìš”í•œ ì •ë³´ë¥¼ ì°¾ì§€ ëª»í•¨")
            if not first_sw:
                print(f"         - ì²« ë²ˆì§¸ SW (WNO {first_wno}) ì—†ìŒ")
            if not second_sw:
                print(f"         - ë‘ ë²ˆì§¸ SW (WNO {first_wno + 1}) ì—†ìŒ")
            if not redu_info['rsize_text']:
                print(f"         - RSIZE í…ìŠ¤íŠ¸ ì—†ìŒ")
    
    print(f"\nâœ… REDU í›„ì²˜ë¦¬ ì™„ë£Œ!")
    
    # TEE_ í›„ì²˜ë¦¬: ëª¨ë“  ì²˜ë¦¬ê°€ ëë‚œ í›„ TEE_ ë ˆì´ì–´ í™•ì¸
    print(f"\nğŸ”§ TEE_ í›„ì²˜ë¦¬ ì‹œì‘...")
    print(f"   ì²˜ë¦¬ ì „ weld_data ìƒíƒœ:")
    for y_key, data in weld_data.items():
        print(f"   Y={y_key:.2f}: WBORE={data.get('wbore', 'N/A')}, WTYPE={data.get('wtype', 'N/A')}")
    
    for wno_y, sw_info in all_wno_sw_info.items():
        wno = sw_info['wno']
        sw_circle = sw_info['circle']
        sw_center = sw_info['center']
        sw_radius = sw_info['radius']
        
        print(f"\n   WNO {wno} ì²˜ë¦¬ ì¤‘ (Y={wno_y:.2f})...")
        
        # SW ì›ì— ì ‘í•˜ëŠ” TEE_ ë ˆì´ì–´ ì°¾ê¸° (ëª¨ë“  ì  ê²€ì‚¬)
        tee_entities = find_tee_entities_touching_circle(doc, sw_circle)
        
        for tee_entity in tee_entities:
            layer_name = tee_entity.dxf.layer.upper()
            if layer_name.startswith('TEE_'):
                td = extract_td_from_tee_layer(layer_name)
                if td is not None:
                    wbore = str(td)
                    wtype = '  BW' if td >= 51 else '  SW'
                    
                    # ê¸°ì¡´ ë°ì´í„°ë¥¼ ë®ì–´ì“°ê¸°
                    weld_data[wno_y] = {
                        'wbore': wbore,
                        'wtype': wtype
                    }
                    
                    tee_entity.dxf.color = 4  # CYAN
                    print(f"âœ… TEE_ í›„ì²˜ë¦¬ - WNO {wno}: WBORE={wbore}, WTYPE={wtype}")
                    print(f"   ë ˆì´ì–´ëª…: {layer_name}")
                    print(f"   Y ì¢Œí‘œ: {wno_y:.2f}")
                    print(f"   ê¸°ì¡´ ë°ì´í„°ë¥¼ TEE_ ë°ì´í„°ë¡œ ë®ì–´ì”€")
                    break  # ì²« ë²ˆì§¸ TEE_ë§Œ ì²˜ë¦¬
    
    print(f"\nâœ… TEE_ í›„ì²˜ë¦¬ ì™„ë£Œ!")
    print(f"   ì²˜ë¦¬ í›„ weld_data ìƒíƒœ:")
    for y_key, data in weld_data.items():
        print(f"   Y={y_key:.2f}: WBORE={data.get('wbore', 'N/A')}, WTYPE={data.get('wtype', 'N/A')}")
    
    return weld_data

def modify_fld_column(doc, all_texts, headers):
    if 'NO' not in headers or '/FLD' not in headers:
        return
    msp = doc.modelspace()
    no_x, no_y = headers['NO']
    fld_x, fld_y = headers['/FLD']
    y_positions = sorted(
        set(t[2] for t in all_texts if abs(t[1] - no_x) < 1 and t[2] < no_y and t[0].strip()),
        reverse=True
    )
    for y in y_positions:
        fld_texts = [t for t in all_texts if abs(t[1] - fld_x) < 1 and abs(t[2] - y) < 0.5]
        for text, x, y2, e in fld_texts:
            val = text.strip().upper()
            if val in ['F', 'S']:
                new_val = val + 'W'
                try:
                    msp.delete_entity(e)
                    msp.add_text(new_val, dxfattribs={'height': 2.5, 'insert': (x + 5, y2)})
                except:
                    continue

def modify_table_with_weld_data(doc, all_texts, bore_value, headers, dn_x, weld_data):
    """í…Œì´ë¸” ìˆ˜ì • - WBORE/WTYPEì´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©"""
    if 'NO' not in headers or dn_x is None:
        return
    msp = doc.modelspace()
    no_x, no_y = headers['NO']
    type_x = headers.get('TYPE', (None, None))[0]
    header_y = no_y

    y_positions = sorted(
        set(t[2] for t in all_texts if abs(t[1] - no_x) < 1 and t[2] < header_y and t[0].strip()),
        reverse=True
    )

    for y in y_positions:
        # ê¸°ì¡´ DN í…ìŠ¤íŠ¸ ì‚­ì œ
        existing = [t for t in all_texts if abs(t[1] - dn_x) < 1 and abs(t[2] - y) < 0.5]
        for t in existing:
            try:
                msp.delete_entity(t[3])
            except:
                continue
        
        # WBOREê°€ ìˆìœ¼ë©´ WBORE ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ BORE ê°’ ì‚¬ìš©
        if y in weld_data and 'wbore' in weld_data[y]:
            output_bore = weld_data[y]['wbore']
            color = 4  # CYAN for weld data
            print(f"  ğŸ“Š í…Œì´ë¸” ìˆ˜ì • - Y={y:.2f}, WBORE={output_bore} ì¶œë ¥")
        else:
            output_bore = str(bore_value)
            color = 2  # ê¸°ë³¸ ìƒ‰ìƒ
            print(f"  ğŸ“Š í…Œì´ë¸” ìˆ˜ì • - Y={y:.2f}, ê¸°ë³¸ê°’={output_bore} ì¶œë ¥")
        
        # BORE ê°’ ì¶œë ¥
        msp.add_text(output_bore, dxfattribs={
            'height': 2.5, 
            'insert': (dn_x + 5, y),
            'color': color
        })

        # TYPE ì²˜ë¦¬
        if type_x is not None:
            # ê¸°ì¡´ TYPE í…ìŠ¤íŠ¸ ì‚­ì œ
            type_texts = [t for t in all_texts if abs(t[1] - type_x) < 1 and abs(t[2] - y) < 0.5]
            for t in type_texts:
                try:
                    msp.delete_entity(t[3])
                except:
                    continue
            
            # WTYPEì´ ìˆìœ¼ë©´ WTYPE ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ BW/SW ì‚¬ìš©
            if y in weld_data and 'wtype' in weld_data[y]:
                type_str = weld_data[y]['wtype']
                color = 4  # CYAN for weld data
            else:
                # WBOREê°€ ìˆìœ¼ë©´ ê·¸ ê°’ìœ¼ë¡œ íŒë‹¨, ì—†ìœ¼ë©´ ê¸°ë³¸ bore_valueë¡œ íŒë‹¨
                check_bore = int(weld_data[y]['wbore']) if y in weld_data and 'wbore' in weld_data[y] else bore_value
                type_str = "  BW" if check_bore >= 65 else "  SW"
                color = 2  # ê¸°ë³¸ ìƒ‰ìƒ
            
            # TYPE ê°’ ì¶œë ¥
            msp.add_text(type_str, dxfattribs={
                'height': 2.5, 
                'insert': (type_x + 3, y),
                'color': color
            })

def get_table_bounds(headers, dn_x, all_texts):
    xs = [headers[k][0] for k in headers] + ([dn_x] if dn_x else [])
    min_x = min(xs) - 20
    max_x = max(xs) + 20
    no_x, no_y = headers['NO']
    # ì •ê·œì‹ ëŒ€ì‹  isdigit() ì‚¬ìš©
    ys = [t[2] for t in all_texts if abs(t[1] - no_x) < 1 and t[2] < no_y and t[0].strip().isdigit()]
    min_y = min(ys) - 10 if ys else no_y - 100
    max_y = no_y + 15
    return min_x, max_x, min_y, max_y

def stretch_entities(doc, bounds):
    min_x, max_x, min_y, max_y = bounds
    msp = doc.modelspace()
    for e in list(msp):
        if not hasattr(e, "dxf"):
            continue
        try:
            if e.dxftype() in ['TEXT', 'MTEXT']:
                p = e.dxf.insert
                if min_x <= p.x <= max_x and min_y <= p.y <= max_y:
                    e.dxf.insert = (p.x + 25, p.y)
            elif e.dxftype() == 'LWPOLYLINE':
                new_points = []
                for x, y, *rest in e.get_points():
                    if min_x <= x <= max_x and min_y <= y <= max_y:
                        x += 25
                    new_points.append((x, y, *rest))
                e.set_points(new_points)
            elif e.dxftype() == 'POLYLINE':
                for v in e.vertices:
                    loc = v.dxf.location
                    if min_x <= loc.x <= max_x and min_y <= loc.y <= max_y:
                        v.dxf.location = (loc.x + 25, loc.y)
            elif e.dxftype() == 'LINE':
                start = e.dxf.start
                end = e.dxf.end
                if min_x <= start.x <= max_x and min_y <= start.y <= max_y:
                    start = (start.x + 25, start.y)
                if min_x <= end.x <= max_x and min_y <= end.y <= max_y:
                    end = (end.x + 25, end.y)
                e.dxf.start = start
                e.dxf.end = end
        except Exception as err:
            print(f"âš  {e.dxftype()} stretch ì˜¤ë¥˜: {err}")
            continue

def apply_final_formatting(doc):
    """ìµœì¢… í¬ë§·íŒ… ì ìš© - í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ê³¼ ìƒ‰ìƒ ë³€ê²½"""
    msp = doc.modelspace()
    
    # ëª¨ë“  í…ìŠ¤íŠ¸ì— ëŒ€í•´ ìŠ¤íƒ€ì¼ê³¼ ìƒ‰ìƒ ì ìš©
    for txt in msp.query('TEXT'):
        if txt.dxf.color != 4:  # CYANì´ ì•„ë‹Œ ê²½ìš°ë§Œ
            txt.dxf.color = 2
        txt.dxf.style = "ARIAL"
        txt.dxf.width = 0.86

    # ARIAL ìŠ¤íƒ€ì¼ì´ ì—†ìœ¼ë©´ ì¶”ê°€
    if "ARIAL" not in doc.styles:
        doc.styles.new("ARIAL", dxfattribs={"font": "arial.ttf"})

def process_dxf_file(filepath):
    print(f"\nğŸ“‚ Processing: {os.path.basename(filepath)}")
    doc = ezdxf.readfile(filepath)
    all_texts = get_texts_by_position(extract_text_entities(doc))

    # ì²˜ë¦¬ ì™„ë£Œ í”Œë˜ê·¸
    processing_completed = False
    
    # FABRICATION/ERECTION MATERIALS ì°¾ê¸°
    materials_x = None
    for text, x, y, _ in all_texts:
        if "FABRICATION MATERIAL" in text.upper():
            materials_x = x
            break
    
    # FABRICATION MATERIALSê°€ ì—†ìœ¼ë©´ ERECTION MATERIALS ì°¾ê¸°
    if materials_x is None:
        for text, x, y, _ in all_texts:
            if "ERECTION MATERIAL" in text.upper():
                materials_x = x
                break

    # SIZE ê°’ ì°¾ê¸° (ìˆ˜ì •ëœ í•¨ìˆ˜ ì‚¬ìš©)
    size_text_value = find_size_value_near_materials(all_texts)
    if not size_text_value:
        print("âš  SIZE ê°’ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ ì²˜ë¦¬ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤.")
        bore_value = 100  # ê¸°ë³¸ê°’
    else:
        bore_value = extract_bore_from_size(size_text_value)
        print(f"âœ… BORE ê°’ ì¶”ì¶œë¨: {bore_value}")
        processing_completed = True

    dn_x = find_dn_header_x(all_texts)
    if dn_x is None:
        print("âš  'NO', '/FLD', 'DN' ì—°ì† í—¤ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    else:
        processing_completed = True

    headers = find_header_positions(all_texts)
    
    # ìš©ì ‘ ë°ì´í„° ìˆ˜ì§‘ (ì¶œë ¥í•˜ì§€ ì•Šê³  ë°ì´í„°ë§Œ ìˆ˜ì§‘)
    weld_data = {}
    if materials_x and headers:
        weld_data = process_weld_data(doc, all_texts, headers, dn_x, materials_x, bore_value)
        if weld_data:
            processing_completed = True
    
    # í…Œì´ë¸” ìˆ˜ì • - ìˆ˜ì§‘ëœ ìš©ì ‘ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ BORE/TYPE ì¶œë ¥
    if headers and dn_x:
        modify_table_with_weld_data(doc, all_texts, bore_value, headers, dn_x, weld_data)
        processing_completed = True
    
    # FLD ì»¬ëŸ¼ ìˆ˜ì •
    if headers:
        modify_fld_column(doc, all_texts, headers)
        processing_completed = True
    
    # í…Œì´ë¸” ì˜ì—­ í™•ì¥
    if headers and dn_x:
        bounds = get_table_bounds(headers, dn_x, all_texts)
        stretch_entities(doc, bounds)
        processing_completed = True

    # ìµœì¢… í¬ë§·íŒ… ì ìš© (í•­ìƒ ì‹¤í–‰)
    apply_final_formatting(doc)

    # ì €ì¥ (í•­ìƒ ì‹¤í–‰)
    new_filename = os.path.splitext(filepath)[0] + "_wt.dxf"
    doc.saveas(new_filename)
    
    if processing_completed:
        print(f"ğŸ’¾ ì²˜ë¦¬ ì™„ë£Œ ë° ì €ì¥: {os.path.basename(new_filename)}")
    else:
        print(f"ğŸ’¾ ì‘ì—… ì—†ì´ ì €ì¥ ì™„ë£Œ: {os.path.basename(new_filename)}")

def main():
    dxf_files = get_selected_dxf_files()
    if not dxf_files:
        print("âŒ DXF íŒŒì¼ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        return
    
    print(f"ğŸ“‹ ì´ {len(dxf_files)}ê°œ íŒŒì¼ ì²˜ë¦¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
    
    for i, dxf in enumerate(dxf_files, 1):
        try:
            print(f"\n[{i}/{len(dxf_files)}] íŒŒì¼ ì²˜ë¦¬ ì¤‘...")
            process_dxf_file(dxf)
        except Exception as e:
            print(f"âŒ ì˜¤ë¥˜ ë°œìƒ: {os.path.basename(dxf)} / {e}")
            # ì˜¤ë¥˜ê°€ ë°œìƒí•´ë„ ìµœì†Œí•œ ì›ë³¸ íŒŒì¼ì„ ë³µì‚¬í•´ì„œ ì €ì¥
            try:
                time.sleep(0.5)  # ì ì‹œ ëŒ€ê¸°
                new_filename = os.path.splitext(dxf)[0] + "_wt.dxf"  # _WT â†’ _wtë¡œ ë³€ê²½
                shutil.copy2(dxf, new_filename)
                print(f"ğŸ“„ ì›ë³¸ íŒŒì¼ ë³µì‚¬ ì €ì¥: {os.path.basename(new_filename)}")
            except Exception as copy_error:
                print(f"âŒ íŒŒì¼ ë³µì‚¬ë„ ì‹¤íŒ¨: {copy_error}")
    
    print(f"\nğŸ‰ ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ!")

if __name__ == "__main__":
    main()