import ezdxf
import math
import os
import tkinter as tk
from tkinter import filedialog

def distance(p1, p2):
    return math.hypot(p1[0] - p2[0], p1[1] - p2[1])

def midpoint(points):
    x = sum(p[0] for p in points) / len(points)
    y = sum(p[1] for p in points) / len(points)
    return (x, y)

def polyline_length(pl):
    try:
        if pl.dxftype() == 'LWPOLYLINE':
            points = [p[:2] for p in pl.get_points()]
        elif pl.dxftype() == 'POLYLINE':
            points = []
            for v in pl.vertices:
                if hasattr(v.dxf, 'location'):
                    pt = (v.dxf.location.x, v.dxf.location.y)
                    points.append(pt)
            if not points:
                return 0
        else:
            return 0
        return sum(distance(points[i], points[i+1]) for i in range(len(points)-1))
    except Exception:
        return 0

def get_poly_points(pl):
    try:
        if pl.dxftype() == 'LWPOLYLINE':
            points = list(pl.get_points())
            points = [pt for pt in points if abs(pt[0]) > 1e-8 or abs(pt[1]) > 1e-8]
            return points
        elif pl.dxftype() == 'POLYLINE':
            pts = []
            for v in pl.vertices:
                if hasattr(v.dxf, 'location'):
                    x, y = v.dxf.location.x, v.dxf.location.y
                    if abs(x) > 1e-8 or abs(y) > 1e-8:
                        pts.append((x, y, 0, 0))
            return pts
        else:
            return []
    except Exception:
        return []

def move_single_point_to(line, target_point, fixed_point):
    try:
        d_start = distance((line.dxf.start[0], line.dxf.start[1]), fixed_point)
        d_end = distance((line.dxf.end[0], line.dxf.end[1]), fixed_point)
        if d_start < d_end:
            line.dxf.end = target_point
        else:
            line.dxf.start = target_point
    except Exception:
        pass

def is_valid_center(center):
    if center is None:
        return False
    x, y = center
    if abs(x) < 1e-5 and abs(y) < 1e-5:
        return False
    if abs(x) > 1e5 or abs(y) > 1e5:
        return False
    return True

def is_nearly_same_points(points, tol=0.05):
    # ëª¨ë“  ì ì´ ì„œë¡œ ê±°ì˜ ê°™ì€ ìœ„ì¹˜ë©´ True ë°˜í™˜ (ê³µë°±/ìœ ë ¹ í´ë¦¬ë¼ì¸ ë°©ì§€)
    if len(points) < 2:
        return True
    base = points[0][:2]
    for pt in points[1:]:
        if distance(base, pt[:2]) > tol:
            return False
    return True

def process_file(filepath):
    try:
        doc = ezdxf.readfile(filepath)
        msp = doc.modelspace()
        modified = False
        to_delete = []
        WELDS = []  # ğŸ‘ˆ ì¶”ê°€: WELDS ì „ì²´ ë¦¬ìŠ¤íŠ¸

        for weld in list(msp.query('LWPOLYLINE POLYLINE')):
            points = get_poly_points(weld)
            if len(points) != 7:
                continue

            # ëª¨ë“  ì ì´ ê±°ì˜ ê°™ì€ ìœ„ì¹˜ë©´ ê±´ë„ˆëœ€ (ê³µë°± ìœ ë ¹ í´ë¦¬ë¼ì¸ ë°©ì§€)
            if is_nearly_same_points(points):
                continue

            weld_center = midpoint([pt[:2] for pt in points])
            if not is_valid_center(weld_center):
                continue

            # ì „ì²´ í´ë¦¬ë¼ì¸ ê¸¸ì´ ì²´í¬ (ì‹¤ì œ WELD í¬ê¸°ì— ë§ê²Œ ì¡°ì •)
            length = polyline_length(weld)
            if length < 1 or length > 100:
                continue

            # ì£¼ë³€ 2ì ì§œë¦¬ POLYLINE (LWPOLYLINE or POLYLINE) ê¸¸ì´ 2.8 ì´í•˜ ìˆ˜ì§‘
            short_plines = []
            for pl in msp.query('LWPOLYLINE POLYLINE LINE'):
                if pl == weld:
                    continue
                pts = get_poly_points(pl)
                if len(pts) != 2:
                    continue
                if any(distance(pt[:2], wp[:2]) <= 3.0 for pt in pts for wp in points):
                    if polyline_length(pl) <= 2.8:
                        short_plines.append(pl)

            # ì¤‘ì‹¬ ì› ìƒì„± (1.6mm, color 2-yellow)
            main_circle = msp.add_circle(center=weld_center, radius=1, dxfattribs={"color": 2})
            main_circle.dxf.lineweight = 20

            # ------------------------------
            # ğŸ’¡ [WELDS: ì›, ë¦¬ë”ì„ , ì›ì•ˆ í…ìŠ¤íŠ¸ ì €ì¥]
            # ------------------------------
            texts_in_circle = []
            for txt in msp.query('TEXT'):
                txt_pos = (txt.dxf.insert[0], txt.dxf.insert[1])
                if distance(txt_pos, weld_center) < 1.0:  # ì› ë°˜ì§€ë¦„ê³¼ ë™ì¼í•˜ê²Œ(í•„ìš”ì‹œ ì¡°ì •)
                    texts_in_circle.append(txt)

            leader_line = None
            for ent in msp.query('LINE'):
                if hasattr(ent.dxf, 'color') and ent.dxf.color == 1:
                    p_start = (ent.dxf.start[0], ent.dxf.start[1])
                    p_end = (ent.dxf.end[0], ent.dxf.end[1])
                    for pt in points:
                        if distance(pt[:2], p_start) <= 1 or distance(pt[:2], p_end) <= 1:
                            leader_line = ent
                            break
                if leader_line:
                    break

            # ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
            WELDS.append({
                "circle": main_circle,
                "leader_line": leader_line,
                "texts": texts_in_circle
            })
            # ------------------------------

            # ì„ ì¢…ë¥˜ ë³€ê²½
            if hasattr(weld.dxf, 'linetype') and isinstance(weld.dxf.linetype, str):
                if weld.dxf.linetype.upper() == "GT100":
                    weld.dxf.linetype = "DOT"

            # BYLAYERì´ë©´ CIRCLE ì—¬ëŸ¬ ê²¹(ì±„ìš´ ë“¯í•œ ëŠë‚Œ)
            if hasattr(weld.dxf, 'linetype') and weld.dxf.linetype.upper() == "BYLAYER":
                for r in [0.85, 0.7, 0.55, 0.4, 0.25 ]:
                    inner = msp.add_circle(center=weld_center, radius=r, dxfattribs={"color": 2})
                    inner.dxf.lineweight = 20

            # ë ˆì´ì–´ ë¼ë²¨ë§: 2ì ì§œë¦¬ ì£¼ë³€ í´ë¦¬ë¼ì¸ 5ê°œ ì´ìƒ = SW, ì´í•˜ë©´ OW
            main_circle.dxf.layer = "SW" if len(short_plines) >= 5 else "OW"

            # ë¹¨ê°„ ì„  stretch
            red_lines = []
            for ent in msp.query('LINE'):
                if hasattr(ent.dxf, 'color') and ent.dxf.color == 1:
                    p_start = (ent.dxf.start[0], ent.dxf.start[1])
                    p_end = (ent.dxf.end[0], ent.dxf.end[1])
                    for pt in points:
                        if distance(pt[:2], p_start) <= 1 or distance(pt[:2], p_end) <= 1:
                            red_lines.append((ent, p_start, p_end))
                            break

            # ê°€ì¥ ê°€ê¹Œìš´ ì (wp1)ë§Œ weld ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™
            for line, p1, p2 in red_lines:
                d1 = distance(p1, weld_center)
                d2 = distance(p2, weld_center)
                wp1 = p1 if d1 < d2 else p2
                wp2 = p2 if d1 < d2 else p1
                move_single_point_to(line, weld_center, fixed_point=wp2)
                break

            # ì‚­ì œ ëŒ€ìƒ ë“±ë¡
            to_delete.append(weld)
            to_delete.extend(short_plines)
            modified = True

        for ent in to_delete:
            try:
                msp.delete_entity(ent)
            except Exception:
                pass

        # --- ì—¬ê¸°ì„œ WELDS ì „ì²´ë¥¼ ì¶œë ¥/í™œìš© ê°€ëŠ¥ ---
        print(f"\n[ {os.path.basename(filepath)} ]ì—ì„œ ë°œê²¬ëœ WELDS ìˆ˜: {len(WELDS)}")
        for idx, welds in enumerate(WELDS, 1):
            texts_str = ', '.join([txt.dxf.text for txt in welds['texts']])
            print(f"- WELDS #{idx}: ì›={welds['circle']}, ì„ ={welds['leader_line']}, TEXT=({texts_str})")

        if modified:
            new_path = os.path.splitext(filepath)[0] + "_wsym.dxf"
            doc.saveas(new_path)
            print(f"âœ” ì €ì¥ ì™„ë£Œ: {new_path}")
        else:
            print(f"âš  ì¡°ê±´ ì¼ì¹˜ ì—†ìŒ: {os.path.basename(filepath)}")

    except Exception as e:
        print(f"âŒ ì˜¤ë¥˜ - {filepath}: {e}")

def main():
    root = tk.Tk()
    root.withdraw()
    filepaths = filedialog.askopenfilenames(title="DXF íŒŒì¼ ì„ íƒ", filetypes=[("DXF files", "*.dxf")])
    if not filepaths:
        print("â— DXF íŒŒì¼ì„ ì„ íƒí•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        return

    for path in filepaths:
        process_file(path)

if __name__ == "__main__":
    main()
