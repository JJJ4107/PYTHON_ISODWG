import os
import sys
import ezdxf
import math
import numpy as np
from ezdxf.entities import Line, LWPolyline, Polyline, Text
import tkinter as tk
from tkinter import filedialog, messagebox
from tkinter import ttk

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ì„¤ì • ê°’ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ANGLE_TOLERANCE = 5.0  # ê°ë„ í—ˆìš© ì˜¤ì°¨ (Â°)
DIM_LAYER_PREFIXES = ("GT_", "PL2")  # ì¹˜ìˆ˜ì„  ë ˆì´ì–´ ì ‘ë‘ì‚¬ë“¤

# TBOX ìºì‹œë¥¼ ìœ„í•œ ì „ì—­ ë”•ì…”ë„ˆë¦¬
TBOX_CACHE = {}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ íŒŒì¼ ì„ íƒ GUI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def select_dxf_files():
    """
    Windows íŒŒì¼ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ë¥¼ ì—´ì–´ DXF íŒŒì¼ë“¤ì„ ì„ íƒ
    Returns: ì„ íƒëœ íŒŒì¼ ê²½ë¡œë“¤ì˜ ë¦¬ìŠ¤íŠ¸
    """
    root = tk.Tk()
    root.withdraw()
    
    file_paths = filedialog.askopenfilenames(
        title="DXF íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš” (ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥)",
        filetypes=[
            ("DXF files", "*.dxf"),
            ("All files", "*.*")
        ],
        multiple=True
    )
    
    root.destroy()
    return list(file_paths)

def show_progress_window(total_files):
    """
    ì§„í–‰ ìƒí™©ì„ ë³´ì—¬ì£¼ëŠ” í”„ë¡œê·¸ë ˆìŠ¤ ìœˆë„ìš° ìƒì„±
    """
    progress_window = tk.Tk()
    progress_window.title("DXF ì²˜ë¦¬ ì§„í–‰ ìƒí™©")
    progress_window.geometry("500x150")
    progress_window.resizable(False, False)
    
    progress_window.eval('tk::PlaceWindow . center')
    
    label = tk.Label(progress_window, text="DXF íŒŒì¼ì„ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...", font=("Arial", 12))
    label.pack(pady=10)
    
    file_label = tk.Label(progress_window, text="", font=("Arial", 10), fg="blue")
    file_label.pack(pady=5)
    
    progress_var = tk.DoubleVar()
    progress_bar = ttk.Progressbar(
        progress_window, 
        variable=progress_var, 
        maximum=total_files, 
        length=400,
        mode='determinate'
    )
    progress_bar.pack(pady=10)
    
    progress_text = tk.Label(progress_window, text=f"0 / {total_files}", font=("Arial", 10))
    progress_text.pack()
    
    progress_window.update()
    
    return progress_window, progress_var, file_label, progress_text

def update_progress(window, progress_var, file_label, progress_text, current, total, current_file):
    """
    í”„ë¡œê·¸ë ˆìŠ¤ ì—…ë°ì´íŠ¸
    """
    if window and window.winfo_exists():
        progress_var.set(current)
        file_label.config(text=f"ì²˜ë¦¬ ì¤‘: {os.path.basename(current_file)}")
        progress_text.config(text=f"{current} / {total}")
        window.update()

def close_progress_window(window):
    """
    í”„ë¡œê·¸ë ˆìŠ¤ ìœˆë„ìš° ë‹«ê¸°
    """
    if window and window.winfo_exists():
        window.destroy()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ìœ í‹¸ í•¨ìˆ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def to2d(pt):
    if hasattr(pt, "__getitem__"):
        return np.array((pt[0], pt[1]), float)
    return np.array((pt.x, pt.y), float)

def distance(a, b):
    return float(np.linalg.norm(a - b))

def angle_deg(a, b):
    dx, dy = b - a
    return (math.degrees(math.atan2(dy, dx)) + 360) % 360

def get_entity_handle(entity):
    """
    ì—”í‹°í‹°ì˜ í•¸ë“¤ì„ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜
    """
    try:
        if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'handle'):
            return entity.dxf.handle
        elif hasattr(entity, 'handle'):
            return entity.handle
        else:
            return str(id(entity))  # ë§ˆì§€ë§‰ ìˆ˜ë‹¨ìœ¼ë¡œ ê°ì²´ ID ì‚¬ìš©
    except:
        return "unknown"

def extract_segments(ent):
    if isinstance(ent, Line):
        return [(ent.dxf.start, ent.dxf.end)]
    if isinstance(ent, LWPolyline):
        pts = list(ent.get_points("xyb"))
        z = ent.dxf.elevation
        return [
            ((x0, y0, z), (x1, y1, z)) for (x0, y0, _), (x1, y1, _) in zip(pts, pts[1:])
        ]
    if isinstance(ent, Polyline):
        verts = list(ent.vertices)
        return [
            (verts[i].dxf.location, verts[i + 1].dxf.location)
            for i in range(len(verts) - 1)
        ]
    return []

def is_enclosed(point, msp):
    """
    ì£¼ì–´ì§„ ì ì´ ë‹«íŒ ì˜ì—­(í´ë¦¬ê³¤) ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
    """
    x, y = float(point[0]), float(point[1])
    
    for entity in msp.query("LWPOLYLINE POLYLINE"):
        if not entity.is_closed:
            continue
            
        if hasattr(entity, 'get_points'):
            points = list(entity.get_points("xy"))
        else:
            points = [(v.dxf.location[0], v.dxf.location[1]) for v in entity.vertices]
        
        if len(points) < 3:
            continue
            
        if point_in_polygon(x, y, points):
            return True
    
    return False

def point_in_polygon(x, y, polygon_points):
    """
    Ray casting ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì ì´ í´ë¦¬ê³¤ ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
    """
    n = len(polygon_points)
    inside = False
    
    p1x, p1y = polygon_points[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon_points[i % n]
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        p1x, p1y = p2x, p2y
    
    return inside

def point_to_line_distance(point, line_start, line_end):
    """
    ì ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°
    """
    line_vec = line_end - line_start
    line_length_sq = np.dot(line_vec, line_vec)
    
    if line_length_sq == 0:
        return distance(point, line_start)
    
    point_vec = point - line_start
    t = np.dot(point_vec, line_vec) / line_length_sq
    t = max(0, min(1, t))
    closest_point = line_start + t * line_vec
    
    return distance(point, closest_point)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TBOX ê´€ë ¨ í•¨ìˆ˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_text_key(txt):
    """
    í…ìŠ¤íŠ¸ ì—”í‹°í‹°ì˜ ê³ ìœ  í‚¤ë¥¼ ìƒì„±
    """
    try:
        handle = get_entity_handle(txt)
        if hasattr(txt.dxf, 'insert'):
            pos = txt.dxf.insert
            return f"{handle}_{pos[0]}_{pos[1]}"
        return handle
    except:
        return str(id(txt))

def create_tbox(txt):
    """
    í…ìŠ¤íŠ¸ì— ëŒ€í•œ TBOXë¥¼ ìƒì„±í•˜ê³  ìºì‹œì— ì €ì¥
    """
    text_key = get_text_key(txt)
    
    # ì´ë¯¸ TBOXê°€ ìƒì„±ë˜ì–´ ìˆë‹¤ë©´ ìºì‹œì—ì„œ ë°˜í™˜
    if text_key in TBOX_CACHE:
        return TBOX_CACHE[text_key]
    
    # í…ìŠ¤íŠ¸ ìœ„ì¹˜
    if hasattr(txt.dxf, 'insert') and txt.dxf.insert is not None:
        txt_pt = to2d(txt.dxf.insert)
    elif hasattr(txt.dxf, 'align_point') and txt.dxf.align_point is not None:
        txt_pt = to2d(txt.dxf.align_point)
    else:
        return None
    
    # í…ìŠ¤íŠ¸ í¬ê¸°
    text_length, text_height = get_text_dimensions(txt)
    
    # TBOX ìƒì„± (ì›ë˜ ìœ„ì¹˜ ê¸°ì¤€)
    tbox_left = txt_pt[0]
    tbox_right = txt_pt[0] + text_length
    tbox_bottom = txt_pt[1]
    tbox_top = txt_pt[1] + text_height
    
    # TBOXë¥¼ +X ë°©í–¥ìœ¼ë¡œ Xê°’/2 ë§Œí¼ ì´ë™
    move_x = text_length / 2.0
    tbox_left += move_x
    tbox_right += move_x
    
    # ì´ë™ëœ TBOXì˜ 4ê°œ ì½”ë„ˆì 
    tbox_corners = [
        np.array([tbox_left, tbox_bottom]),   # ì¢Œí•˜
        np.array([tbox_right, tbox_bottom]),  # ìš°í•˜
        np.array([tbox_right, tbox_top]),     # ìš°ìƒ
        np.array([tbox_left, tbox_top])       # ì¢Œìƒ
    ]
    
    # TBOX ì •ë³´ë¥¼ ìºì‹œì— ì €ì¥
    tbox_info = {
        'corners': tbox_corners,
        'left': tbox_left,
        'right': tbox_right,
        'bottom': tbox_bottom,
        'top': tbox_top,
        'text_length': text_length,
        'text_height': text_height,
        'original_position': txt_pt
    }
    
    TBOX_CACHE[text_key] = tbox_info
    
    return tbox_info

def clear_tbox_cache():
    """
    TBOX ìºì‹œ ì´ˆê¸°í™”
    """
    global TBOX_CACHE
    TBOX_CACHE = {}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DB1, CH1 ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def find_dim_pairs_optimized(all_line_entities):
    """
    DIM1, DIM2 ìŒì„ ì°¾ëŠ” í•¨ìˆ˜ (ìµœì í™”ëœ ë²„ì „ - ë¯¸ë¦¬ í•„í„°ë§ëœ ì—”í‹°í‹° ì‚¬ìš©)
    """
    two_point_entities = []
    
    for ent in all_line_entities:
        if not ent.dxf.layer.startswith(DIM_LAYER_PREFIXES):
            continue
            
        segments = extract_segments(ent)
        if len(segments) != 1:
            continue
            
        p0, p1 = segments[0]
        v0, v1 = to2d(p0), to2d(p1)
        length = distance(v0, v1)
        
        if 1.5 <= length <= 12:
            two_point_entities.append((ent, v0, v1, length))
    
    dim_pairs = []
    overlapped_entities = []
    close_tolerance = 0.2
    far_threshold = 3.0
    tolerance_len = 0.5
    
    for i in range(len(two_point_entities)):
        for j in range(i + 1, len(two_point_entities)):
            ent1, v0_1, v1_1, len1 = two_point_entities[i]
            ent2, v0_2, v1_2, len2 = two_point_entities[j]
            
            length_diff = abs(len1 - len2)
            if length_diff > tolerance_len:
                continue
            
            connection_cases = [
                (v0_1, v0_2, v1_1, v1_2, "v0_1-v0_2"),
                (v0_1, v1_2, v1_1, v0_2, "v0_1-v1_2"),
                (v1_1, v0_2, v0_1, v1_2, "v1_1-v0_2"),
                (v1_1, v1_2, v0_1, v0_2, "v1_1-v1_2"),
            ]
            
            valid_pair_found = False
            overlap_found = False
            
            for close_pt1, close_pt2, far_pt1, far_pt2, case_name in connection_cases:
                close_dist = distance(close_pt1, close_pt2)
                far_dist = distance(far_pt1, far_pt2)
                
                if close_dist <= close_tolerance:
                    if far_dist <= close_tolerance:
                        if ent1 not in overlapped_entities:
                            ent1.dxf.color = 3
                            overlapped_entities.append(ent1)
                        if ent2 not in overlapped_entities:
                            ent2.dxf.color = 3
                            overlapped_entities.append(ent2)
                        overlap_found = True
                        break
                    elif far_dist >= far_threshold:
                        if case_name == "v0_1-v0_2":
                            vec1 = v1_1 - v0_1
                            vec2 = v1_2 - v0_2
                            dim1_common, dim1_opposite = v0_1, v1_1
                            dim2_common, dim2_opposite = v0_2, v1_2
                        elif case_name == "v0_1-v1_2":
                            vec1 = v1_1 - v0_1
                            vec2 = v0_2 - v1_2
                            dim1_common, dim1_opposite = v0_1, v1_1
                            dim2_common, dim2_opposite = v1_2, v0_2
                        elif case_name == "v1_1-v0_2":
                            vec1 = v0_1 - v1_1
                            vec2 = v1_2 - v0_2
                            dim1_common, dim1_opposite = v1_1, v0_1
                            dim2_common, dim2_opposite = v0_2, v1_2
                        else:
                            vec1 = v0_1 - v1_1
                            vec2 = v0_2 - v1_2
                            dim1_common, dim1_opposite = v1_1, v0_1
                            dim2_common, dim2_opposite = v1_2, v0_2
                        
                        dot_product = np.dot(vec1, vec2)
                        
                        if dot_product < 0:
                            if ent1 not in overlapped_entities and ent2 not in overlapped_entities:
                                dim_pairs.append({
                                    'DIM1': ent1, 'DIM1_common': dim1_common, 'DIM1_opposite': dim1_opposite,
                                    'DIM2': ent2, 'DIM2_common': dim2_common, 'DIM2_opposite': dim2_opposite,
                                    'common_point': (close_pt1 + close_pt2) / 2,
                                    'length': (len1 + len2) / 2
                                })
                                valid_pair_found = True
                                break
                
                if valid_pair_found or overlap_found:
                    break
            
            if not overlap_found and not valid_pair_found:
                reverse_dist1 = distance(v0_1, v1_2)
                reverse_dist2 = distance(v1_1, v0_2)
                
                if reverse_dist1 <= close_tolerance and reverse_dist2 <= close_tolerance:
                    if ent1 not in overlapped_entities:
                        ent1.dxf.color = 3
                        overlapped_entities.append(ent1)
                    if ent2 not in overlapped_entities:
                        ent2.dxf.color = 3
                        overlapped_entities.append(ent2)
                    overlap_found = True
    
    return dim_pairs, overlapped_entities

def find_arrow_entities_optimized(all_line_entities, point, tolerance=0.5):
    """
    ìµœì í™”ëœ ë²„ì „ - ë¯¸ë¦¬ í•„í„°ë§ëœ ì—”í‹°í‹°ì—ì„œ 3ì  í´ë¦¬ë¼ì¸ ì°¾ê¸°
    AD1, AD2 ì „ìš© - DIM_LAYER_PREFIXES ë ˆì´ì–´ì—ì„œë§Œ ì°¾ìŒ
    """
    arrows = []
    
    for ent in all_line_entities:
        # AD1, AD2ëŠ” DIM_LAYER_PREFIXESë¡œ ì‹œì‘í•˜ëŠ” ë ˆì´ì–´ì—ì„œë§Œ ì°¾ìŒ
        if not ent.dxf.layer.startswith(DIM_LAYER_PREFIXES):
            continue
            
        try:
            if isinstance(ent, LWPolyline):
                points = list(ent.get_points("xy"))
            elif isinstance(ent, Polyline):
                points = [v.dxf.location for v in ent.vertices]
            else:
                continue
            
            if len(points) != 3:
                continue
            
            pts = [to2d(p) for p in points]
            min_dist_to_point = min(distance(pt, point) for pt in pts)
            
            if min_dist_to_point <= tolerance:
                arrows.append(ent)
        except Exception as e:
            continue
    
    return arrows

def find_ad3_entities_optimized(all_line_entities, dim_pair, ad1_entities, ad2_entities, tolerance=0.5):
    """
    ìµœì í™”ëœ ë²„ì „ - ë¯¸ë¦¬ í•„í„°ë§ëœ ì—”í‹°í‹°ì—ì„œ AD3 ì°¾ê¸°
    ìˆ˜ì •: ARROW ë ˆì´ì–´ë„ í¬í•¨, DIM1/DIM2 ëì  ê·¼ì²˜ ì—”í‹°í‹°ëŠ” ì œì™¸
    CP(ê³µí†µì ) ê·¼ì²˜ì˜ 3ì  ARROW í´ë¦¬ë¼ì¸ë„ AD3ë¡œ ë¶„ë¥˜
    """
    ad3_candidates = []
    common_point = dim_pair['common_point']
    
    # DIM1, DIM2ì˜ ì–‘ëì  ìˆ˜ì§‘ (AD1, AD2 ë³´í˜¸ë¥¼ ìœ„í•´)
    dim1_common = dim_pair['DIM1_common']
    dim1_opposite = dim_pair['DIM1_opposite']
    dim2_common = dim_pair['DIM2_common']
    dim2_opposite = dim_pair['DIM2_opposite']
    
    # DIM ëì ë“¤ (AD1, AD2ê°€ ìœ„ì¹˜í•˜ëŠ” ê³³)
    dim_far_endpoints = [dim1_opposite, dim2_opposite]  # AD1, AD2 ìœ„ì¹˜
    
    # AD1, AD2ì˜ í•¸ë“¤ ìˆ˜ì§‘
    excluded_handles = set()
    for ad1 in ad1_entities:
        excluded_handles.add(get_entity_handle(ad1))
    for ad2 in ad2_entities:
        excluded_handles.add(get_entity_handle(ad2))
    
    for ent in all_line_entities:
        # DIM_LAYER_PREFIXES ë˜ëŠ” ARROW ë ˆì´ì–´ ì²´í¬
        if not (ent.dxf.layer.startswith(DIM_LAYER_PREFIXES) or ent.dxf.layer.upper() == "ARROW"):
            continue
            
        # ì´ë¯¸ ì œì™¸ëœ í•¸ë“¤ì¸ì§€ í™•ì¸
        if get_entity_handle(ent) in excluded_handles:
            continue
            
        try:
            if isinstance(ent, LWPolyline):
                points = list(ent.get_points("xy"))
            elif isinstance(ent, Polyline):
                points = [v.dxf.location for v in ent.vertices]
            else:
                continue
            
            if len(points) != 3:
                continue
            
            pts = [to2d(p) for p in points]
            
            # ARROW ë ˆì´ì–´ì¸ ê²½ìš°, DIMì˜ ë°˜ëŒ€í¸ ëì (AD1, AD2 ìœ„ì¹˜) ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸
            if ent.dxf.layer.upper() == "ARROW":
                is_near_far_endpoint = False
                for pt in pts:
                    for far_endpoint in dim_far_endpoints:
                        if distance(pt, far_endpoint) <= 0.5:  # AD1, AD2 ìœ„ì¹˜ì—ì„œ 0.5mm ì´ë‚´
                            is_near_far_endpoint = True
                            break
                    if is_near_far_endpoint:
                        break
                
                # AD1, AD2 ìœ„ì¹˜ ê·¼ì²˜ì˜ ARROWëŠ” ì œì™¸
                if is_near_far_endpoint:
                    continue
            
            # ê³µí†µì (CP)ê³¼ì˜ ê±°ë¦¬ í™•ì¸
            min_dist_to_cp = min(distance(pt, common_point) for pt in pts)
            
            if min_dist_to_cp <= tolerance:
                ad3_candidates.append((ent, min_dist_to_cp))
        except Exception as e:
            continue
    
    if ad3_candidates:
        ad3_candidates.sort(key=lambda x: x[1])
        return [ad3_candidates[0][0]]
    
    return []

def find_ad3_touching_dims(all_line_entities, dim1_ent, dim2_ent, ad1_entities, ad2_entities, tolerance=0.2):
    """
    DIM1ì´ë‚˜ DIM2 ì„ ë¶„ì— ì ‘í•˜ëŠ” AD3 ì—”í‹°í‹°ë“¤ì„ ì°¾ëŠ” í•¨ìˆ˜ (AD1, AD2 ì œì™¸)
    ìˆ˜ì •: ARROW ë ˆì´ì–´ë§Œ ëŒ€ìƒìœ¼ë¡œ, 0.2mm ì´ë‚´ ì ‘ì´‰, DIM ëì  ê·¼ì²˜ ì œì™¸
    """
    touching_ad3 = []
    
    # DIM1, DIM2 ì„ ë¶„ ì •ë³´ ì¶”ì¶œ
    dim1_segments = extract_segments(dim1_ent)
    dim2_segments = extract_segments(dim2_ent)
    
    if not dim1_segments or not dim2_segments:
        return []
    
    dim1_start, dim1_end = to2d(dim1_segments[0][0]), to2d(dim1_segments[0][1])
    dim2_start, dim2_end = to2d(dim2_segments[0][0]), to2d(dim2_segments[0][1])
    
    # DIM ëì ë“¤ (AD1, AD2 ë³´í˜¸ìš©)
    dim_endpoints = [dim1_start, dim1_end, dim2_start, dim2_end]
    
    # DIM1, DIM2, AD1, AD2 ì œì™¸
    excluded_handles = {get_entity_handle(dim1_ent), get_entity_handle(dim2_ent)}
    
    # AD1, AD2 í•¸ë“¤ ì¶”ê°€í•˜ì—¬ ì‚­ì œ ëŒ€ìƒì—ì„œ ì œì™¸
    for ad1 in ad1_entities:
        excluded_handles.add(get_entity_handle(ad1))
    for ad2 in ad2_entities:
        excluded_handles.add(get_entity_handle(ad2))
    
    for ent in all_line_entities:
        # ARROW ë ˆì´ì–´ë§Œ ì²´í¬ (DIM ì„ ë¶„ì— ì ‘í•˜ëŠ” AD3ëŠ” ì£¼ë¡œ ARROW ë ˆì´ì–´)
        if ent.dxf.layer.upper() != "GT_1":
            continue
            
        if get_entity_handle(ent) in excluded_handles:
            continue
            
        try:
            # 3ì  í´ë¦¬ë¼ì¸ì¸ì§€ í™•ì¸
            if isinstance(ent, LWPolyline):
                points = list(ent.get_points("xy"))
            elif isinstance(ent, Polyline):
                points = [v.dxf.location for v in ent.vertices]
            else:
                continue
            
            if len(points) != 3:
                continue
            
            pts = [to2d(p) for p in points]
            
            # DIM ëì  ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸ (AD1, AD2 ë³´í˜¸)
            is_near_endpoint = False
            for pt in pts:
                for endpoint in dim_endpoints:
                    if distance(pt, endpoint) <= 0.5:  # DIM ëì ì—ì„œ 0.5mm ì´ë‚´
                        is_near_endpoint = True
                        break
                if is_near_endpoint:
                    break
            
            # DIM ëì  ê·¼ì²˜ì˜ ARROWëŠ” AD1 ë˜ëŠ” AD2ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìœ¼ë¯€ë¡œ ì œì™¸
            if is_near_endpoint:
                continue
            
            # AD3ì˜ ê° ì ì´ DIM1 ë˜ëŠ” DIM2 ì„ ë¶„ì— ì ‘í•˜ëŠ”ì§€ í™•ì¸
            is_touching = False
            
            for pt in pts:
                # DIM1 ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬
                dist_to_dim1 = point_to_line_distance(pt, dim1_start, dim1_end)
                # DIM2 ì„ ë¶„ê¹Œì§€ì˜ ê±°ë¦¬
                dist_to_dim2 = point_to_line_distance(pt, dim2_start, dim2_end)
                
                # 0.2mm ì´ë‚´ë¡œ ì ‘ì´‰í•˜ëŠ”ì§€ í™•ì¸
                if dist_to_dim1 <= tolerance or dist_to_dim2 <= tolerance:
                    is_touching = True
                    break
            
            if is_touching:
                touching_ad3.append(ent)
        except Exception as e:
            continue
    
    return touching_ad3

def find_arrow_lines_touching_ad3(all_line_entities, ad3_entities, tolerance=0.1):
    """
    ì‚­ì œë  AD3 ì—”í‹°í‹°ì˜ ì ì— ì ‘í•˜ê³ , ARROW ë ˆì´ì–´ì´ë©°, 1mm ì´í•˜ì¸ LINEì„ ì°¾ëŠ” í•¨ìˆ˜
    """
    arrow_lines_to_delete = []
    
    # AD3 ì—”í‹°í‹°ë“¤ì˜ ëª¨ë“  ì  ìˆ˜ì§‘
    ad3_points = []
    for ad3 in ad3_entities:
        try:
            if isinstance(ad3, LWPolyline):
                points = list(ad3.get_points("xy"))
            elif isinstance(ad3, Polyline):
                points = [v.dxf.location for v in ad3.vertices]
            else:
                continue
            
            for p in points:
                ad3_points.append(to2d(p))
        except Exception as e:
            continue
    
    # ARROW ë ˆì´ì–´ì˜ LINE ì—”í‹°í‹° ê²€ìƒ‰
    for ent in all_line_entities:
        if not isinstance(ent, Line):
            continue
        
        if ent.dxf.layer.upper() != "ARROW":
            continue
        
        try:
            # LINEì˜ ê¸¸ì´ ê³„ì‚°
            segments = extract_segments(ent)
            if not segments:
                continue
            
            p0, p1 = segments[0]
            v0, v1 = to2d(p0), to2d(p1)
            line_length = distance(v0, v1)
            
            # 1mm ì´í•˜ì¸ì§€ í™•ì¸
            if line_length > 1.0:
                continue
            
            # AD3 ì ë“¤ê³¼ì˜ ê±°ë¦¬ í™•ì¸
            is_touching_ad3 = False
            for ad3_pt in ad3_points:
                # LINEì˜ ì–‘ ëì ì´ AD3 ì ì— ì ‘í•˜ëŠ”ì§€ í™•ì¸
                if distance(v0, ad3_pt) <= tolerance or distance(v1, ad3_pt) <= tolerance:
                    is_touching_ad3 = True
                    break
            
            if is_touching_ad3:
                arrow_lines_to_delete.append(ent)
        except Exception as e:
            continue
    
    return arrow_lines_to_delete

def find_g1_entities_optimized_with_all_dims(all_line_entities, dim1_ent, dim2_ent, dim_pair, all_used_dim_handles, tolerance=0.2):
    """
    ìµœì í™”ëœ ë²„ì „ - ë¯¸ë¦¬ í•„í„°ë§ëœ ì—”í‹°í‹°ì—ì„œ G1 ì°¾ê¸°
    ëª¨ë“  DIMìœ¼ë¡œ ì‚¬ìš©ëœ ì—”í‹°í‹°ë“¤ì„ ì œì™¸
    """
    g1_candidates = []
    
    dim1_segments = extract_segments(dim1_ent)
    dim2_segments = extract_segments(dim2_ent)
    
    if not dim1_segments or not dim2_segments:
        return []
    
    dim1_start, dim1_end = to2d(dim1_segments[0][0]), to2d(dim1_segments[0][1])
    dim2_start, dim2_end = to2d(dim2_segments[0][0]), to2d(dim2_segments[0][1])
    
    common_point = dim_pair['common_point']
    dim1_common = dim_pair['DIM1_common']
    dim1_opposite = dim_pair['DIM1_opposite']
    dim2_common = dim_pair['DIM2_common'] 
    dim2_opposite = dim_pair['DIM2_opposite']
    
    for ent in all_line_entities:
        if not ent.dxf.layer.startswith(DIM_LAYER_PREFIXES):
            continue
        
        # ğŸ”´ ëª¨ë“  DIMìœ¼ë¡œ ì‚¬ìš©ëœ ì—”í‹°í‹° ì œì™¸ (í˜„ì¬ DIM ìŒë¿ë§Œ ì•„ë‹ˆë¼ ëª¨ë“  DIM)
        if get_entity_handle(ent) in all_used_dim_handles:
            continue
            
        segments = extract_segments(ent)
        if len(segments) != 1:
            continue
        
        p0, p1 = segments[0]
        v0, v1 = to2d(p0), to2d(p1)
        
        min_dist_to_far_ends = min(
            distance(v0, dim1_opposite), distance(v1, dim1_opposite),
            distance(v0, dim2_opposite), distance(v1, dim2_opposite)
        )
        
        far_end_exclusion_distance = 0.5
        if min_dist_to_far_ends <= far_end_exclusion_distance:
            continue
        
        min_dist_to_valid_area = float('inf')
        
        for g1_pt in [v0, v1]:
            dist_to_common = distance(g1_pt, common_point)
            if dist_to_common < min_dist_to_valid_area:
                min_dist_to_valid_area = dist_to_common
        
        for g1_pt in [v0, v1]:
            dist_to_dim1_common = distance(g1_pt, dim1_common)
            dist_to_dim1_line = point_to_line_distance(g1_pt, dim1_start, dim1_end)
            min_dist_dim1 = min(dist_to_dim1_common, dist_to_dim1_line)
            
            if min_dist_dim1 < min_dist_to_valid_area:
                min_dist_to_valid_area = min_dist_dim1
        
        for g1_pt in [v0, v1]:
            dist_to_dim2_common = distance(g1_pt, dim2_common)
            dist_to_dim2_line = point_to_line_distance(g1_pt, dim2_start, dim2_end)
            min_dist_dim2 = min(dist_to_dim2_common, dist_to_dim2_line)
            
            if min_dist_dim2 < min_dist_to_valid_area:
                min_dist_to_valid_area = min_dist_dim2
        
        if min_dist_to_valid_area <= tolerance:
            g1_candidates.append((ent, v0, v1, min_dist_to_valid_area))
    
    if g1_candidates:
        g1_candidates.sort(key=lambda x: x[3])
        closest_g1 = g1_candidates[0]
        return [(closest_g1[0], closest_g1[1], closest_g1[2])]
    
    return []

def find_ct_texts(msp, g1_entities, text_entities, dim_pair, search_radius=10.0):
    """
    G1 ëì ì—ì„œ 50mm ë‚´ì—ì„œ ê¸°ìš¸ê¸° 0ì´ê³  50ë³´ë‹¤ í° ìˆ«ì TEXTë¥¼ ì°¾ì•„
    TBOXë¥¼ ë§Œë“¤ê³  +Xë¡œ TBOX Xê°’/2 ë§Œí¼ ì´ë™í•œ í›„
    CPì—ì„œ ë¨¼ G1 ì ì´ TBOXì˜ 4ì  ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ TBOX ì•ˆì˜ TEXTë¥¼ CTë¡œ ì„ íƒ
    """
    ct_texts = []
    
    common_point = dim_pair['common_point']
    
    for g1_ent, v0, v1 in g1_entities:
        # CPì—ì„œ ë” ë¨¼ G1 ëì  ì°¾ê¸°
        dist_to_common_v0 = distance(v0, common_point)
        dist_to_common_v1 = distance(v1, common_point)
        
        if dist_to_common_v0 > dist_to_common_v1:
            search_point = v0
        else:
            search_point = v1
        
        candidates = []
        
        for txt in text_entities:
            try:
                # RED í…ìŠ¤íŠ¸ ì œì™¸
                if hasattr(txt.dxf, 'color') and txt.dxf.color == 1:
                    continue
                
                # WDNO ë ˆì´ì–´ ì œì™¸
                if hasattr(txt.dxf, 'layer') and 'WDNO' in txt.dxf.layer.upper():
                    continue
                
                # í…ìŠ¤íŠ¸ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
                if hasattr(txt.dxf, 'insert') and txt.dxf.insert is not None:
                    txt_pt = to2d(txt.dxf.insert)
                elif (hasattr(txt.dxf, 'align_point') and txt.dxf.align_point is not None):
                    txt_pt = to2d(txt.dxf.align_point)
                else:
                    continue
            except:
                continue
            
            # G1 ëì ì—ì„œ 50mm ì´ë‚´ì¸ì§€ í™•ì¸
            dist = distance(txt_pt, search_point)
            if dist > search_radius:  # 50mm
                continue
            
            # íšŒì „ê°ì´ 0ì¸ì§€ í™•ì¸
            rotation = float(getattr(txt.dxf, "rotation", 0.0))
            if abs(rotation) > 0.1:
                continue
            
            # í…ìŠ¤íŠ¸ ê°’ ê°€ì ¸ì˜¤ê¸°
            text_val = txt.plain_text() if hasattr(txt, "plain_text") else txt.dxf.text
            
            # ìˆ«ìì¸ì§€ í™•ì¸
            if not text_val.isdigit():
                continue
            
            # 10ë³´ë‹¤ í° ìˆ«ìì¸ì§€ í™•ì¸
            try:
                text_numeric_value = int(text_val)
                if text_numeric_value <= 10:
                    continue
            except:
                continue
            
            # ë‹«íŒ ì˜ì—­ ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
            if is_enclosed(txt_pt, msp):
                continue
            
            # TBOX ìƒì„± (ì¤‘ë³µ ìƒì„± ë°©ì§€)
            tbox_info = create_tbox(txt)
            if tbox_info is None:
                continue
            
            # G1 ëì (search_point)ì—ì„œ TBOX 4ê°œ ì½”ë„ˆê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬
            min_dist_to_tbox = min(distance(search_point, corner) for corner in tbox_info['corners'])
            
            candidates.append((min_dist_to_tbox, txt, text_numeric_value, tbox_info))
        
        if candidates:
            # TBOXê¹Œì§€ì˜ ê±°ë¦¬ê°€ ê°€ì¥ ê°€ê¹Œìš´ í…ìŠ¤íŠ¸ ì„ íƒ
            candidates.sort(key=lambda x: x[0])  # ê±°ë¦¬ìˆœ ì •ë ¬
            selected_candidate = candidates[0]
            
            closest_txt = selected_candidate[1]
            ct_texts.append(closest_txt)
            
            # ë””ë²„ê¹… ì •ë³´ ì¶œë ¥ (ì„ íƒì‚¬í•­)
            print(f"CT ì„ íƒ: í…ìŠ¤íŠ¸={closest_txt.dxf.text}, "
                  f"TBOXê¹Œì§€ ê±°ë¦¬={selected_candidate[0]:.2f}mm, "
                  f"í…ìŠ¤íŠ¸ í¬ê¸°={selected_candidate[3]['text_length']:.2f}x{selected_candidate[3]['text_height']:.2f}")
            
            break
    
    return ct_texts

def get_text_dimensions(txt):
    """
    í…ìŠ¤íŠ¸ì˜ í¬ê¸° ì •ë³´ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ (ê¸¸ì´, ë†’ì´)
    """
    try:
        if txt.dxftype() == "TEXT":
            # TEXT ì—”í‹°í‹°ì˜ ê²½ìš°
            text_val = txt.dxf.text
            height = float(txt.dxf.height)
            # ëŒ€ëµì ì¸ ë¬¸ì í­ ê³„ì‚° (ë†’ì´ì˜ 0.6ë°°ë¡œ ì¶”ì •)
            char_width = height * 0.6
            text_length = len(text_val) * char_width
            return text_length, height
            
        elif txt.dxftype() == "MTEXT":
            # MTEXT ì—”í‹°í‹°ì˜ ê²½ìš°
            text_val = txt.plain_text() if hasattr(txt, "plain_text") else txt.dxf.text
            height = float(txt.dxf.char_height) if hasattr(txt.dxf, 'char_height') else 1.0
            # ëŒ€ëµì ì¸ ë¬¸ì í­ ê³„ì‚°
            char_width = height * 0.6
            text_length = len(text_val) * char_width
            return text_length, height
            
    except Exception as e:
        return 0.0, 0.0
    
    return 0.0, 0.0

def check_ct_dim_interference(ct_position, text_length, text_height, dim1_start, dim1_end, dim2_start, dim2_end):
    """
    CTì™€ DIM1, DIM2 ì„ ë¶„ ê°„ì˜ ê°„ì„­ì„ ì²´í¬í•˜ëŠ” í•¨ìˆ˜
    """
    # í…ìŠ¤íŠ¸ ë†’ì´ì˜ 60%ë¥¼ ê°„ì„­ ì„ê³„ê°’ìœ¼ë¡œ ì‚¬ìš©
    interference_threshold = text_height * 0.6
    
    # DIM1, DIM2 ì„ ë¶„ê³¼ì˜ ê±°ë¦¬ ê³„ì‚°
    dist_to_dim1 = point_to_line_distance(ct_position, dim1_start, dim1_end)
    dist_to_dim2 = point_to_line_distance(ct_position, dim2_start, dim2_end)
    
    # ê°„ì„­ ì—¬ë¶€ íŒë‹¨
    dim1_interference = dist_to_dim1 < interference_threshold
    dim2_interference = dist_to_dim2 < interference_threshold
    
    return dim1_interference or dim2_interference, dist_to_dim1, dist_to_dim2

def calculate_chain_direction(dim1_ent, dim2_ent):
    """
    DIM1, DIM2ë¡œë¶€í„° ì²´ì¸ ë°©í–¥ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
    """
    # DIM1ì˜ ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ ì²´ì¸ ë°©í–¥ ê³„ì‚°
    dim1_segments = extract_segments(dim1_ent)
    if dim1_segments:
        p0, p1 = dim1_segments[0]
        v0, v1 = to2d(p0), to2d(p1)
        chain_dir = angle_deg(v0, v1)
        return chain_dir
    return 0.0

def calculate_text_angle(chain_dir):
    """
    ì²´ì¸ ë°©í–¥ìœ¼ë¡œë¶€í„° í…ìŠ¤íŠ¸ ê°ë„ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
    """
    angle = chain_dir % 360
    
    # ìˆ˜ì§(ìœ„/ì•„ë˜) ë°©í–¥ì¼ ë•Œ í…ìŠ¤íŠ¸ í—¤ë“œë¥¼ ì™¼ìª½(90Â°)ìœ¼ë¡œ ê³ ì •
    if abs(angle - 90) <= ANGLE_TOLERANCE or abs(angle - 270) <= ANGLE_TOLERANCE:
        angle = 90.0
    else:
        # í…ìŠ¤íŠ¸ê°€ ë’¤ì§‘íˆì§€ ì•Šë„ë¡, 90~270Â° êµ¬ê°„ì€ +180Â° ë³´ì •
        if 90 < angle < 270:
            angle = (angle + 180) % 360
    
    return angle

def find_parallel_polylines_for_ang(msp, dim_pair, tolerance=0.5):
    """
    CP ë°˜ëŒ€í¸ ì ì—ì„œ 2ì ì„ ê°€ì§„ í´ë¦¬ë¼ì¸ì„ ì°¾ì•„ ANG ê°ë„ ê³„ì‚° (DIM1, DIM2 ì œì™¸)
    ìµœì í™”: ì „ì²´ ìŠ¤ìº” ëŒ€ì‹  í•„ìš”ì‹œì—ë§Œ í˜¸ì¶œ
    """
    dim1_opposite = dim_pair['DIM1_opposite']
    dim2_opposite = dim_pair['DIM2_opposite']
    
    # DIM1, DIM2 ì œì™¸ ëª©ë¡ ì¶”ê°€
    excluded_handles = {
        get_entity_handle(dim_pair['DIM1']),
        get_entity_handle(dim_pair['DIM2'])
    }
    
    # DIM1ê³¼ DIM2 ë°˜ëŒ€í¸ ì ë“¤ ê·¼ì²˜ì—ì„œ í´ë¦¬ë¼ì¸ ì°¾ê¸°
    search_points = [dim1_opposite, dim2_opposite]
    found_polylines = []
    
    # í•„ìš”ì‹œì—ë§Œ ì¿¼ë¦¬ ì‹¤í–‰ (ANG ê°ë„ ê³„ì‚°ì‹œì—ë§Œ)
    for search_point in search_points:
        for ent in msp.query("LWPOLYLINE POLYLINE"):
            if not ent.dxf.layer.startswith(DIM_LAYER_PREFIXES):
                continue
            
            # DIM1, DIM2 ì œì™¸
            if get_entity_handle(ent) in excluded_handles:
                continue
            
            # í´ë¦¬ë¼ì¸ì˜ ì ë“¤ ì¶”ì¶œ
            if isinstance(ent, LWPolyline):
                points = list(ent.get_points("xy"))
            else:
                points = [v.dxf.location for v in ent.vertices]
            
            if len(points) != 2:  # ì •í™•íˆ 2ê°œì˜ ì ë§Œ ê²€ìƒ‰
                continue
            
            # í´ë¦¬ë¼ì¸ì˜ ê° ì ì´ ê²€ìƒ‰ ì  ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸
            pts = [to2d(p) for p in points]
            min_distance = min(distance(pt, search_point) for pt in pts)
            
            if min_distance <= tolerance:
                # í´ë¦¬ë¼ì¸ì˜ ë°©í–¥ ê°ë„ ê³„ì‚° (ì²« ë²ˆì§¸ì™€ ë‘ ë²ˆì§¸ ì  ê¸°ì¤€)
                polyline_angle = angle_deg(pts[0], pts[1])
                found_polylines.append((ent, polyline_angle, min_distance, search_point))
    
    # ê°€ì¥ ê°€ê¹Œìš´ í´ë¦¬ë¼ì¸ì˜ ê°ë„ë¥¼ ANGë¡œ ì‚¬ìš©
    if found_polylines:
        # ê±°ë¦¬ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
        found_polylines.sort(key=lambda x: x[2])
        closest_polyline = found_polylines[0]
        ang_angle = closest_polyline[1]
        return ang_angle
    else:
        return 0.0

def find_and_color_ct1_polylines(msp, dim_pair, tolerance=0.5):
    """
    DIM1 ì–‘ëì—ì„œ 2ì ì„ ê°€ì§„ í´ë¦¬ë¼ì¸ì„ ì°¾ì•„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½í•˜ëŠ” í•¨ìˆ˜
    """
    dim1_common = dim_pair['DIM1_common']
    dim1_opposite = dim_pair['DIM1_opposite']
    
    # DIM1, DIM2 ì œì™¸ ëª©ë¡ ì¶”ê°€
    excluded_handles = {
        get_entity_handle(dim_pair['DIM1']),
        get_entity_handle(dim_pair['DIM2'])
    }
    
    # DIM1 ì–‘ëì—ì„œ í´ë¦¬ë¼ì¸ ì°¾ê¸°
    search_points = [dim1_common, dim1_opposite]
    found_polylines = []
    
    for search_point in search_points:
        for ent in msp.query("LWPOLYLINE POLYLINE"):
            if not ent.dxf.layer.startswith(DIM_LAYER_PREFIXES):
                continue
            
            # DIM1, DIM2 ì œì™¸
            if get_entity_handle(ent) in excluded_handles:
                continue
            
            # í´ë¦¬ë¼ì¸ì˜ ì ë“¤ ì¶”ì¶œ
            if isinstance(ent, LWPolyline):
                points = list(ent.get_points("xy"))
            else:
                points = [v.dxf.location for v in ent.vertices]
            
            if len(points) != 2:  # ì •í™•íˆ 2ê°œì˜ ì ë§Œ ê²€ìƒ‰
                continue
            
            # í´ë¦¬ë¼ì¸ì˜ ê° ì ì´ ê²€ìƒ‰ ì  ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸
            pts = [to2d(p) for p in points]
            min_distance = min(distance(pt, search_point) for pt in pts)
            
            if min_distance <= tolerance:
                found_polylines.append((ent, min_distance))
    
    # ê°€ì¥ ê°€ê¹Œìš´ í´ë¦¬ë¼ì¸ì„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½
    if found_polylines:
        # ê±°ë¦¬ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
        found_polylines.sort(key=lambda x: x[1])
        closest_polyline = found_polylines[0][0]
        # í°ìƒ‰ìœ¼ë¡œ ë³€ê²½ (ìƒ‰ìƒ ì½”ë“œ 7)
        closest_polyline.dxf.color = 7

def process_ct_text_with_enhanced_interference_check(txt, g1_ent, v0, v1, text_angle, common_point, dim_pair, msp):
    """
    ê°•í™”ëœ CT í…ìŠ¤íŠ¸ ì´ë™ ë° ê°„ì„­ ê²€ì‚¬ ì²˜ë¦¬
    ìˆ˜ì •ì‚¬í•­: 
    - CT1 ì¡°ê±´: 1.2 <= dim_length <= 1.5 (íšŒì „ ì—†ìŒ, í´ë¦¬ë¼ì¸ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½)
    - ANG ì‚¬ìš© ì¡°ê±´: 1.5 <= dim_length <= 2.0
    """
    try:
        # í˜„ì¬ í…ìŠ¤íŠ¸ ìœ„ì¹˜ í™•ì¸
        if hasattr(txt.dxf, 'insert') and txt.dxf.insert is not None:
            current_pos = to2d(txt.dxf.insert)
        elif (hasattr(txt.dxf, 'align_point') and txt.dxf.align_point is not None):
            current_pos = to2d(txt.dxf.align_point)
        else:
            return
    except:
        return
    
    # DIM1, DIM2 ì„ ë¶„ ì •ë³´ ì¶”ì¶œ
    dim1_ent = dim_pair['DIM1']
    dim2_ent = dim_pair['DIM2']
    
    dim1_segments = extract_segments(dim1_ent)
    dim2_segments = extract_segments(dim2_ent)
    
    if not dim1_segments or not dim2_segments:
        return
    
    dim1_start, dim1_end = to2d(dim1_segments[0][0]), to2d(dim1_segments[0][1])
    dim2_start, dim2_end = to2d(dim2_segments[0][0]), to2d(dim2_segments[0][1])
    
    # DIM1, DIM2 ê¸¸ì´ í™•ì¸
    dim_length = dim_pair['length']
    is_ct1 = 1.2 <= dim_length <= 1.5  # ìˆ˜ì •ëœ ì¡°ê±´
    
    # íšŒì „ ê°ë„ ê²°ì •
    if is_ct1:
        # CT1ì˜ ê²½ìš°: íšŒì „ ê°ë„ë¥¼ 0ìœ¼ë¡œ ì„¤ì •í•˜ê³  ê´€ë ¨ í´ë¦¬ë¼ì¸ì„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½
        final_angle = 0.0
        find_and_color_ct1_polylines(msp, dim_pair)
    else:
        # CTì˜ ê²½ìš°: ê¸°ì¡´ ë¡œì§ ì‚¬ìš©
        use_ang_angle = 1.5 <= dim_length <= 2.0  # ìˆ˜ì •ëœ ì¡°ê±´
        if use_ang_angle:
            # ANG ê°ë„ ê³„ì‚°
            ang_angle = find_parallel_polylines_for_ang(msp, dim_pair)
            final_angle = ang_angle
        else:
            # ê¸°ì¡´ text_angle ì‚¬ìš©
            final_angle = text_angle
    
    # í…ìŠ¤íŠ¸ ê¸¸ì´ ë° ë†’ì´ ê³„ì‚°
    text_length, text_height = get_text_dimensions(txt)
    text_half_length = text_length / 2.0
    
    # í…ìŠ¤íŠ¸ ë°©í–¥ ë‹¨ìœ„ë²¡í„° ê³„ì‚° (final_angle ê¸°ì¤€)
    text_angle_rad = math.radians(final_angle)
    text_direction = np.array([math.cos(text_angle_rad), math.sin(text_angle_rad)])
    
    # í…ìŠ¤íŠ¸ ìˆ˜ì§ ë°©í–¥ ê³„ì‚° (ì¢Œìš° ì´ë™ìš©)
    text_perpendicular = np.array([-math.sin(text_angle_rad), math.cos(text_angle_rad)])
    
    # 1ë‹¨ê³„: CT ì¤‘ì‹¬ì„ CPë¡œ ë§ì¶”ê¸°
    cp_centered_point = common_point - text_direction * text_half_length
    
    # 2ë‹¨ê³„: CPì—ì„œ TEXT ì¤‘ì‹¬ ë°©í–¥ìœ¼ë¡œ 0.6mm ì´ë™
    # CPì—ì„œ í˜„ì¬ í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì ìœ¼ë¡œì˜ ë°©í–¥ ë²¡í„° ê³„ì‚°
    current_text_center = cp_centered_point + text_direction * text_half_length  # CP ì •ë ¬ëœ ìƒíƒœì˜ í…ìŠ¤íŠ¸ ì¤‘ì‹¬
    cp_to_text_center_vec = current_text_center - common_point
    cp_to_text_center_distance = np.linalg.norm(cp_to_text_center_vec)
    
    if cp_to_text_center_distance > 0:
        # CPì—ì„œ í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì  ë°©í–¥ ë‹¨ìœ„ë²¡í„°
        cp_to_text_center_direction = cp_to_text_center_vec / cp_to_text_center_distance
        # 0.6mm ì´ë™
        move_0_6mm = cp_to_text_center_direction * 0.6
        intermediate_point = cp_centered_point + move_0_6mm
    else:
        # CPì™€ í…ìŠ¤íŠ¸ ì¤‘ì‹¬ì ì´ ê°™ìœ¼ë©´ í…ìŠ¤íŠ¸ ë°©í–¥ìœ¼ë¡œ 0.6mm ì´ë™
        move_0_6mm = text_direction * 0.6
        intermediate_point = cp_centered_point + move_0_6mm
    
    # 3ë‹¨ê³„: ê°„ì„­ ê²€ì‚¬
    interference_detected, _, _ = check_ct_dim_interference(
        intermediate_point, text_length, text_height, dim1_start, dim1_end, dim2_start, dim2_end
    )
    
    final_position = intermediate_point
    
    if interference_detected:
        # 4ë‹¨ê³„: ê°„ì„­ ë°œìƒì‹œ ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œ 1.2mm ì´ë™
        if cp_to_text_center_distance > 0:
            # 0.6mm ì´ë™ ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œ 1.2mm
            interference_avoid_move = -cp_to_text_center_direction * 1.2
            candidate_position = intermediate_point + interference_avoid_move
        else:
            # í…ìŠ¤íŠ¸ ë°©í–¥ ë°˜ëŒ€ë¡œ 1.2mm
            interference_avoid_move = -text_direction * 1.2
            candidate_position = intermediate_point + interference_avoid_move
        
        # ë°˜ëŒ€ë°©í–¥ ì´ë™ í›„ ê°„ì„­ ì¬ê²€ì‚¬
        interference_still_detected, _, _ = check_ct_dim_interference(
            candidate_position, text_length, text_height, dim1_start, dim1_end, dim2_start, dim2_end
        )
        
        if not interference_still_detected:
            # ê°„ì„­ í•´ê²°ë¨
            final_position = candidate_position
        else:
            # 5ë‹¨ê³„: ì—¬ì „íˆ ê°„ì„­ ì‹œ ì¢Œìš°, ìœ„ì•„ë˜ë¡œ 1mmì”© ìµœëŒ€ 4ë²ˆ ì´ë™
            positions_to_try = []
            
            # ì¢Œìš° ì´ë™ ìœ„ì¹˜ë“¤ ìƒì„± (ìš°ì„ ìˆœìœ„: ì¢Œìš°)
            for offset in [1.0, -1.0, 2.0, -2.0, 3.0, -3.0, 4.0, -4.0]:
                side_move = text_perpendicular * offset
                test_position = candidate_position + side_move
                positions_to_try.append(test_position)
            
            # ìœ„ì•„ë˜ ì´ë™ ìœ„ì¹˜ë“¤ ìƒì„± (ì°¨ìˆœìœ„: ìœ„ì•„ë˜)
            for offset in [1.0, -1.0, 2.0, -2.0, 3.0, -3.0, 4.0, -4.0]:
                vertical_move = text_direction * offset
                test_position = candidate_position + vertical_move
                positions_to_try.append(test_position)
            
            # ê° ìœ„ì¹˜ì—ì„œ ê°„ì„­ ê²€ì‚¬
            best_position = candidate_position  # ê¸°ë³¸ê°’
            
            for test_pos in positions_to_try:
                test_interference, _, _ = check_ct_dim_interference(
                    test_pos, text_length, text_height, dim1_start, dim1_end, dim2_start, dim2_end
                )
                
                if not test_interference:
                    # ê°„ì„­ ì—†ëŠ” ì²« ë²ˆì§¸ ìœ„ì¹˜ ì„ íƒ
                    best_position = test_pos
                    break
            
            final_position = best_position
    
    # 6ë‹¨ê³„: ìµœì¢… ìœ„ì¹˜ì—ì„œ CP ë°©í–¥ìœ¼ë¡œ 2mm ì¶”ê°€ ì´ë™
    # final_positionì—ì„œ common_point ë°©í–¥ìœ¼ë¡œì˜ ë‹¨ìœ„ë²¡í„° ê³„ì‚°
    final_to_cp_vec = common_point - final_position
    final_to_cp_distance = np.linalg.norm(final_to_cp_vec)
    
    if final_to_cp_distance > 0:
        # CP ë°©í–¥ ë‹¨ìœ„ë²¡í„°
        final_to_cp_direction = final_to_cp_vec / final_to_cp_distance
        # CP ë°©í–¥ìœ¼ë¡œ 2mm ì´ë™
        cp_move_2mm = final_to_cp_direction * 2.0
        final_position = final_position + cp_move_2mm
    
    # ğŸ”´ ë³€ê²½: DIM1 ê¸°ìš¸ê¸°ë¡œ í‰í–‰í•˜ê²Œ CP ë°©í–¥ìœ¼ë¡œ 1.2mm ì´ë™
    move_distance = -2 # mm
    
    # DIM1 ì„ ë¶„ ì •ë³´
    dim1_segments = extract_segments(dim_pair['DIM1'])
    if dim1_segments:
        dim1_start, dim1_end = to2d(dim1_segments[0][0]), to2d(dim1_segments[0][1])
        
        # DIM1ì˜ ë°©í–¥ ë²¡í„°
        dim1_vec = dim1_end - dim1_start
        dim1_length = np.linalg.norm(dim1_vec)
        
        if dim1_length > 0:
            # DIM1ì˜ ë‹¨ìœ„ ë°©í–¥ ë²¡í„°
            dim1_unit = dim1_vec / dim1_length
            
            # í˜„ì¬ ìœ„ì¹˜ì—ì„œ CPë¡œì˜ ë°©í–¥ ë²¡í„°
            to_cp_vec = common_point - final_position
            
            # CP ë°©í–¥ì„ DIM1 ë°©í–¥ì— íˆ¬ì˜
            projection_length = np.dot(to_cp_vec, dim1_unit)
            
            # CP ë°©í–¥ì´ DIM1ê³¼ ê°™ì€ ë°©í–¥ì¸ì§€ ë°˜ëŒ€ ë°©í–¥ì¸ì§€ í™•ì¸
            if projection_length > 0:
                move_direction = dim1_unit  # DIM1ê³¼ ê°™ì€ ë°©í–¥
            else:
                move_direction = -dim1_unit  # DIM1ê³¼ ë°˜ëŒ€ ë°©í–¥
            
            # 1.2mm ì´ë™
            final_position = final_position + move_direction * move_distance
    # 7ë‹¨ê³„: í…ìŠ¤íŠ¸ ì´ë™ ë° íšŒì „ ì²˜ë¦¬
    if txt.dxftype() == "TEXT":
        old_z = float(txt.dxf.insert[2]) if len(txt.dxf.insert) > 2 else 0.0
        txt.dxf.insert = (float(final_position[0]), float(final_position[1]), old_z)
        txt.dxf.halign = 0
        txt.dxf.valign = 0
        try:
            if hasattr(txt.dxf, 'align_point'):
                delattr(txt.dxf, 'align_point')
        except:
            pass
        txt.dxf.rotation = float(final_angle)
        
    elif txt.dxftype() == "MTEXT":
        old_z = float(txt.dxf.insert[2]) if len(txt.dxf.insert) > 2 else 0.0
        txt.dxf.insert = (float(final_position[0]), float(final_position[1]), old_z)
        txt.dxf.attachment_point = 1
        txt.dxf.rotation = float(final_angle)
    
    # CT1 ë³€ìˆ˜ë¡œ ì²˜ë¦¬ë˜ì—ˆìŒì„ ë¦¬í„´ (ë””ë²„ê¹…ìš©)
    return is_ct1
def process_dimension_system(msp, text_entities):
    """
    DB1, CH1 ì¹˜ìˆ˜ì„  ì‹œìŠ¤í…œ ì²˜ë¦¬ (ì¿¼ë¦¬ ìµœì í™” ì ìš© + ê°•í™”ëœ AD3 ì‚­ì œ, AD1/AD2 ë³´í˜¸)
    DIM1, DIM2, AD1, AD2ëŠ” ì ˆëŒ€ ì‚­ì œë˜ì§€ ì•ŠìŒì„ ë³´ì¥
    CP(ê³µí†µì )ì˜ 3ì  ARROW ë ˆì´ì–´ì™€ DIM ì„ ë¶„ì— ì ‘í•˜ëŠ” ARROW ë ˆì´ì–´ AD3 ì‚­ì œ
    """
    # ğŸš€ ì¿¼ë¦¬ ìµœì í™”: í•œ ë²ˆë§Œ ìŠ¤ìº” í›„ ë¶„ë¥˜
    all_line_entities = list(msp.query("LINE LWPOLYLINE POLYLINE"))
    
    # find_dim_pairs í•¨ìˆ˜ì— ë¯¸ë¦¬ ìŠ¤ìº”ëœ ì—”í‹°í‹° ì „ë‹¬
    dim_pairs, overlapped_entities = find_dim_pairs_optimized(all_line_entities)
    
    all_processed_entities = []
    all_ct_texts = []
    all_ct1_texts = []  # CT1 í…ìŠ¤íŠ¸ ë³„ë„ ì¶”ì 
    g1_entities_to_delete = []
    ad3_entities_to_delete = []
    arrow_lines_to_delete = []  # ì¶”ê°€ëœ ARROW LINE ì‚­ì œ ëª©ë¡
    
    # ë³´í˜¸í•  ì—”í‹°í‹° ëª©ë¡ (ì ˆëŒ€ ì‚­ì œë˜ë©´ ì•ˆ ë¨)
    protected_entities = set()
    protected_entities_list = []  # ë¦¬ìŠ¤íŠ¸ë¡œë„ ê´€ë¦¬
    
    # AD1, AD2ë¥¼ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸ (ì „ì²´ í”„ë¡œì„¸ìŠ¤ì—ì„œ ë³´í˜¸ìš©)
    all_ad1_ad2_entities = []
    
    # DIMì˜ ë°˜ëŒ€í¸ ëì ë“¤ì„ ì €ì¥ (AD1, AD2 ìœ„ì¹˜)
    all_dim_far_endpoints = []
    
    # ğŸ”´ ëª¨ë“  DIMìœ¼ë¡œ ì‚¬ìš©ëœ ì—”í‹°í‹°ë“¤ì˜ í•¸ë“¤ ìˆ˜ì§‘ (G1 ì œì™¸ìš©)
    all_used_dim_handles = set()
    for dim_pair in dim_pairs:
        all_used_dim_handles.add(get_entity_handle(dim_pair['DIM1']))
        all_used_dim_handles.add(get_entity_handle(dim_pair['DIM2']))
    
    all_processed_entities.extend(overlapped_entities)
    
    for i, dim_pair in enumerate(dim_pairs):
        dim1 = dim_pair['DIM1']
        dim2 = dim_pair['DIM2']
        dim1_opposite = dim_pair['DIM1_opposite']
        dim2_opposite = dim_pair['DIM2_opposite']
        dim1_common = dim_pair['DIM1_common']
        dim2_common = dim_pair['DIM2_common']
        
        # DIMì˜ ë°˜ëŒ€í¸ ëì ë“¤ ì €ì¥ (AD1, AD2ê°€ ìœ„ì¹˜í•˜ëŠ” ê³³)
        all_dim_far_endpoints.extend([dim1_opposite, dim2_opposite])
        
        # DIM1, DIM2ë¥¼ ë³´í˜¸ ëª©ë¡ì— ì¶”ê°€
        protected_entities.add(get_entity_handle(dim1))
        protected_entities.add(get_entity_handle(dim2))
        protected_entities_list.append(dim1)
        protected_entities_list.append(dim2)
        
        # ì²´ì¸ ë°©í–¥ ê³„ì‚°
        chain_dir = calculate_chain_direction(dim1, dim2)
        text_angle = calculate_text_angle(chain_dir)
        
        # DIM1, DIM2ë¥¼ GREENìœ¼ë¡œ í‘œì‹œ
        dim1.dxf.color = 3
        dim2.dxf.color = 3
        all_processed_entities.extend([dim1, dim2])
        
        # AD1, AD2 ì°¾ê¸° (ìµœì í™”ëœ ë²„ì „) - DIM_LAYER_PREFIXESì—ì„œë§Œ ì°¾ìŒ
        ad1_entities = find_arrow_entities_optimized(all_line_entities, dim1_opposite)
        ad2_entities = find_arrow_entities_optimized(all_line_entities, dim2_opposite)
        
        # AD1, AD2ë¥¼ ë³´í˜¸ ëª©ë¡ì— ì¶”ê°€
        for ad1 in ad1_entities:
            protected_entities.add(get_entity_handle(ad1))
            protected_entities_list.append(ad1)
            all_ad1_ad2_entities.append(ad1)
        for ad2 in ad2_entities:
            protected_entities.add(get_entity_handle(ad2))
            protected_entities_list.append(ad2)
            all_ad1_ad2_entities.append(ad2)
        
        # AD1, AD2ë¥¼ YELLOWë¡œ í‘œì‹œ
        for ad1 in ad1_entities:
            ad1.dxf.color = 2
            all_processed_entities.append(ad1)
        
        for ad2 in ad2_entities:
            ad2.dxf.color = 2
            all_processed_entities.append(ad2)
        
        # AD3 ì°¾ê¸° (ìµœì í™”ëœ ë²„ì „) - CP ê·¼ì²˜ì˜ 3ì  í´ë¦¬ë¼ì¸ (ARROW ë ˆì´ì–´ í¬í•¨)
        ad3_entities = find_ad3_entities_optimized(all_line_entities, dim_pair, ad1_entities, ad2_entities)
        
        # ğŸ”´ G1 ì°¾ê¸° - ëª¨ë“  DIM í•¸ë“¤ ì „ë‹¬í•˜ì—¬ ì œì™¸
        g1_entities = find_g1_entities_optimized_with_all_dims(
            all_line_entities, dim1, dim2, dim_pair, all_used_dim_handles
        )
        
        # CT ì°¾ê¸° ë° ì²˜ë¦¬
        ct_found = False
        for g1_ent, v0, v1 in g1_entities:
            g1_ent.dxf.color = 1
            all_processed_entities.append(g1_ent)
            g1_entities_to_delete.append(g1_ent)
            
            # CT ì°¾ê¸°
            ct_texts = find_ct_texts(msp, [(g1_ent, v0, v1)], text_entities, dim_pair)
            
            if ct_texts:
                ct_found = True
                for ct in ct_texts:
                    ct.dxf.color = 2
                    
                    # ê°•í™”ëœ í…ìŠ¤íŠ¸ ì´ë™ ë° ê°„ì„­ ê²€ì‚¬
                    is_ct1 = process_ct_text_with_enhanced_interference_check(
                        ct, g1_ent, v0, v1, text_angle, dim_pair['common_point'], dim_pair, msp
                    )
                    
                    # CT1 ë³€ìˆ˜ì¸ì§€ CT ë³€ìˆ˜ì¸ì§€ êµ¬ë¶„í•˜ì—¬ ì €ì¥
                    if is_ct1:
                        all_ct1_texts.append(ct)
                    else:
                        all_ct_texts.append(ct)
        
        # ... ë‚˜ë¨¸ì§€ ì½”ë“œëŠ” ë™ì¼ ...
        
        # CTë¥¼ ì°¾ì•˜ì„ ë•Œë§Œ AD3 ì‚­ì œ (CP ê·¼ì²˜ì˜ 3ì  ARROW í¬í•¨)
        if ct_found:
            for ad3 in ad3_entities:
                # ë³´í˜¸ëœ ì—”í‹°í‹°ê°€ ì•„ë‹Œ ê²½ìš°ë§Œ ì‚­ì œ ëª©ë¡ì— ì¶”ê°€
                if (get_entity_handle(ad3) not in protected_entities and 
                    ad3 not in all_ad1_ad2_entities and
                    ad3 not in protected_entities_list):
                    ad3.dxf.color = 4
                    all_processed_entities.append(ad3)
                    ad3_entities_to_delete.append(ad3)
                else:
                    # ë³´í˜¸ëœ ì—”í‹°í‹°ëŠ” ìƒ‰ìƒë§Œ ë³€ê²½
                    ad3.dxf.color = 2
                    all_processed_entities.append(ad3)
        else:
            for ad3 in ad3_entities:
                ad3.dxf.color = 2
                all_processed_entities.append(ad3)
        
        # DIM1, DIM2 ì„ ë¶„ì— ì ‘í•˜ëŠ” AD3 ì°¾ê¸° (ARROW ë ˆì´ì–´, 0.2mm ì´ë‚´)
        touching_ad3 = find_ad3_touching_dims(all_line_entities, dim1, dim2, ad1_entities, ad2_entities)
        for touching_ad3_ent in touching_ad3:
            # ë³´í˜¸ëœ ì—”í‹°í‹°ê°€ ì•„ë‹ˆê³  ì´ë¯¸ ì‚­ì œ ëª©ë¡ì— ì—†ëŠ” ê²½ìš°ë§Œ ì¶”ê°€
            if (get_entity_handle(touching_ad3_ent) not in protected_entities and 
                touching_ad3_ent not in ad3_entities_to_delete and
                touching_ad3_ent not in all_ad1_ad2_entities and
                touching_ad3_ent not in protected_entities_list):  # : ì¶”ê°€ë¨
                touching_ad3_ent.dxf.color = 4  # ì‚­ì œ ì˜ˆì • í‘œì‹œ
                all_processed_entities.append(touching_ad3_ent)
                ad3_entities_to_delete.append(touching_ad3_ent)
    # DIMì˜ ë°˜ëŒ€í¸ ëì  ê·¼ì²˜ì˜ ARROW ë ˆì´ì–´ ë³´í˜¸ (AD1, AD2 ë³´í˜¸)
    for ent in all_line_entities:
        if ent.dxf.layer.upper() == "ARROW":
            try:
                if isinstance(ent, LWPolyline):
                    points = list(ent.get_points("xy"))
                elif isinstance(ent, Polyline):
                    points = [v.dxf.location for v in ent.vertices]
                else:
                    continue
                
                pts = [to2d(p) for p in points]
                
                # DIMì˜ ë°˜ëŒ€í¸ ëì  ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸ (AD1, AD2 ìœ„ì¹˜)
                for pt in pts:
                    for far_endpoint in all_dim_far_endpoints:
                        if distance(pt, far_endpoint) <= 0.5:  # ë°˜ëŒ€í¸ ëì ì—ì„œ 0.5mm ì´ë‚´
                            protected_entities.add(get_entity_handle(ent))
                            break
            except:
                continue

    # ì‚­ì œë  AD3 ì ì— ì ‘í•˜ëŠ” ARROW ë ˆì´ì–´ì˜ 1mm ì´í•˜ LINE ì°¾ê¸°
    arrow_lines = find_arrow_lines_touching_ad3(all_line_entities, ad3_entities_to_delete)
    for arrow_line in arrow_lines:
        # ë³´í˜¸ëœ ì—”í‹°í‹°ê°€ ì•„ë‹Œ ê²½ìš°ë§Œ ì‚­ì œ ëª©ë¡ì— ì¶”ê°€
        if (get_entity_handle(arrow_line) not in protected_entities and
            arrow_line not in protected_entities_list):
            arrow_line.dxf.color = 4  # ì‚­ì œ ì˜ˆì • í‘œì‹œ
            all_processed_entities.append(arrow_line)
            arrow_lines_to_delete.append(arrow_line)

    # ì‚­ì œ ì „ ìµœì¢… ê²€ì¦: AD1, AD2ê°€ ì‚­ì œ ëª©ë¡ì— ìˆëŠ”ì§€ í™•ì¸
    ad3_entities_to_delete_final = []
    for ad3_ent in ad3_entities_to_delete:
        if (ad3_ent not in all_ad1_ad2_entities and 
            ad3_ent not in protected_entities_list and
            get_entity_handle(ad3_ent) not in protected_entities):
            ad3_entities_to_delete_final.append(ad3_ent)

    arrow_lines_to_delete_final = []
    for arrow_line in arrow_lines_to_delete:
        if (arrow_line not in all_ad1_ad2_entities and
            arrow_line not in protected_entities_list and
            get_entity_handle(arrow_line) not in protected_entities):
            arrow_lines_to_delete_final.append(arrow_line)

    # ì—”í‹°í‹° ì‚­ì œ (ë³´í˜¸ëœ ì—”í‹°í‹° ì œì™¸)
    deleted_count = 0
    for ad3_ent in ad3_entities_to_delete_final:
        try:
            # ì‚­ì œ ì§ì „ ìµœì¢… í™•ì¸
            if (get_entity_handle(ad3_ent) not in protected_entities and
                ad3_ent not in protected_entities_list and
                ad3_ent not in all_ad1_ad2_entities):
                msp.delete_entity(ad3_ent)
                deleted_count += 1
        except:
            pass

    for g1_ent in g1_entities_to_delete:
        try:
            # G1ì€ ë³´í˜¸ ëŒ€ìƒì´ ì•„ë‹ˆë¯€ë¡œ ì‚­ì œ
            if get_entity_handle(g1_ent) not in protected_entities:
                msp.delete_entity(g1_ent)
        except:
            pass

    # ARROW LINE ì‚­ì œ
    for arrow_line in arrow_lines_to_delete_final:
        try:
            # ì‚­ì œ ì§ì „ ìµœì¢… í™•ì¸
            if (get_entity_handle(arrow_line) not in protected_entities and
                arrow_line not in protected_entities_list):
                msp.delete_entity(arrow_line)
        except:
            pass

    return all_processed_entities, all_ct_texts, all_ct1_texts


    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ë©”ì¸ íŒŒì´í”„ë¼ì¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def auto_align_dxf(input_dxf, output_dxf):
    """
    DB1, CH1ë§Œ ì²˜ë¦¬í•˜ëŠ” ë‹¨ì¼ DXF íŒŒì¼ ì²˜ë¦¬ í•¨ìˆ˜ (ë¡œê·¸ ìµœì†Œí™”)
    """
    if not os.path.isfile(input_dxf):
        return False
    
    try:
        # TBOX ìºì‹œ ì´ˆê¸°í™”
        clear_tbox_cache()
        
        doc = ezdxf.readfile(input_dxf)
        msp = doc.modelspace()

        # í…ìŠ¤íŠ¸ ì—”í‹°í‹° ìˆ˜ì§‘
        text_entities = list(msp.query("TEXT MTEXT"))
        
        # DB1, CH1 ì¹˜ìˆ˜ì„  ì‹œìŠ¤í…œ ì²˜ë¦¬
        processed_entities, ct_texts, ct1_texts = process_dimension_system(msp, text_entities)

        # ì €ì¥
        doc.saveas(output_dxf)
        
        # ì²˜ë¦¬ ì™„ë£Œ í›„ TBOX ìºì‹œ ì´ˆê¸°í™”
        clear_tbox_cache()
        
        return True
        
    except Exception as e:
        # ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ TBOX ìºì‹œ ì´ˆê¸°í™”
        clear_tbox_cache()
        return False

def process_multiple_files():
    """
    ì—¬ëŸ¬ DXF íŒŒì¼ì„ ì²˜ë¦¬í•˜ëŠ” ë©”ì¸ í•¨ìˆ˜ (ë¡œê·¸ ìµœì†Œí™”)
    """
    selected_files = select_dxf_files()
    
    if not selected_files:
        return
    
    progress_window, progress_var, file_label, progress_text = show_progress_window(len(selected_files))
    
    success_count = 0
    failed_files = []
    
    try:
        for i, input_file in enumerate(selected_files):
            update_progress(progress_window, progress_var, file_label, progress_text, 
                          i, len(selected_files), input_file)
            
            file_dir = os.path.dirname(input_file)
            file_name = os.path.splitext(os.path.basename(input_file))[0]
            output_file = os.path.join(file_dir, f"{file_name}_DIM.dxf")
            
            if auto_align_dxf(input_file, output_file):
                success_count += 1
            else:
                failed_files.append(os.path.basename(input_file))
        
        update_progress(progress_window, progress_var, file_label, progress_text, 
                      len(selected_files), len(selected_files), "ì™„ë£Œ")
        
    finally:
        close_progress_window(progress_window)
    
    # ìµœì¢… ê²°ê³¼ ì¶œë ¥
    print(f"âœ… ì„±ê³µ: {success_count}ê°œ íŒŒì¼")
    if failed_files:
        print(f"âŒ ì‹¤íŒ¨: {len(failed_files)}ê°œ íŒŒì¼")
        for file_name in failed_files:
            print(f"  - {file_name}")
    
    print("í”„ë¡œê·¸ë¨ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")


if __name__ == "__main__":
    if len(sys.argv) == 3:
        auto_align_dxf(sys.argv[1], sys.argv[2])
    else:
        process_multiple_files()