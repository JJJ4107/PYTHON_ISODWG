import ezdxf
import os
import math
from ezdxf.math import Vec2
from tkinter import Tk, filedialog

def select_dxf_files():
    root = Tk()
    root.withdraw()
    file_paths = filedialog.askopenfilenames(
        title="DXF íŒŒì¼ ì„ íƒ",
        filetypes=[("DXF Files", "*.dxf")]
    )
    root.destroy()
    return file_paths

def extract_points(entity):
    if entity.dxftype() == 'LWPOLYLINE':
        return [Vec2(x, y) for x, y, *_ in entity.get_points()]
    elif entity.dxftype() == 'POLYLINE':
        try:
            return [Vec2(v.dxf.location.x, v.dxf.location.y) for v in entity]
        except:
            return []
    return []

def distance(p1, p2):
    return math.hypot(p2.x - p1.x, p2.y - p1.y)

def get_angle(p1, p2):
    return math.degrees(math.atan2(p2.y - p1.y, p2.x - p1.x))

def get_offset_by_angle(angle_deg, distance_mm):
    angle_rad = math.radians(angle_deg)
    return Vec2(math.cos(angle_rad), math.sin(angle_rad)) * distance_mm

def get_perpendicular_offset(angle_deg, distance_mm):
    angle_rad = math.radians(angle_deg + 90)
    return Vec2(math.cos(angle_rad), math.sin(angle_rad)) * distance_mm

def rotate_point(point, center, angle_deg):
    angle_rad = math.radians(angle_deg)
    dx, dy = point - center
    cos_a, sin_a = math.cos(angle_rad), math.sin(angle_rad)
    return Vec2(center.x + dx * cos_a - dy * sin_a,
                center.y + dx * sin_a + dy * cos_a)

def rotate_text(text, center, angle_deg):
    insert = text.dxf.insert
    pt = Vec2(insert[0], insert[1])
    new_pt = rotate_point(pt, center, angle_deg)
    text.dxf.insert = (new_pt.x, new_pt.y, 0)
    text.dxf.rotation += angle_deg

def move_text(text, offset):
    insert = text.dxf.insert
    pt = Vec2(insert[0], insert[1])
    new_pt = pt + offset
    text.dxf.insert = (new_pt.x, new_pt.y, 0)

def segments_cross(a1, a2, b1, b2):
    def ccw(A, B, C):
        return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x)
    return (ccw(a1, b1, b2) != ccw(a2, b1, b2)) and (ccw(a1, a2, b1) != ccw(a1, a2, b2))

def polyline_intersects_with_fall(pl_points, fall_points):
    """í´ë¦¬ë¼ì¸ì´ FALL í´ë¦¬ë¼ì¸ì˜ ì–´ë–¤ ì„ ë¶„ê³¼ë„ êµì°¨í•˜ëŠ”ì§€ í™•ì¸"""
    for i in range(len(fall_points)):
        j = (i + 1) % len(fall_points)
        fall_seg_start = fall_points[i]
        fall_seg_end = fall_points[j]
        
        for k in range(len(pl_points) - 1):
            pl_seg_start = pl_points[k]
            pl_seg_end = pl_points[k + 1]
            
            if segments_cross(fall_seg_start, fall_seg_end, pl_seg_start, pl_seg_end):
                return True
    return False

def g1_crosses_both_fall_segments(g1_pts, fall_pts):
    """G1ì´ FALLì˜ ì 1-2 ì„ ë¶„ê³¼ ì 3-4 ì„ ë¶„ì„ ëª¨ë‘ í†µê³¼í•˜ëŠ”ì§€ í™•ì¸"""
    if len(g1_pts) != 2 or len(fall_pts) != 4:
        return False
    
    # FALLì˜ ì 1-2 ì„ ë¶„ê³¼ êµì°¨ í™•ì¸
    crosses_12 = segments_cross(g1_pts[0], g1_pts[1], fall_pts[0], fall_pts[1])
    
    # FALLì˜ ì 3-4 ì„ ë¶„ê³¼ êµì°¨ í™•ì¸
    crosses_34 = segments_cross(g1_pts[0], g1_pts[1], fall_pts[2], fall_pts[3])
    
    return crosses_12 and crosses_34

def polylines_intersect(pl1_points, pl2_points):
    """ë‘ í´ë¦¬ë¼ì¸ì´ êµì°¨í•˜ëŠ”ì§€ í™•ì¸"""
    for i in range(len(pl1_points) - 1):
        for j in range(len(pl2_points) - 1):
            if segments_cross(pl1_points[i], pl1_points[i+1], 
                            pl2_points[j], pl2_points[j+1]):
                return True
    return False

def check_all_segments_under_21(pts):
    """ëª¨ë“  ì ê°„ ê±°ë¦¬ê°€ 2.1mm ì´í•˜ì¸ì§€ í™•ì¸"""
    for i in range(len(pts) - 1):
        if distance(pts[i], pts[i+1]) > 2.1:
            return False
    return True

def find_arrow_lines_near_points(msp, points, max_dist=0.2, max_length=1.0):
    """AD1ì˜ ì ì—ì„œ max_dist(0.2mm) ë‚´ì˜ max_length(1mm) ì´í•˜ ARROW ë ˆì´ì–´ line ì°¾ê¸°"""
    arrow_lines = []
    for line in msp.query('LINE'):
        if line.dxf.layer.upper() != 'ARROW':
            continue
        
        start = Vec2(line.dxf.start.x, line.dxf.start.y)
        end = Vec2(line.dxf.end.x, line.dxf.end.y)
        
        # ë¼ì¸ ê¸¸ì´ í™•ì¸
        line_length = distance(start, end)
        if line_length > max_length:
            continue
        
        # ê° AD1 ì ì—ì„œ lineê¹Œì§€ì˜ ìµœì†Œ ê±°ë¦¬ í™•ì¸
        for pt in points:
            dist_to_start = distance(pt, start)
            dist_to_end = distance(pt, end)
            min_dist_to_line = min(dist_to_start, dist_to_end)
            
            if min_dist_to_line <= max_dist:
                arrow_lines.append(line)
                break
    
    return arrow_lines

def find_ad1_near_g1_start(g1_pts, ad1_groups, max_dist=0.5):
    """G1ì˜ ì‹œì‘ì ì—ì„œ AD1 í´ë¦¬ë¼ì¸ì´ max_dist(0.5mm) ë‚´ì— ìˆëŠ” AD1 ì°¾ê¸°"""
    if not g1_pts:
        return []
    
    g1_start = g1_pts[0]  # G1ì˜ ì‹œì‘ì 
    found_ad1_groups = []
    
    for ad1_group in ad1_groups:
        ad1_pts = extract_points(ad1_group['polyline'])
        
        # AD1ì˜ ëª¨ë“  ì  ì¤‘ í•˜ë‚˜ë¼ë„ G1 ì‹œì‘ì ì—ì„œ 0.5mm ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
        for i, pt in enumerate(ad1_pts):
            dist = distance(g1_start, pt)
            if dist <= max_dist:
                found_ad1_groups.append(ad1_group)
                print(f"    [G1-AD1 ì—°ê²°] G1 ì‹œì‘ì ê³¼ AD1 {i+1}ë²ˆì  ê±°ë¦¬: {dist:.3f}mm")
                break  # í•˜ë‚˜ë¼ë„ ì°¾ìœ¼ë©´ ì¶”ê°€í•˜ê³  ë‹¤ìŒ AD1ë¡œ
    
    return found_ad1_groups

def is_text_upside_down(text_rotation):
    """í…ìŠ¤íŠ¸ê°€ ë’¤ì§‘í˜€ ìˆëŠ”ì§€ í™•ì¸ (90ë„ < íšŒì „ < 270ë„)"""
    # íšŒì „ ê°ë„ë¥¼ 0-360 ë²”ìœ„ë¡œ ì •ê·œí™”
    normalized_rotation = text_rotation % 360
    return 90 < normalized_rotation < 270

def get_text_bounds(text):
    """í…ìŠ¤íŠ¸ì˜ ëŒ€ëµì ì¸ ê²½ê³„ ìƒìë¥¼ ë°˜í™˜"""
    # ezdxfì˜ TEXT ì—”í‹°í‹° ì†ì„± ì ‘ê·¼ ë°©ì‹
    try:
        # ë°©ë²• 1: dxf ì†ì„± ì‚¬ìš©
        insert = text.dxf.insert
        text_str = text.dxf.text
        height = text.dxf.height
        rotation = text.dxf.rotation
    except AttributeError:
        try:
            # ë°©ë²• 2: get_dxf_attrib ë©”ì„œë“œ ì‚¬ìš©
            insert = text.get_dxf_attrib('insert', default=(0, 0, 0))
            text_str = text.get_dxf_attrib('text', default='')
            height = text.get_dxf_attrib('height', default=1.0)
            rotation = text.get_dxf_attrib('rotation', default=0.0)
        except:
            # ë°©ë²• 3: ì§ì ‘ ì†ì„± ì ‘ê·¼
            insert = getattr(text, 'insert', (0, 0, 0))
            text_str = getattr(text, 'text', '')
            height = getattr(text, 'height', 1.0)
            rotation = getattr(text, 'rotation', 0.0)
    
    pos = Vec2(insert[0], insert[1])
    
    # í…ìŠ¤íŠ¸ í¬ê¸° ì¶”ì • (í°íŠ¸ í¬ê¸°ì™€ í…ìŠ¤íŠ¸ ê¸¸ì´ ê¸°ë°˜)
    text_length = len(text_str) * height * 0.7
    text_height = height * 1.2
    
    # íšŒì „ ê³ ë ¤
    angle_rad = math.radians(rotation)
    cos_a, sin_a = math.cos(angle_rad), math.sin(angle_rad)
    
    # ë„¤ ëª¨ì„œë¦¬ ì  ê³„ì‚°
    corners = [
        pos,
        pos + Vec2(text_length * cos_a, text_length * sin_a),
        pos + Vec2(text_length * cos_a - text_height * sin_a, 
                   text_length * sin_a + text_height * cos_a),
        pos + Vec2(-text_height * sin_a, text_height * cos_a)
    ]
    
    return corners

def point_to_line_distance(point, line_start, line_end):
    """ì ì—ì„œ ì„ ë¶„ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°"""
    line_vec = line_end - line_start
    point_vec = point - line_start
    line_len = distance(line_start, line_end)
    
    if line_len < 0.001:  # ì„ ë¶„ì´ ì ì¸ ê²½ìš°
        return distance(point, line_start)
    
    t = max(0, min(1, (point_vec.x * line_vec.x + point_vec.y * line_vec.y) / (line_len * line_len)))
    projection = line_start + line_vec * t
    
    return distance(point, projection)

def text_intersects_polyline(text, polyline_points):
    """í…ìŠ¤íŠ¸ê°€ í´ë¦¬ë¼ì¸ê³¼ êµì°¨í•˜ëŠ”ì§€ í™•ì¸"""
    text_corners = get_text_bounds(text)
    
    # í…ìŠ¤íŠ¸ ê²½ê³„ì˜ ê° ì„ ë¶„ê³¼ í´ë¦¬ë¼ì¸ì˜ ê° ì„ ë¶„ì´ êµì°¨í•˜ëŠ”ì§€ í™•ì¸
    for i in range(len(text_corners)):
        j = (i + 1) % len(text_corners)
        for k in range(len(polyline_points) - 1):
            if segments_cross(text_corners[i], text_corners[j], 
                            polyline_points[k], polyline_points[k+1]):
                return True
    
    # í…ìŠ¤íŠ¸ì˜ ê° ëª¨ì„œë¦¬ê°€ í´ë¦¬ë¼ì¸ì— ë„ˆë¬´ ê°€ê¹Œìš´ì§€ í™•ì¸ (1mm ì´ë‚´)
    for corner in text_corners:
        for k in range(len(polyline_points) - 1):
            if point_to_line_distance(corner, polyline_points[k], polyline_points[k+1]) < 1.0:
                return True
    
    return False

def texts_overlap(text1, text2):
    """ë‘ í…ìŠ¤íŠ¸ê°€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸"""
    if text1 == text2:
        return False
    
    corners1 = get_text_bounds(text1)
    corners2 = get_text_bounds(text2)
    
    # ë‘ í…ìŠ¤íŠ¸ ê²½ê³„ê°€ êµì°¨í•˜ëŠ”ì§€ í™•ì¸
    for i in range(len(corners1)):
        j = (i + 1) % len(corners1)
        for k in range(len(corners2)):
            l = (k + 1) % len(corners2)
            if segments_cross(corners1[i], corners1[j], corners2[k], corners2[l]):
                return True
    
    # í•œ í…ìŠ¤íŠ¸ì˜ ì¤‘ì‹¬ì´ ë‹¤ë¥¸ í…ìŠ¤íŠ¸ ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
    try:
        insert1 = text1.dxf.insert
        insert2 = text2.dxf.insert
        height1 = text1.dxf.height
        height2 = text2.dxf.height
    except AttributeError:
        try:
            insert1 = text1.get_dxf_attrib('insert', default=(0, 0, 0))
            insert2 = text2.get_dxf_attrib('insert', default=(0, 0, 0))
            height1 = text1.get_dxf_attrib('height', default=1.0)
            height2 = text2.get_dxf_attrib('height', default=1.0)
        except:
            insert1 = getattr(text1, 'insert', (0, 0, 0))
            insert2 = getattr(text2, 'insert', (0, 0, 0))
            height1 = getattr(text1, 'height', 1.0)
            height2 = getattr(text2, 'height', 1.0)
    
    center1 = Vec2(insert1[0], insert1[1])
    center2 = Vec2(insert2[0], insert2[1])
    
    # ì¤‘ì‹¬ ê°„ ê±°ë¦¬ê°€ ë„ˆë¬´ ê°€ê¹Œìš´ ê²½ìš°
    if distance(center1, center2) < (height1 + height2) * 0.5:
        return True
    
    return False

def count_interferences(text, msp, pipe_entities, other_texts):
    """í…ìŠ¤íŠ¸ì˜ ê°„ì„­ ìˆ˜ë¥¼ ê³„ì‚° (PIPE ì œì™¸)"""
    interference_count = 0
    
    # ëª¨ë“  í´ë¦¬ë¼ì¸ê³¼ì˜ ê°„ì„­ í™•ì¸ (PIPE ì œì™¸)
    for entity in msp.query('LWPOLYLINE POLYLINE'):
        if entity in pipe_entities:
            continue
        
        pts = extract_points(entity)
        if pts and text_intersects_polyline(text, pts):
            interference_count += 1
    
    # ë¼ì¸ê³¼ì˜ ê°„ì„­ í™•ì¸ (PIPE ì œì™¸)
    for line in msp.query('LINE'):
        if line.dxf.layer.upper() == 'PIPE':
            continue
        
        line_pts = [
            Vec2(line.dxf.start.x, line.dxf.start.y),
            Vec2(line.dxf.end.x, line.dxf.end.y)
        ]
        if text_intersects_polyline(text, line_pts):
            interference_count += 1
    
    # ë‹¤ë¥¸ í…ìŠ¤íŠ¸ì™€ì˜ ê°„ì„­ í™•ì¸
    for other_text in other_texts:
        if texts_overlap(text, other_text):
            interference_count += 100  # í…ìŠ¤íŠ¸ ê°„ì„­ì€ ë§¤ìš° ë†’ì€ ê°€ì¤‘ì¹˜
    
    return interference_count

def find_optimal_text_position(text, pipe_angle, msp, pipe_entities, other_texts, max_offset=10):
    """í…ìŠ¤íŠ¸ì˜ ìµœì  ìœ„ì¹˜ ì°¾ê¸° (1mm ë‹¨ìœ„ë¡œ ì´ë™í•˜ë©° ê°„ì„­ ìµœì†Œí™”)"""
    insert = text.dxf.insert
    original_pos = Vec2(insert[0], insert[1])
    min_interference = count_interferences(text, msp, pipe_entities, other_texts)
    best_offset = 0
    
    print(f"    [ê°„ì„­ ì²´í¬] ì‹œì‘ ìœ„ì¹˜ ê°„ì„­ ìˆ˜: {min_interference}")
    
    # ê°„ì„­ì´ ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ ìœ ì§€
    if min_interference == 0:
        print(f"    [ê°„ì„­ ì²´í¬] ê°„ì„­ ì—†ìŒ, ìœ„ì¹˜ ìœ ì§€")
        return
    
    # -10mm ~ +10mm ë²”ìœ„ì—ì„œ 1mmì”© ì´ë™í•˜ë©° í…ŒìŠ¤íŠ¸
    for offset_mm in range(-max_offset, max_offset + 1):
        if offset_mm == 0:
            continue
        
        # ì„ì‹œë¡œ í…ìŠ¤íŠ¸ ì´ë™
        offset_vec = get_offset_by_angle(pipe_angle, offset_mm)
        text.dxf.insert = (original_pos.x + offset_vec.x, 
                          original_pos.y + offset_vec.y, 0)
        
        # ê°„ì„­ ìˆ˜ ê³„ì‚°
        interference = count_interferences(text, msp, pipe_entities, other_texts)
        
        # ë” ì ì€ ê°„ì„­ì„ ì°¾ì€ ê²½ìš°
        if interference < min_interference:
            min_interference = interference
            best_offset = offset_mm
            print(f"    [ê°„ì„­ ì²´í¬] {offset_mm}mm ìœ„ì¹˜: ê°„ì„­ {interference}ê°œ")
            
            # ê°„ì„­ì´ 0ì´ë©´ ì¦‰ì‹œ ì¤‘ë‹¨
            if interference == 0:
                print(f"    [ê°„ì„­ ì²´í¬] ê°„ì„­ ì—†ëŠ” ìœ„ì¹˜ ë°œê²¬!")
                break
    
    # ìµœì  ìœ„ì¹˜ë¡œ ì´ë™
    if best_offset != 0:
        offset_vec = get_offset_by_angle(pipe_angle, best_offset)
        text.dxf.insert = (original_pos.x + offset_vec.x, 
                          original_pos.y + offset_vec.y, 0)
        print(f"    [ê°„ì„­ ì²´í¬] ìµœì¢… ì´ë™: {best_offset}mm (ê°„ì„­ {min_interference}ê°œ)")
    else:
        # ì›ë˜ ìœ„ì¹˜ë¡œ ë³µì›
        text.dxf.insert = (original_pos.x, original_pos.y, 0)
        print(f"    [ê°„ì„­ ì²´í¬] ì›ë˜ ìœ„ì¹˜ ìœ ì§€ (ê°„ì„­ {min_interference}ê°œ)")

def process_file(filepath):
    doc = ezdxf.readfile(filepath)
    msp = doc.modelspace()
    
    # ì‚­ì œí•  ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸
    entities_to_delete = []
    
    # ëª¨ë“  í…ìŠ¤íŠ¸ ìˆ˜ì§‘ (ê°„ì„­ ì²´í¬ìš©)
    all_texts = list(msp.query('TEXT'))
    
    # PIPE ì—”í‹°í‹° ìˆ˜ì§‘
    pipe_entities = []
    for entity in msp.query('LWPOLYLINE POLYLINE LINE'):
        if entity.dxf.layer.upper() == 'PIPE':
            pipe_entities.append(entity)

    # 1. FALL ë ˆì´ì–´ì˜ 4ì  í´ë¦¬ë¼ì¸ ì°¾ê¸°
    fall_polylines = []
    for pl in msp.query('LWPOLYLINE POLYLINE'):
        if pl.dxf.layer.upper() == 'FALL':
            pts = extract_points(pl)
            if len(pts) == 4:
                fall_polylines.append(pl)
                print(f"[FALL ë ˆì´ì–´] 4ì  í´ë¦¬ë¼ì¸ ë°œê²¬: {pl.dxf.handle}")

    # ê° FALL í´ë¦¬ë¼ì¸ ì²˜ë¦¬
    for fall_pl in fall_polylines:
        fall_pts = extract_points(fall_pl)
        
        # FALL í´ë¦¬ë¼ì¸ì˜ ì  1ë²ˆê³¼ 2ë²ˆì˜ ì¤‘ì‹¬ì  ê³„ì‚°
        fall_p1_p2_center = Vec2(
            (fall_pts[0].x + fall_pts[1].x) / 2,
            (fall_pts[0].y + fall_pts[1].y) / 2
        )
        
        # FALL ì¤‘ì‹¬ ê³„ì‚°
        fall_center = Vec2(
            sum(p.x for p in fall_pts) / 4,
            sum(p.y for p in fall_pts) / 4
        )
        
        # 2. FALL ì„ ë¶„ì— ì ‘í•˜ëŠ” 2ì , 3ì  í´ë¦¬ë¼ì¸ ì°¾ê¸° ë° ë¶„ë¥˜
        g1_list = []  # 2ì  í´ë¦¬ë¼ì¸ + ì ê°„ê±°ë¦¬ 2.1 ì´ˆê³¼ 3ì  í´ë¦¬ë¼ì¸
        ad1_list = []  # ì ê°„ê±°ë¦¬ 2.1 ì´í•˜ 3ì  í´ë¦¬ë¼ì¸
        ad1_groups = []  # AD1ê³¼ ì—°ê´€ëœ ARROW lineë“¤ì˜ ê·¸ë£¹
        
        for pl in msp.query('LWPOLYLINE POLYLINE'):
            if pl is fall_pl:  # FALL ìì‹ ì€ ì œì™¸
                continue
                
            pts = extract_points(pl)
            
            if not polyline_intersects_with_fall(pts, fall_pts):
                continue
            
            # 2ì  í´ë¦¬ë¼ì¸ â†’ G1
            if len(pts) == 2:
                pl.dxf.layer = "G1"
                pl.dxf.color = 4  # CYAN
                g1_list.append(pl)
                print(f"  [G1] 2ì  í´ë¦¬ë¼ì¸ ë°œê²¬: {pl.dxf.handle}")
            
            # 3ì  í´ë¦¬ë¼ì¸ â†’ ì ê°„ ê±°ë¦¬ì— ë”°ë¼ ë¶„ë¥˜
            elif len(pts) == 3:
                if check_all_segments_under_21(pts):
                    # ëª¨ë“  ì ê°„ ê±°ë¦¬ 2.1 ì´í•˜ â†’ AD1
                    pl.dxf.layer = "AD1"
                    pl.dxf.color = 3  # GREEN
                    ad1_list.append(pl)
                    
                    # ARROW ë ˆì´ì–´ line ì°¾ê¸° (0.2mm ë‚´, 1mm ì´í•˜)
                    arrow_lines = find_arrow_lines_near_points(msp, pts)
                    for arrow in arrow_lines:
                        arrow.dxf.color = 3  # GREEN
                    
                    ad1_groups.append({
                        'polyline': pl,
                        'arrows': arrow_lines
                    })
                    
                    print(f"  [AD1] 3ì  í´ë¦¬ë¼ì¸ ë°œê²¬ (ì ê°„ê±°ë¦¬â‰¤2.1): {pl.dxf.handle}")
                    if arrow_lines:
                        print(f"    - ì—°ê´€ëœ ARROW line {len(arrow_lines)}ê°œ ë°œê²¬")
                else:
                    # ì ê°„ ê±°ë¦¬ 2.1 ì´ˆê³¼ â†’ G1
                    pl.dxf.layer = "G1"
                    pl.dxf.color = 4  # CYAN
                    g1_list.append(pl)
                    print(f"  [G1] 3ì  í´ë¦¬ë¼ì¸ ë°œê²¬ (ì ê°„ê±°ë¦¬>2.1): {pl.dxf.handle}")
        
        # ì‚­ì œ ì œì™¸í•  G1ê³¼ AD1 ì°¾ê¸°
        exclude_from_deletion = set()
        
        for g1 in g1_list:
            g1_pts = extract_points(g1)
            if len(g1_pts) == 2 and g1_crosses_both_fall_segments(g1_pts, fall_pts):
                exclude_from_deletion.add(g1)
                print(f"  [ì‚­ì œ ì œì™¸] G1 {g1.dxf.handle} - FALLì˜ ì–‘ìª½ ì„ ë¶„ í†µê³¼")
                
                # ì´ G1ê³¼ ì ‘ì´‰í•˜ëŠ” AD1ë„ ì œì™¸
                for ad1_group in ad1_groups:
                    ad1_pts = extract_points(ad1_group['polyline'])
                    if polylines_intersect(g1_pts, ad1_pts):
                        exclude_from_deletion.add(ad1_group['polyline'])
                        print(f"    [ì‚­ì œ ì œì™¸] AD1 {ad1_group['polyline'].dxf.handle} - ì œì™¸ëœ G1ê³¼ ì ‘ì´‰")
        
        # 3. G1ê³¼ AD1ì—ì„œ FALL TEXT ì°¾ê¸°
        fall_text = None
        fall_o_text = None
        found_entities = []  # FALL TEXTë¥¼ ì°¾ì€ ëª¨ë“  ì—”í‹°í‹°ë“¤
        found_ad1_groups = []  # FALL TEXTë¥¼ ì°¾ì€ AD1 ê·¸ë£¹ë“¤
        
        # G1 ë¦¬ìŠ¤íŠ¸ì—ì„œ ì°¾ê¸°
        for g1 in g1_list:
            g1_pts = extract_points(g1)
            
            # G1ì˜ FALLë¡œë¶€í„° ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
            max_dist = 0
            far_point = None
            for pt in g1_pts:
                d = distance(pt, fall_center)
                if d > max_dist:
                    max_dist = d
                    far_point = pt
            
            if not far_point:
                continue
            
            # ë¨¼ ì  ê·¼ì²˜ì—ì„œ FALL TEXT ì°¾ê¸°
            for t in msp.query('TEXT'):
                if 'FALL' in t.dxf.text.upper() and abs(t.dxf.rotation) < 1e-2:
                    insert = t.dxf.insert
                    t_pos = Vec2(insert[0], insert[1])
                    
                    if distance(t_pos, far_point) <= 20:
                        if not fall_text:  # ì²« ë²ˆì§¸ ë°œê²¬í•œ ê²ƒë§Œ ì²˜ë¦¬ìš©ìœ¼ë¡œ ì €ì¥
                            fall_text = t
                        found_entities.append(g1)
                        print(f"  [FALL TEXT] G1ì—ì„œ ë°œê²¬: '{t.dxf.text}' at G1: {g1.dxf.handle}")
                        break
        
        # AD1ì—ì„œë„ ì°¾ê¸°
        for ad1_group in ad1_groups:
            ad1_pts = extract_points(ad1_group['polyline'])
            
            # AD1ì˜ FALLë¡œë¶€í„° ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
            max_dist = 0
            far_point = None
            for pt in ad1_pts:
                d = distance(pt, fall_center)
                if d > max_dist:
                    max_dist = d
                    far_point = pt
            
            if not far_point:
                continue
            
            # ë¨¼ ì  ê·¼ì²˜ì—ì„œ FALL TEXT ì°¾ê¸°
            for t in msp.query('TEXT'):
                if 'FALL' in t.dxf.text.upper() and abs(t.dxf.rotation) < 1e-2:
                    insert = t.dxf.insert
                    t_pos = Vec2(insert[0], insert[1])
                    
                    if distance(t_pos, far_point) <= 20:
                        if not fall_text:  # ì²« ë²ˆì§¸ ë°œê²¬í•œ ê²ƒë§Œ ì²˜ë¦¬ìš©ìœ¼ë¡œ ì €ì¥
                            fall_text = t
                        found_entities.append(ad1_group['polyline'])
                        found_ad1_groups.append(ad1_group)
                        print(f"  [FALL TEXT] AD1ì—ì„œ ë°œê²¬: '{t.dxf.text}' at AD1: {ad1_group['polyline'].dxf.handle}")
                        break
        
        # O í…ìŠ¤íŠ¸ ì°¾ê¸°
        if fall_text:
            insert = fall_text.dxf.insert
            t_pos = Vec2(insert[0], insert[1])
            min_dist = float('inf')
            for o in msp.query('TEXT'):
                if o.dxf.text.strip().upper() == 'O':
                    try:
                        o_insert = o.dxf.insert
                        o_pos = Vec2(o_insert[0], o_insert[1])
                        dist = distance(o_pos, t_pos)
                        if dist < min_dist and dist <= 20:
                            min_dist = dist
                            fall_o_text = o
                    except:
                        continue
        
        if not fall_text:
            print(f"  [ì£¼ì˜] FALL TEXTë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            continue
        
        fall_insert = fall_text.dxf.insert
        fall_pos = Vec2(fall_insert[0], fall_insert[1])
        
        # 4. FALL ë ˆì´ì–´ì— ê°€ì¥ ê°€ê¹Œìš´ PIPE ë ˆì´ì–´ ì°¾ê¸°
        found_pipe = None
        pipe_p1, pipe_p2 = None, None
        min_pipe_dist = float('inf')
        pipe_angle = 0  # PIPE ê°ë„ ì €ì¥
        
        for pl in msp.query('LWPOLYLINE POLYLINE'):
            if pl.dxf.layer.upper() != "PIPE":
                continue
            pts = extract_points(pl)
            
            if len(pts) == 2:
                for pt in pts:
                    d = distance(pt, fall_center)
                    if d < min_pipe_dist:
                        min_pipe_dist = d
                        found_pipe = pl
                        if distance(pts[0], fall_pos) <= distance(pts[1], fall_pos):
                            pipe_p1, pipe_p2 = pts[0], pts[1]
                        else:
                            pipe_p1, pipe_p2 = pts[1], pts[0]
        
        if not found_pipe:
            print(f"  [PIPE] ë ˆì´ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ FALL í´ë¦¬ë¼ì¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.")
            pipe_p1, pipe_p2 = fall_pts[0], fall_pts[1]
        else:
            print(f"  [PIPE] ë ˆì´ì–´ ë°œê²¬: {found_pipe.dxf.handle}")
        
        # PIPE ê°ë„ ê³„ì‚°
        pipe_angle = get_angle(pipe_p1, pipe_p2)
        
        # 5. FALL TEXT ì²˜ë¦¬
        if not fall_text.dxf.text.endswith("Â°"):
            fall_text.dxf.text = fall_text.dxf.text + "Â°"
        
        if fall_o_text:
            try:
                msp.delete_entity(fall_o_text)
                print(f"  [ì‚­ì œ] O í…ìŠ¤íŠ¸")
            except Exception as e:
                print(f"  O ì‚­ì œ ì˜¤ë¥˜: {e}")
        
        # íšŒì „ ê°ë„ ê³„ì‚°
        angle = get_angle(pipe_p1, pipe_p2)
        rotate_angle = 180 - abs(angle) if angle < -120 else angle
        
        # FALL í…ìŠ¤íŠ¸ íšŒì „ ë° ì´ë™
        rotate_text(fall_text, fall_pos, rotate_angle)
        current_insert = fall_text.dxf.insert
        current_pos = Vec2(current_insert[0], current_insert[1])
        move_text(fall_text, fall_p1_p2_center - current_pos)
        
        if angle < -120:
            move_text(fall_text, get_offset_by_angle(angle, 12))
            move_text(fall_text, get_perpendicular_offset(angle, 5.5))
        else:
            move_text(fall_text, get_offset_by_angle(angle, -5))
            move_text(fall_text, get_perpendicular_offset(angle, -5.5))
        
        # í…ìŠ¤íŠ¸ê°€ ë’¤ì§‘í˜€ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  180ë„ íšŒì „
        current_rotation = fall_text.dxf.rotation % 360
        if is_text_upside_down(current_rotation):
            rotate_text(fall_text, fall_p1_p2_center, 180)
            print(f"  [180ë„ íšŒì „] FALL TEXTê°€ ë’¤ì§‘í˜€ ìˆì–´ 180ë„ íšŒì „")
        
        fall_text.dxf.color = 1
        fall_text.dxf.layer = "RED"
        
        # ê°„ì„­ ì²´í¬ ë° ìµœì  ìœ„ì¹˜ ì°¾ê¸°
        print(f"  [ê°„ì„­ ìµœì í™”] FALL TEXT ìœ„ì¹˜ ìµœì í™” ì‹œì‘...")
        find_optimal_text_position(fall_text, pipe_angle, msp, pipe_entities, all_texts)
        
        # 6. FALL TEXTë¥¼ ì°¾ëŠ”ë° ì„±ê³µí•œ ëª¨ë“  G1ê³¼ AD1 ì‚­ì œ (ì œì™¸ ëŒ€ìƒ ì œì™¸)
        for entity in found_entities:
            if entity not in exclude_from_deletion:
                entities_to_delete.append(entity)
                print(f"  [ì‚­ì œ ì˜ˆì •] {entity.dxf.layer}: {entity.dxf.handle} (FALL TEXT ì°¾ìŒ)")
                
                # G1ì¸ ê²½ìš°, ì‹œì‘ì  0.5mm ë‚´ì˜ AD1 ì°¾ê¸°
                if entity.dxf.layer == "G1":
                    g1_pts = extract_points(entity)
                    if g1_pts:
                        # G1 ì‹œì‘ì ì—ì„œ 0.5mm ë‚´ì˜ AD1 ì°¾ê¸°
                        near_ad1_groups = find_ad1_near_g1_start(g1_pts, ad1_groups, max_dist=0.5)
                        for ad1_group in near_ad1_groups:
                            if ad1_group['polyline'] not in exclude_from_deletion:
                                # AD1 ì‚­ì œ ì˜ˆì •ì— ì¶”ê°€
                                if ad1_group['polyline'] not in entities_to_delete:
                                    entities_to_delete.append(ad1_group['polyline'])
                                    print(f"    [G1 ì—°ê´€ ì‚­ì œ ì˜ˆì •] AD1: {ad1_group['polyline'].dxf.handle} (G1 ì‹œì‘ì  0.5mm ë‚´)")
                                
                                # AD1ì˜ ARROW lineë“¤ë„ ì‚­ì œ ì˜ˆì •ì— ì¶”ê°€
                                for arrow in ad1_group['arrows']:
                                    if arrow not in entities_to_delete:
                                        entities_to_delete.append(arrow)
                                        print(f"    [G1 ì—°ê´€ ì‚­ì œ ì˜ˆì •] ARROW line: {arrow.dxf.handle}")
        
        # AD1ê°€ ì§ì ‘ FALL TEXTë¥¼ ì°¾ì€ ê²½ìš°ì˜ ARROW lineë“¤ë„ ì‚­ì œ
        for ad1_group in found_ad1_groups:
            if ad1_group['polyline'] not in exclude_from_deletion:
                for arrow in ad1_group['arrows']:
                    if arrow not in entities_to_delete:
                        entities_to_delete.append(arrow)
                        print(f"  [ì‚­ì œ ì˜ˆì •] ARROW line: {arrow.dxf.handle} (AD1ì´ FALL TEXT ì°¾ìŒ)")
    
    # ì‚­ì œ ì‹¤í–‰
    for entity in entities_to_delete:
        try:
            msp.delete_entity(entity)
            layer = entity.dxf.layer if hasattr(entity.dxf, 'layer') else 'UNKNOWN'
            print(f"[ì‚­ì œ ì™„ë£Œ] {layer}: {entity.dxf.handle}")
        except Exception as e:
            print(f"ì‚­ì œ ì˜¤ë¥˜: {e}")

    save_path = os.path.splitext(filepath)[0] + "_FALL.dxf"
    doc.saveas(save_path)
    print(f"âœ… ì²˜ë¦¬ ì™„ë£Œ: {os.path.basename(save_path)}")

if __name__ == "__main__":
    files = select_dxf_files()
    if not files:
        print("âŒ ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
    else:
        for file in files:
            process_file(file)
        print("ğŸ‰ ëª¨ë“  íŒŒì¼ ì²˜ë¦¬ ì™„ë£Œ.")