import ezdxf
from pathlib import Path
import tkinter as tk
from tkinter import filedialog
from typing import List, Tuple, Optional
import math
from dataclasses import dataclass

@dataclass
class LineInfo:
    entity_type: str
    layer: str
    points: List[Tuple[float, float]]
    width: Optional[float]
    source: str

class DxfModifier:
    def __init__(self, input_file: str):
        self.input_file = Path(input_file)

    def _direct_parse_dxf(self) -> List[LineInfo]:
        lines: List[LineInfo] = []
        try:
            with open(self.input_file, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.readlines()
            i = 0
            while i < len(content):
                line = content[i].strip()
                
                # LWPOLYLINE ì²˜ë¦¬ ì¶”ê°€
                if line == "LWPOLYLINE":
                    layer = "0"
                    const_width = None
                    points = []
                    i += 1
                    
                    # LWPOLYLINE í—¤ë” ì •ë³´ íŒŒì‹±
                    while i < len(content):
                        code = content[i].strip()
                        if code == "10":  # ì²« ë²ˆì§¸ X ì¢Œí‘œë¥¼ ë§Œë‚˜ë©´ ì¢Œí‘œ ìˆ˜ì§‘ ì‹œì‘
                            break
                        if code == "8":  # Layer
                            i += 1
                            if i < len(content):
                                layer = content[i].strip()
                        elif code == "43":  # Constant width
                            i += 1
                            if i < len(content):
                                const_width = float(content[i].strip())
                        i += 1
                    
                    # ì¢Œí‘œ ìˆ˜ì§‘
                    while i < len(content):
                        code = content[i].strip()
                        if code == "10":  # X coordinate
                            x = None
                            y = None
                            i += 1
                            if i < len(content):
                                x = float(content[i].strip())
                            i += 1
                            # ë‹¤ìŒì€ 20 (Y coordinate)ì´ì–´ì•¼ í•¨
                            if i < len(content) and content[i].strip() == "20":
                                i += 1
                                if i < len(content):
                                    y = float(content[i].strip())
                                if x is not None and y is not None:
                                    points.append((x, y))
                        elif code == "0":  # ë‹¤ìŒ ì—”í‹°í‹° ì‹œì‘
                            break
                        else:
                            i += 1
                    
                    # widthê°€ 0.6ì¸ ê²½ìš°ë§Œ ì €ì¥
                    if const_width and const_width == 0.6 and len(points) >= 2:
                        lines.append(LineInfo(
                            entity_type="LWPOLYLINE",
                            layer=layer,
                            points=points,
                            width=const_width,
                            source="direct_parsing"
                        ))
                    i += 1
                    
                elif line == "POLYLINE":
                    layer = "0"
                    start_width: Optional[float] = None
                    end_width: Optional[float] = None
                    i += 1
                    # í—¤ë” íŒŒì‹±
                    while i < len(content):
                        code = content[i].strip()
                        if code == "VERTEX":
                            break
                        if code == "8":
                            i += 1
                            if i < len(content):
                                layer = content[i].strip()
                        elif code == "40":
                            i += 1
                            if i < len(content):
                                try:
                                    start_width = float(content[i].strip())
                                except ValueError:
                                    start_width = None
                        elif code == "41":
                            i += 1
                            if i < len(content):
                                try:
                                    end_width = float(content[i].strip())
                                except ValueError:
                                    end_width = None
                        i += 1
                    # ê¼­ì§€ì  íŒŒì‹±
                    points: List[Tuple[float,float]] = []
                    while i < len(content):
                        token = content[i].strip()
                        if token == "VERTEX":
                            x = None; y = None
                            i += 1
                            while i < len(content) and content[i].strip() not in ["VERTEX", "SEQEND"]:
                                code = content[i].strip()
                                if code == "10":
                                    i += 1
                                    if i < len(content):
                                        try:
                                            x = float(content[i].strip())
                                        except ValueError:
                                            x = None
                                elif code == "20":
                                    i += 1
                                    if i < len(content):
                                        try:
                                            y = float(content[i].strip())
                                        except ValueError:
                                            y = None
                                i += 1
                            if x is not None and y is not None:
                                points.append((x,y))
                        elif token == "SEQEND":
                            break
                        else:
                            i += 1
                    width = start_width if start_width and start_width > 0 else end_width
                    # widthê°€ 0.6ì¸ ê²½ìš°ë§Œ ì €ì¥
                    if width and width == 0.6 and len(points) >= 2:
                        lines.append(LineInfo(
                            entity_type="POLYLINE",
                            layer=layer,
                            points=points,
                            width=width,
                            source="direct_parsing"
                        ))
                    i += 1
                else:
                    i += 1
        except Exception as e:
            print(f"ì§ì ‘ íŒŒì‹± ì¤‘ ì˜¤ë¥˜: {e}")
        return lines

    def find_and_modify_green_lines(self, doc):
        direct_lines = self._direct_parse_dxf()
        c_lines_key = set()
        msp = doc.modelspace()
        modified_count = 0
        
        # widthê°€ 0.6ì¸ ë¼ì¸ë“¤ë§Œ í•„í„°ë§
        width_06_lines = [line for line in direct_lines if line.width and line.width == 0.6]
        
        for entity in msp:
            entity_type = entity.dxftype()
            # POLYLINEê³¼ LWPOLYLINE ëª¨ë‘ ì²˜ë¦¬
            if entity_type in ["POLYLINE", "LWPOLYLINE"]:
                if entity_type == "POLYLINE":
                    pts = [(v.dxf.location.x, v.dxf.location.y) for v in entity.vertices]
                elif entity_type == "LWPOLYLINE":
                    pts = [(pt[0], pt[1]) for pt in entity.get_points('xy')]
                else:
                    continue
                    
                key = tuple((round(x,6), round(y,6)) for x,y in pts)
                
                for dl in width_06_lines:
                    # ë™ì¼í•œ ì—”í‹°í‹° íƒ€ì…ì¸ì§€ë„ í™•ì¸
                    if (dl.entity_type == entity_type and
                        len(dl.points) == len(pts) and 
                        self._points_match(pts, dl.points)):
                        try:
                            entity.dxf.color = 3  # Green
                            entity.dxf.lineweight = 50
                            c_lines_key.add(key)
                            modified_count += 1
                            break
                        except Exception as e:
                            print(f"ì—”í‹°í‹° ìˆ˜ì • ì‹¤íŒ¨ ({entity_type}): {e}")
        
        print(f"width = 0.6ì¸ ë¼ì¸ìœ¼ë¡œ ìˆ˜ì •ëœ ê°œìˆ˜: {modified_count}ê°œ")
        return c_lines_key, direct_lines

    def _points_match(self, p1: List[Tuple[float,float]], p2: List[Tuple[float,float]], tol=1e-3) -> bool:
        if len(p1) != len(p2): return False
        for a,b in zip(p1,p2):
            if abs(a[0]-b[0])>tol or abs(a[1]-b[1])>tol:
                return False
        return True

def has_bulge(ent):
    if ent.dxftype() == 'LWPOLYLINE':
        for x, y, bulge in ent.get_points('xyb'):
            if abs(bulge) > 1e-7:
                return True
        return False
    elif ent.dxftype() == 'POLYLINE':
        for v in ent.vertices:
            if hasattr(v.dxf, 'bulge') and abs(v.dxf.bulge) > 1e-7:
                return True
        return False
    return False

def get_bulge_radius(ent):
    pts = polypoints(ent)
    n = len(pts)
    if n < 2:
        return None

    if ent.dxftype() == 'LWPOLYLINE':
        points = list(ent.get_points('xyb'))
        for idx, (x, y, bulge) in enumerate(points[:-1]):
            if abs(bulge) > 1e-7:
                chord = distance(pts[idx], pts[idx+1])
                theta = 4 * math.atan(abs(bulge))
                if theta == 0:
                    continue
                return abs(chord / (2 * math.sin(theta/2)))
    else:
        verts = list(ent.vertices)
        for idx, v in enumerate(verts[:-1]):
            if hasattr(v.dxf, 'bulge') and abs(v.dxf.bulge) > 1e-7:
                chord = distance(pts[idx], pts[idx+1])
                theta = 4 * math.atan(abs(v.dxf.bulge))
                if theta == 0:
                    continue
                return abs(chord / (2 * math.sin(theta/2)))
    return None

def get_arc_center_from_bulge(p1, p2, bulge):
    """ë‘ ì ê³¼ bulge ê°’ìœ¼ë¡œë¶€í„° í˜¸ì˜ ì¤‘ì‹¬ì ì„ ê³„ì‚°"""
    if abs(bulge) < 1e-7:
        return None
    
    # í˜„ì˜ ì¤‘ì 
    mid_x = (p1[0] + p2[0]) / 2
    mid_y = (p1[1] + p2[1]) / 2
    
    # í˜„ì˜ ê¸¸ì´ì™€ ë°©í–¥
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    chord_length = math.sqrt(dx*dx + dy*dy)
    
    if chord_length < 1e-7:
        return None
    
    # bulgeë¡œë¶€í„° ì¤‘ì‹¬ê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
    # bulge = tan(theta/4), ì—¬ê¸°ì„œ thetaëŠ” í˜¸ì˜ ì¤‘ì‹¬ê°
    theta = 4 * math.atan(abs(bulge))
    radius = chord_length / (2 * math.sin(theta/2))
    
    # sagitta (í˜¸ì˜ ë†’ì´) ê³„ì‚°
    sagitta = radius * (1 - math.cos(theta/2))
    if bulge < 0:
        sagitta = -sagitta
    
    # í˜„ì— ìˆ˜ì§ì¸ ë°©í–¥ ë²¡í„° (ì™¼ìª½ìœ¼ë¡œ 90ë„ íšŒì „)
    perp_x = -dy / chord_length
    perp_y = dx / chord_length
    
    # í˜¸ì˜ ë†’ì´ë¥¼ ê³ ë ¤í•œ ì˜¤í”„ì…‹
    h = radius - sagitta
    
    # ì¤‘ì‹¬ì  ê³„ì‚°
    center_x = mid_x + h * perp_x
    center_y = mid_y + h * perp_y
    
    return (center_x, center_y)

def get_polyline_arc_center_and_radius_with_bulge(ent):
    """bulgeê°€ ìˆëŠ” í´ë¦¬ë¼ì¸ì˜ ì¤‘ì‹¬ì ê³¼ ë°˜ì§€ë¦„ ê³„ì‚°"""
    pts = polypoints(ent)
    
    if ent.dxftype() == 'LWPOLYLINE':
        points = list(ent.get_points('xyb'))
        print(f"  LWPOLYLINE bulge ì •ë³´:")
        for idx, (x, y, bulge) in enumerate(points):
            print(f"    ì {idx+1}: ({x:.3f}, {y:.3f}), bulge={bulge:.6f}")
        
        # ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ í™•ì¸ (ë‹«íŒ í´ë¦¬ë¼ì¸ í¬í•¨)
        for idx in range(len(points)):
            x1, y1, bulge = points[idx]
            # ë‹¤ìŒ ì  (ë§ˆì§€ë§‰ ì ì˜ ê²½ìš° ì²« ë²ˆì§¸ ì ìœ¼ë¡œ)
            next_idx = (idx + 1) % len(points)
            x2, y2, _ = points[next_idx]
            
            if abs(bulge) > 1e-7:
                print(f"  bulge ë°œê²¬: ì {idx+1}â†’ì {next_idx+1}, bulge={bulge:.6f}")
                center = get_arc_center_from_bulge((x1, y1), (x2, y2), bulge)
                if center:
                    radius = distance(center, (x1, y1))
                    print(f"  ê³„ì‚°ëœ ì¤‘ì‹¬: ({center[0]:.3f}, {center[1]:.3f}), ë°˜ì§€ë¦„: {radius:.3f}")
                    return center, radius
    else:  # POLYLINE
        verts = list(ent.vertices)
        print(f"  POLYLINE bulge ì •ë³´:")
        for idx, v in enumerate(verts):
            bulge = v.dxf.bulge if hasattr(v.dxf, 'bulge') else 0
            print(f"    ì {idx+1}: ({v.dxf.location.x:.3f}, {v.dxf.location.y:.3f}), bulge={bulge:.6f}")
        
        # ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ í™•ì¸ (ë‹«íŒ í´ë¦¬ë¼ì¸ í¬í•¨)
        for idx in range(len(verts)):
            v1 = verts[idx]
            # ë‹¤ìŒ ì  (ë§ˆì§€ë§‰ ì ì˜ ê²½ìš° ì²« ë²ˆì§¸ ì ìœ¼ë¡œ)
            next_idx = (idx + 1) % len(verts)
            v2 = verts[next_idx]
            
            if hasattr(v1.dxf, 'bulge') and abs(v1.dxf.bulge) > 1e-7:
                p1 = (v1.dxf.location.x, v1.dxf.location.y)
                p2 = (v2.dxf.location.x, v2.dxf.location.y)
                print(f"  bulge ë°œê²¬: ì {idx+1}â†’ì {next_idx+1}, bulge={v1.dxf.bulge:.6f}")
                center = get_arc_center_from_bulge(p1, p2, v1.dxf.bulge)
                if center:
                    radius = distance(center, p1)
                    print(f"  ê³„ì‚°ëœ ì¤‘ì‹¬: ({center[0]:.3f}, {center[1]:.3f}), ë°˜ì§€ë¦„: {radius:.3f}")
                    return center, radius
    
    print(f"  âš ï¸ bulgeê°€ ìˆëŠ” ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    return None, None

def circle_exists_at_position(msp, center, radius, tolerance=0.1):
    """íŠ¹ì • ìœ„ì¹˜ì— ë™ì¼í•œ ë°˜ì§€ë¦„ì˜ ì›ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    for circle in msp.query('CIRCLE'):
        existing_center = (circle.dxf.center.x, circle.dxf.center.y)
        existing_radius = circle.dxf.radius
        
        # ì¤‘ì‹¬ì ê³¼ ë°˜ì§€ë¦„ì´ ëª¨ë‘ í—ˆìš© ì˜¤ì°¨ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
        center_distance = distance(existing_center, center)
        if (center_distance < tolerance and 
            abs(existing_radius - radius) < tolerance):
            return True
    return False

def centroid(pts):
    return (sum(p[0] for p in pts)/len(pts), sum(p[1] for p in pts)/len(pts))

def scale_triangle(pts, center, scale):
    return [(center[0]+(x-center[0])*scale, center[1]+(y-center[1])*scale) for x,y in pts]

def distance(p1, p2):
    return math.dist(p1, p2)
          
def draw_line(msp, p1, p2, color=7, layer=None):
    attrib = {"color": color}
    if layer:
        attrib["layer"] = layer
    msp.add_line(p1, p2, dxfattribs=attrib)
    
def scale_triangle(pts, center, scale):
    # pts: [(x1, y1), (x2, y2), (x3, y3)]
    # center: (cx, cy)
    return [
        (center[0] + (x - center[0]) * scale, center[1] + (y - center[1]) * scale)
        for x, y in pts
    ]

def polypoints(ent):
    if ent.dxftype()=='LWPOLYLINE':
        return [(pt[0], pt[1]) for pt in ent.get_points('xy')]
    elif ent.dxftype()=='POLYLINE':
        return [(v.dxf.location.x, v.dxf.location.y) for v in ent.vertices]
    return []

def all_pair_distances(pts):
    return [distance(pts[i], pts[i+1]) for i in range(len(pts)-1)]

def line_exists_between_points(msp, p1, p2, tolerance=1e-6):
    """ë‘ ì  ì‚¬ì´ì— ì´ë¯¸ LINEì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    for line in msp.query('LINE'):
        start = (line.dxf.start.x, line.dxf.start.y)
        end = (line.dxf.end.x, line.dxf.end.y)
        
        # ì–‘ë°©í–¥ ëª¨ë‘ ì²´í¬
        if ((abs(start[0] - p1[0]) < tolerance and 
             abs(start[1] - p1[1]) < tolerance and
             abs(end[0] - p2[0]) < tolerance and 
             abs(end[1] - p2[1]) < tolerance) or
            (abs(start[0] - p2[0]) < tolerance and 
             abs(start[1] - p2[1]) < tolerance and
             abs(end[0] - p1[0]) < tolerance and 
             abs(end[1] - p1[1]) < tolerance)):
            return True
    return False

def process_dxf(filepath: str):
    print(f"\nğŸ“ ì²˜ë¦¬ ì¤‘: {Path(filepath).name}")
    doc = ezdxf.readfile(filepath)
    modifier = DxfModifier(filepath)
    c_keys, direct_ls = modifier.find_and_modify_green_lines(doc)
    msp = doc.modelspace()

    # 1. C_LINES ë¶„ë¥˜: width 0.6 -> ELBO or PIPE (ìˆ˜ì •ë¨)
    for dl in direct_ls:
        if not dl.width or abs(dl.width-0.6)>1e-3: continue
        pts = dl.points
        n = len(pts)
        
        # POLYLINEê³¼ LWPOLYLINE ëª¨ë‘ ì²˜ë¦¬í•˜ë„ë¡ ìˆ˜ì •
        for ent in msp:
            if ent.dxftype() not in ['POLYLINE', 'LWPOLYLINE']:
                continue
                
            # ê° íƒ€ì…ì— ë§ê²Œ ì¢Œí‘œ ì¶”ì¶œ
            if ent.dxftype() == 'POLYLINE':
                epts = [(v.dxf.location.x, v.dxf.location.y) for v in ent.vertices]
            else:  # LWPOLYLINE
                epts = [(pt[0], pt[1]) for pt in ent.get_points('xy')]
                
            # ì¢Œí‘œê°€ ì¼ì¹˜í•˜ëŠ” ì—”í‹°í‹°ë¥¼ ì°¾ì•„ì„œ ë ˆì´ì–´ ì„¤ì •
            if len(epts)==n and all(abs(epts[i][0]-pts[i][0])<1e-4 and abs(epts[i][1]-pts[i][1])<1e-4 for i in range(n)):
                # bulgeê°€ ìˆìœ¼ë©´ ELBO, ì—†ìœ¼ë©´ PIPE ë ˆì´ì–´ë¡œ ì„¤ì •
                ent.dxf.layer = 'ELBO' if has_bulge(ent) else 'PIPE'
                break

    # 2. PL ì²˜ë¦¬: ë‹¤ì–‘í•œ ì  ê°œìˆ˜ë³„ ë ˆì´ì–´ ë³€ê²½
    entities_to_delete = []  # ì‚­ì œí•  ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸
    
    for ent in list(msp):
        if ent.dxftype() not in ['LWPOLYLINE','POLYLINE']: continue
        pts = polypoints(ent)
        n = len(pts)
        key = tuple((round(x,6),round(y,6)) for x,y in pts)
        if ent.dxftype()=='POLYLINE' and key in c_keys: continue
        if getattr(ent.dxf,'const_width',0)!=0: continue

        # 3ì  polyline (PL3)
        if n==3:
            if has_bulge(ent):
                r = get_bulge_radius(ent)
                if r and 2 <= r <= 3:
                    ent.dxf.layer = 'WELDNO'
                    ent.dxf.color = 2
                elif r and 5 <= r <= 8:
                    # INSTNO ì²˜ë¦¬ - ì›ìœ¼ë¡œ ëŒ€ì²´
                    print(f"\nINSTNO í´ë¦¬ë¼ì¸ ë°œê²¬: bulge ë°˜ì§€ë¦„ = {r:.3f}")
                    
                    # bulgeë¥¼ ì‚¬ìš©í•˜ì—¬ ì •í™•í•œ ì›ì˜ ì¤‘ì‹¬ì ê³¼ ë°˜ì§€ë¦„ ê³„ì‚°
                    center, calculated_radius = get_polyline_arc_center_and_radius_with_bulge(ent)
                    
                    if center and calculated_radius:
                        print(f"í´ë¦¬ë¼ì¸ íƒ€ì…: {ent.dxftype()}")
                        print(f"3ì  ì¢Œí‘œ: {pts}")
                        print(f"ê³„ì‚°ëœ ì¤‘ì‹¬: ({center[0]:.3f}, {center[1]:.3f}), ë°˜ì§€ë¦„: {calculated_radius:.3f}")
                        
                        # ë™ì¼í•œ ìœ„ì¹˜ì— ë™ì¼í•œ ì›ì´ ìˆëŠ”ì§€ í™•ì¸
                        if not circle_exists_at_position(msp, center, calculated_radius):
                            # ì› ê·¸ë¦¬ê¸° - CYAN ìƒ‰ìƒ(4)
                            circle = msp.add_circle(
                                center=center,
                                radius=calculated_radius,
                                dxfattribs={'layer': 'INSTNO', 'color': 4}  # CYAN
                            )
                            print(f"âœ… CYAN ì› ì¶”ê°€ ì™„ë£Œ: ì¤‘ì‹¬ ({center[0]:.3f}, {center[1]:.3f}), ë°˜ì§€ë¦„ {calculated_radius:.3f}")
                            
                            # ì›ë³¸ í´ë¦¬ë¼ì¸ì„ ì‚­ì œ ëª©ë¡ì— ì¶”ê°€
                            entities_to_delete.append(ent)
                            print(f"í´ë¦¬ë¼ì¸ì„ ì‚­ì œ ëª©ë¡ì— ì¶”ê°€")
                        else:
                            print(f"âš ï¸ ì›ì´ ì´ë¯¸ ì¡´ì¬ (SKIP)")
                    else:
                        print(f"âŒ ì›ì˜ ì¤‘ì‹¬ì  ê³„ì‚° ì‹¤íŒ¨")
                        # ê³„ì‚° ì‹¤íŒ¨ì‹œì—ë„ ë ˆì´ì–´ëŠ” ì„¤ì •
                        ent.dxf.layer = 'INSTNO'
                        ent.dxf.color = 2

        # 4ì  polyline (PL4) - FALL ì¡°ê±´ ì¶”ê°€
        elif n==4:
            # ì ê°„ ê±°ë¦¬ ê³„ì‚° (ë§ˆì§€ë§‰ ì ì—ì„œ ì²« ì ìœ¼ë¡œì˜ ê±°ë¦¬ í¬í•¨)
            dists = all_pair_distances(pts)
            last_to_first = distance(pts[3], pts[0])
            
            # FALL íŒ¨í„´ í™•ì¸ (í—ˆìš© ì˜¤ì°¨ 0.1mm)
            tolerance = 0.1
            if (len(dists) >= 3 and
                abs(dists[0] - 7.445) <= tolerance and  # ì 1â†’ì 2
                abs(dists[1] - 1.612) <= tolerance and  # ì 2â†’ì 3
                abs(dists[2] - 7.592) <= tolerance and  # ì 3â†’ì 4
                abs(last_to_first - 0) <= tolerance):   # ì 4â†’ì 1
                ent.dxf.layer = 'FALL'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL4'
                ent.dxf.color = 7

        # 5ì  polyline (PL5)
        elif n==5:
            dists = all_pair_distances(pts)
            if all(d<=4.5 for d in dists):
                ent.dxf.layer = 'itemno'
            elif any(d>=30 for d in dists):
                ent.dxf.layer = 'spoolno'
            else:
                ent.dxf.layer = 'PL5'
            ent.dxf.color = 7

        # 6ì  polyline (PL6) - ìˆ˜ì •ëœ ë¶€ë¶„
        elif n==6:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ëª¨ë“  ì ê°„ ê±°ë¦¬ì˜ í•©
            
            # ê¸¸ì´ê°’ í•©ê³„ ê¸°ì¤€ìœ¼ë¡œ ë ˆì´ì–´ ì§€ì •
            if 10 <= total_dist <= 11:
                ent.dxf.layer = 'SFW'
                ent.dxf.color = 2
            elif 17.5 <= total_dist <= 22:
                ent.dxf.layer = 'REDU'
                ent.dxf.color = 2
            elif 16 <= total_dist <= 16.5:
                ent.dxf.layer = 'REDU'
                ent.dxf.color = 2
            elif 17 <= total_dist <= 17.3:
                ent.dxf.layer = 'FLOW'
                ent.dxf.color = 2
            elif 12 <= total_dist <= 13.3:
                ent.dxf.layer = 'OLET'
                ent.dxf.color = 2
            elif any(d<=1.0 for d in dists):
                ent.dxf.layer = 'FLAN'
                ent.dxf.color = 2
            elif sum(1 for d in dists if 6<=d<=15)>=2:
                ent.dxf.layer = 'VALV'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL6'
                ent.dxf.color = 7

        elif n==7:
            dists = all_pair_distances(pts)
            mov_idx = [i for i,d in enumerate(dists) if 3<=d<=5]
            if len(mov_idx)>=2:
                ent.dxf.layer = 'MOV'
                ent.dxf.color = 2
            elif all(d<=2.2 for d in dists):
                ent.dxf.layer='weld'
                ent.dxf.color=2
            else:
                ent.dxf.layer = 'PL7'
                ent.dxf.color = 4

        elif n==8:
            dists = all_pair_distances(pts)
            if sum(1 for d in dists if 1.5<=d<=4)>=5:
                ent.dxf.layer = 'WOLET'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL8'
                ent.dxf.color = 7

        elif n==9:
            dists = all_pair_distances(pts)
            if all(d<=5 for d in dists):
                ent.dxf.layer = 'CV'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL9'
                ent.dxf.color = 7

        elif n==10:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ëª¨ë“  ì ê°„ ê±°ë¦¬ì˜ í•©
            
            if 13.5 <= total_dist <= 14.5:
                ent.dxf.layer = 'CAP'
                ent.dxf.color = 2  # Yellow
            else:
                ent.dxf.layer = 'PL10'
                ent.dxf.color = 7

        elif n==12:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ëª¨ë“  ì ê°„ ê±°ë¦¬ì˜ í•©
            
            if 34 <= total_dist <= 35:
                ent.dxf.layer = 'SFW'
                ent.dxf.color = 2  # Yellow
            else:
                ent.dxf.layer = 'PL12'
                ent.dxf.color = 7

        elif n==2:
            ent.dxf.layer = 'PL2'
            ent.dxf.color = 7
    
    # ì‚­ì œ ì˜ˆì •ì¸ ì—”í‹°í‹°ë“¤ì„ ì‹¤ì œë¡œ ì‚­ì œ
    print(f"\nì‚­ì œ ëŒ€ìƒ ì—”í‹°í‹° ìˆ˜: {len(entities_to_delete)}ê°œ")
    for idx, ent in enumerate(entities_to_delete):
        try:
            msp.delete_entity(ent)
            print(f"  [{idx+1}] INSTNO í´ë¦¬ë¼ì¸ ì‚­ì œ ì™„ë£Œ")
        except Exception as e:
            print(f"  [{idx+1}] ì‚­ì œ ì‹¤íŒ¨: {e}")
    
    # 3. TEXT ë ˆì´ì–´ ì§€ì •
    for ent in msp.query('TEXT'):
        txt = ent.dxf.text.upper()
        if '<' in txt and '>' in txt:
            ent.dxf.layer = 'itemno'
        elif any(tag in txt for tag in ['EL+','EL-','FL+','FL-']):
            ent.dxf.layer = 'ELEV'
        elif any(letter in txt for letter in ['F','G']):
            ent.dxf.layer = 'FLAN'
        elif 'FALL' in txt:
            ent.dxf.layer = 'FALL'

    # 4. SP3, SP7 ì²˜ë¦¬ (ë ˆì´ì–´ë§Œ ì§€ì •)
    # 4. SP3, SP7 ì²˜ë¦¬ (ë ˆì´ì–´ë§Œ ì§€ì •)
    for ent in msp:
        if ent.dxftype() not in ['LWPOLYLINE','POLYLINE']: continue
        pts = polypoints(ent)
        n = len(pts)
        # ARROW ì„ ê¸‹ê¸° - ì¤‘ë³µ ì²´í¬ ì¶”ê°€
        if n==3:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ì ê°„ ê±°ë¦¬ì˜ í•© ê³„ì‚°
            
            if total_dist <= 5:  # ìƒˆë¡œìš´ ì¡°ê±´: ì ê°„ ê±°ë¦¬ í•©ì´ 5 ì´í•˜
                # LINEì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                if not line_exists_between_points(msp, pts[2], pts[0]):
                    # ì›ë˜ ì‚¼ê°í˜• ì„¸ ë³€
                    line20 = msp.add_line(pts[2], pts[0], dxfattribs={'color': 7, 'layer': 'ARROW'})
                    print(f"ìƒˆ LINE ì¶”ê°€: {pts[2]} -> {pts[0]}")
                else:
                    print(f"LINE ì´ë¯¸ ì¡´ì¬: {pts[2]} -> {pts[0]} (SKIP)")
        elif n==7:
            dists = all_pair_distances(pts)
            if any(d>30 for d in dists):
                ent.dxf.layer = 'SUPP'

    # 5. PIPE ë ˆì´ì–´ ì²˜ë¦¬ (ì‚­ì œ X, color ë§Œ ì²˜ë¦¬)
    for ent in list(msp):
        if ent.dxftype() in ['LWPOLYLINE','POLYLINE'] and ent.dxf.layer=='PIPE':
            ent.dxf.color = 3

    # FALL ë ˆì´ì–´ì˜ 2ì  í´ë¦¬ë¼ì¸ ìƒ‰ìƒì„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½
    for ent in list(msp):
        if ent.dxftype() in ['LWPOLYLINE','POLYLINE'] and ent.dxf.layer=='FALL':
            pts = polypoints(ent)
            if len(pts) == 2:
                ent.dxf.color = 7  # í°ìƒ‰

    for txt in msp.query('TEXT'):
        txt.dxf.color = 2
        txt.dxf.style = "ARIAL"
       # txt.dxf.width = 0.86 

    def set_width_by_f_x(msp):
        # 1. FABRICATION MATERIALS í…ìŠ¤íŠ¸ì˜ 'F' ë¬¸ì ìœ„ì¹˜(Xì¢Œí‘œ) ì°¾ê¸°
        f_x = None
        for txt in msp.query('TEXT'):
            if txt.dxf.text and txt.dxf.text.strip().upper().startswith('F'):
                f_x = txt.dxf.insert[0]
                break  # ì²« 'F'ë§Œ ì°¾ìœ¼ë©´ ë¨

        if f_x is None:
            print("FABRICATION MATERIALSì˜ F ìœ„ì¹˜ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
            return

        # 2. ì „ì²´ TEXTë¥¼ ëŒë©´ì„œ F ê¸°ì¤€ ì™¼ìª½/ì˜¤ë¥¸ìª½ì— width ì ìš©
        for txt in msp.query('TEXT'):
            if not txt.dxf.text:
                continue
            x = txt.dxf.insert[0]
            # í­ì€ ëª¨ë‘ floatìœ¼ë¡œ ë¹„êµ
            if x < f_x - 1e-4:  # Fì˜ Xë³´ë‹¤ ì™¼ìª½
                txt.dxf.width = 0.87
            else:  # F í¬í•¨ ì˜¤ë¥¸ìª½(í¬í•¨)
                txt.dxf.width = 0.8
            txt.dxf.style = "ARIAL"
            txt.dxf.color = 2


        if "ARIAL" not in doc.styles:
            doc.styles.new("ARIAL", dxfattribs={"font": "arial.ttf"})
    set_width_by_f_x(msp)

    # 7. íŒŒì¼ ì €ì¥
    outname = Path(filepath).with_stem(Path(filepath).stem + '_PL')
    doc.saveas(str(outname))
    print(f"âœ… ì €ì¥ ì™„ë£Œ: {outname}")

def select_files_and_process():
    root = tk.Tk()
    root.withdraw()
    files = filedialog.askopenfilenames(filetypes=[('DXF files','*.dxf')])
    for f in files:
        process_dxf(f)

if __name__ == '__main__':
    select_files_and_process()