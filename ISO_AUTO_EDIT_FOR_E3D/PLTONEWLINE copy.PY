import ezdxf
from pathlib import Path
import tkinter as tk
from tkinter import filedialog
from typing import List, Tuple, Optional
import math
from dataclasses import dataclass
from ezdxf.math import Vec2
import os
from tkinter import messagebox
import numpy as np

# =============== PLTONEWLINE ê´€ë ¨ í´ë˜ìŠ¤ì™€ í•¨ìˆ˜ë“¤ ===============
@dataclass
class LineInfo:
    entity_type: str
    layer: str
    points: List[Tuple[float, float]]
    width: Optional[float]
    source: str

class DxfModifier:
    def __init__(self, input_file: str):
        self.input_file = Path(input_file)

    def _direct_parse_dxf(self) -> List[LineInfo]:
        lines: List[LineInfo] = []
        try:
            with open(self.input_file, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.readlines()
            i = 0
            while i < len(content):
                line = content[i].strip()
                
                # LWPOLYLINE ì²˜ë¦¬ ì¶”ê°€
                if line == "LWPOLYLINE":
                    layer = "0"
                    const_width = None
                    points = []
                    i += 1
                    
                    # LWPOLYLINE í—¤ë” ì •ë³´ íŒŒì‹±
                    while i < len(content):
                        code = content[i].strip()
                        if code == "10":  # ì²« ë²ˆì§¸ X ì¢Œí‘œë¥¼ ë§Œë‚˜ë©´ ì¢Œí‘œ ìˆ˜ì§‘ ì‹œì‘
                            break
                        if code == "8":  # Layer
                            i += 1
                            if i < len(content):
                                layer = content[i].strip()
                        elif code == "43":  # Constant width
                            i += 1
                            if i < len(content):
                                const_width = float(content[i].strip())
                        i += 1
                    
                    # ì¢Œí‘œ ìˆ˜ì§‘
                    while i < len(content):
                        code = content[i].strip()
                        if code == "10":  # X coordinate
                            x = None
                            y = None
                            i += 1
                            if i < len(content):
                                x = float(content[i].strip())
                            i += 1
                            # ë‹¤ìŒì€ 20 (Y coordinate)ì´ì–´ì•¼ í•¨
                            if i < len(content) and content[i].strip() == "20":
                                i += 1
                                if i < len(content):
                                    y = float(content[i].strip())
                                if x is not None and y is not None:
                                    points.append((x, y))
                        elif code == "0":  # ë‹¤ìŒ ì—”í‹°í‹° ì‹œì‘
                            break
                        else:
                            i += 1
                    
                    # widthê°€ 0.6ì¸ ê²½ìš°ë§Œ ì €ì¥
                    if const_width and const_width == 0.6 and len(points) >= 2:
                        lines.append(LineInfo(
                            entity_type="LWPOLYLINE",
                            layer=layer,
                            points=points,
                            width=const_width,
                            source="direct_parsing"
                        ))
                    i += 1
                    
                elif line == "POLYLINE":
                    layer = "0"
                    start_width: Optional[float] = None
                    end_width: Optional[float] = None
                    i += 1
                    # í—¤ë” íŒŒì‹±
                    while i < len(content):
                        code = content[i].strip()
                        if code == "VERTEX":
                            break
                        if code == "8":
                            i += 1
                            if i < len(content):
                                layer = content[i].strip()
                        elif code == "40":
                            i += 1
                            if i < len(content):
                                try:
                                    start_width = float(content[i].strip())
                                except ValueError:
                                    start_width = None
                        elif code == "41":
                            i += 1
                            if i < len(content):
                                try:
                                    end_width = float(content[i].strip())
                                except ValueError:
                                    end_width = None
                        i += 1
                    # ê¼­ì§€ì  íŒŒì‹±
                    points: List[Tuple[float,float]] = []
                    while i < len(content):
                        token = content[i].strip()
                        if token == "VERTEX":
                            x = None; y = None
                            i += 1
                            while i < len(content) and content[i].strip() not in ["VERTEX", "SEQEND"]:
                                code = content[i].strip()
                                if code == "10":
                                    i += 1
                                    if i < len(content):
                                        try:
                                            x = float(content[i].strip())
                                        except ValueError:
                                            x = None
                                elif code == "20":
                                    i += 1
                                    if i < len(content):
                                        try:
                                            y = float(content[i].strip())
                                        except ValueError:
                                            y = None
                                i += 1
                            if x is not None and y is not None:
                                points.append((x,y))
                        elif token == "SEQEND":
                            break
                        else:
                            i += 1
                    width = start_width if start_width and start_width > 0 else end_width
                    # widthê°€ 0.6ì¸ ê²½ìš°ë§Œ ì €ì¥
                    if width and width == 0.6 and len(points) >= 2:
                        lines.append(LineInfo(
                            entity_type="POLYLINE",
                            layer=layer,
                            points=points,
                            width=width,
                            source="direct_parsing"
                        ))
                    i += 1
                else:
                    i += 1
        except Exception as e:
            print(f"ì§ì ‘ íŒŒì‹± ì¤‘ ì˜¤ë¥˜: {e}")
        return lines

    def find_and_modify_green_lines(self, doc):
        direct_lines = self._direct_parse_dxf()
        c_lines_key = set()
        msp = doc.modelspace()
        modified_count = 0
        
        # widthê°€ 0.6ì¸ ë¼ì¸ë“¤ë§Œ í•„í„°ë§
        width_06_lines = [line for line in direct_lines if line.width and line.width == 0.6]
        
        for entity in msp:
            entity_type = entity.dxftype()
            # POLYLINEê³¼ LWPOLYLINE ëª¨ë‘ ì²˜ë¦¬
            if entity_type in ["POLYLINE", "LWPOLYLINE"]:
                if entity_type == "POLYLINE":
                    pts = [(v.dxf.location.x, v.dxf.location.y) for v in entity.vertices]
                elif entity_type == "LWPOLYLINE":
                    pts = [(pt[0], pt[1]) for pt in entity.get_points('xy')]
                else:
                    continue
                    
                key = tuple((round(x,6), round(y,6)) for x,y in pts)
                
                for dl in width_06_lines:
                    # ë™ì¼í•œ ì—”í‹°í‹° íƒ€ì…ì¸ì§€ë„ í™•ì¸
                    if (dl.entity_type == entity_type and
                        len(dl.points) == len(pts) and 
                        self._points_match(pts, dl.points)):
                        try:
                            entity.dxf.color = 3  # Green
                            entity.dxf.lineweight = 50
                            c_lines_key.add(key)
                            modified_count += 1
                            break
                        except Exception as e:
                            print(f"ì—”í‹°í‹° ìˆ˜ì • ì‹¤íŒ¨ ({entity_type}): {e}")
        
        print(f"width = 0.6ì¸ ë¼ì¸ìœ¼ë¡œ ìˆ˜ì •ëœ ê°œìˆ˜: {modified_count}ê°œ")
        return c_lines_key, direct_lines

    def _points_match(self, p1: List[Tuple[float,float]], p2: List[Tuple[float,float]], tol=1e-3) -> bool:
        if len(p1) != len(p2): return False
        for a,b in zip(p1,p2):
            if abs(a[0]-b[0])>tol or abs(a[1]-b[1])>tol:
                return False
        return True

# PLTONEWLINE ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
def has_bulge(ent):
    if ent.dxftype() == 'LWPOLYLINE':
        for x, y, bulge in ent.get_points('xyb'):
            if abs(bulge) > 1e-7:
                return True
        return False
    elif ent.dxftype() == 'POLYLINE':
        for v in ent.vertices:
            if hasattr(v.dxf, 'bulge') and abs(v.dxf.bulge) > 1e-7:
                return True
        return False
    return False

def get_bulge_radius(ent):
    pts = polypoints(ent)
    n = len(pts)
    if n < 2:
        return None

    if ent.dxftype() == 'LWPOLYLINE':
        points = list(ent.get_points('xyb'))
        for idx, (x, y, bulge) in enumerate(points[:-1]):
            if abs(bulge) > 1e-7:
                chord = distance(pts[idx], pts[idx+1])
                theta = 4 * math.atan(abs(bulge))
                if theta == 0:
                    continue
                return abs(chord / (2 * math.sin(theta/2)))
    else:
        verts = list(ent.vertices)
        for idx, v in enumerate(verts[:-1]):
            if hasattr(v.dxf, 'bulge') and abs(v.dxf.bulge) > 1e-7:
                chord = distance(pts[idx], pts[idx+1])
                theta = 4 * math.atan(abs(v.dxf.bulge))
                if theta == 0:
                    continue
                return abs(chord / (2 * math.sin(theta/2)))
    return None

def centroid(pts):
    return (sum(p[0] for p in pts)/len(pts), sum(p[1] for p in pts)/len(pts))

def scale_triangle(pts, center, scale):
    return [(center[0]+(x-center[0])*scale, center[1]+(y-center[1])*scale) for x,y in pts]

def distance(p1, p2):
    return math.dist(p1, p2)
          
def draw_line(msp, p1, p2, color=7, layer=None):
    attrib = {"color": color}
    if layer:
        attrib["layer"] = layer
    msp.add_line(p1, p2, dxfattribs=attrib)

def polypoints(ent):
    if ent.dxftype()=='LWPOLYLINE':
        return [(pt[0], pt[1]) for pt in ent.get_points('xy')]
    elif ent.dxftype()=='POLYLINE':
        return [(v.dxf.location.x, v.dxf.location.y) for v in ent.vertices]
    return []

def all_pair_distances(pts):
    return [distance(pts[i], pts[i+1]) for i in range(len(pts)-1)]

def line_exists_between_points(msp, p1, p2, tolerance=1e-6):
    """ë‘ ì  ì‚¬ì´ì— ì´ë¯¸ LINEì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸"""
    for line in msp.query('LINE'):
        start = (line.dxf.start.x, line.dxf.start.y)
        end = (line.dxf.end.x, line.dxf.end.y)
        
        # ì–‘ë°©í–¥ ëª¨ë‘ ì²´í¬
        if ((abs(start[0] - p1[0]) < tolerance and 
             abs(start[1] - p1[1]) < tolerance and
             abs(end[0] - p2[0]) < tolerance and 
             abs(end[1] - p2[1]) < tolerance) or
            (abs(start[0] - p2[0]) < tolerance and 
             abs(start[1] - p2[1]) < tolerance and
             abs(end[0] - p1[0]) < tolerance and 
             abs(end[1] - p1[1]) < tolerance)):
            return True
    return False

# =============== CROSCHK ê´€ë ¨ í´ë˜ìŠ¤ ===============
class PipeLayerRenamer:
    def __init__(self):
        self.doc = None
        self.msp = None
        self.pno_array = []
        self.psize_array = []
        self.pbox_entities = []
        
    def distance_2d(self, p1, p2):
        """2D ê±°ë¦¬ ê³„ì‚°"""
        return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
    
    def find_text_near_point(self, point, radius, layer=None):
        """íŠ¹ì • ì§€ì  ê·¼ì²˜ì˜ í…ìŠ¤íŠ¸ ì°¾ê¸°"""
        texts = []
        for entity in self.msp:
            if entity.dxftype() in ['TEXT', 'MTEXT']:
                if layer and entity.dxf.layer != layer:
                    continue
                    
                if entity.dxftype() == 'TEXT':
                    pos = entity.dxf.insert
                else:  # MTEXT
                    pos = entity.dxf.insert
                    
                if self.distance_2d(point, pos) <= radius:
                    texts.append(entity)
        return texts
    
    def find_headers_near_text(self, search_text, search_radius=100):
        """íŠ¹ì • í…ìŠ¤íŠ¸ ê·¼ì²˜ì—ì„œ í—¤ë” ì°¾ê¸°"""
        headers = {'PT': None, 'ITEM': None, 'MATERIAL': None, 'SIZE': None}
        
        # ë¨¼ì € search_text ì°¾ê¸°
        base_text = None
        for entity in self.msp:
            if entity.dxftype() in ['TEXT', 'MTEXT']:
                text_content = entity.dxf.text if entity.dxftype() == 'TEXT' else entity.text
                if search_text in text_content:
                    base_text = entity
                    break
        
        if not base_text:
            return headers
        
        base_pos = base_text.dxf.insert
        
        # ê·¼ì²˜ì—ì„œ í—¤ë” ì°¾ê¸°
        for entity in self.msp:
            if entity.dxftype() in ['TEXT', 'MTEXT']:
                text_content = entity.dxf.text if entity.dxftype() == 'TEXT' else entity.text
                pos = entity.dxf.insert
                
                if self.distance_2d(base_pos, pos) <= search_radius:
                    for header in headers:
                        if header in text_content.upper():
                            headers[header] = entity
                            # í—¤ë” ìƒ‰ìƒì„ REDë¡œ ë³€ê²½
                            entity.dxf.color = 1  # RED
                            
        return headers
    
    def find_pipe_items_in_area(self, base_text, y_offset=-50, x_min=-10, x_max=80):
        """íŠ¹ì • í…ìŠ¤íŠ¸ ê¸°ì¤€ìœ¼ë¡œ ì§€ì •ëœ ë²”ìœ„ ë‚´ì—ì„œ PIPE í•­ëª© ì°¾ê¸°"""
        pipe_items = []
        if not base_text:
            return pipe_items
            
        base_pos = base_text.dxf.insert
        
        # ì§€ì •ëœ ë²”ìœ„ ë‚´ì—ì„œ PIPE í…ìŠ¤íŠ¸ ì°¾ê¸°
        for entity in self.msp:
            if entity.dxftype() in ['TEXT', 'MTEXT']:
                text_content = entity.dxf.text if entity.dxftype() == 'TEXT' else entity.text
                pos = entity.dxf.insert
                
                # Y: base_posì—ì„œ -50mm ì•„ë˜ê¹Œì§€
                # X: base_posì—ì„œ -10mm ~ +80mm ë²”ìœ„
                y_in_range = (base_pos[1] + y_offset) <= pos[1] <= base_pos[1]
                x_in_range = (base_pos[0] + x_min) <= pos[0] <= (base_pos[0] + x_max)
                
                if y_in_range and x_in_range and 'PIPE' in text_content.upper():
                    pipe_items.append(entity)
                        
        # Y ì¢Œí‘œë¡œ ì •ë ¬ (ìœ„ì—ì„œ ì•„ë˜ë¡œ)
        pipe_items.sort(key=lambda e: e.dxf.insert[1], reverse=True)
        
        return pipe_items
    
    def extract_pipe_info_from_pipe_text(self, pipe_entity):
        """PIPE í…ìŠ¤íŠ¸ì—ì„œ ì§ì ‘ PTì™€ SIZE ì •ë³´ ì¶”ì¶œ"""
        pipe_text = pipe_entity.dxf.text if pipe_entity.dxftype() == 'TEXT' else pipe_entity.text
        pipe_pos = pipe_entity.dxf.insert
        
        print(f"     PIPE í…ìŠ¤íŠ¸ at ({pipe_pos[0]:.1f}, {pipe_pos[1]:.1f}): {pipe_text}")
        
        # PIPE í…ìŠ¤íŠ¸ ì£¼ë³€ì—ì„œ ìˆ«ì ì°¾ê¸°
        pt_value = None
        size_value = None
        
        # Y ì¢Œí‘œ í—ˆìš© ì˜¤ì°¨ë¥¼ ë” ì—„ê²©í•˜ê²Œ ì„¤ì • (1mm)
        y_tolerance = 1.0
        
        # PIPE í…ìŠ¤íŠ¸ ê·¼ì²˜ì—ì„œ ëª¨ë“  í…ìŠ¤íŠ¸ ê²€ìƒ‰
        nearby_texts = []
        for entity in self.msp:
            if entity.dxftype() in ['TEXT', 'MTEXT']:
                if entity == pipe_entity:
                    continue
                pos = entity.dxf.insert
                # PIPE í…ìŠ¤íŠ¸ì™€ ì •í™•íˆ ê°™ì€ ì¤„(Y ì¢Œí‘œ ì°¨ì´ 1mm ì´ë‚´)ì— ìˆëŠ” í…ìŠ¤íŠ¸
                if abs(pos[1] - pipe_pos[1]) <= y_tolerance:
                    text_content = entity.dxf.text if entity.dxftype() == 'TEXT' else entity.text
                    nearby_texts.append((pos[0], text_content.strip(), entity, pos[1]))
        
        # X ì¢Œí‘œë¡œ ì •ë ¬
        nearby_texts.sort(key=lambda x: x[0])
        
        # ë””ë²„ê¹…: ê°™ì€ ì¤„ì˜ ëª¨ë“  í…ìŠ¤íŠ¸ ì¶œë ¥
        print(f"     ê°™ì€ ì¤„ì˜ í…ìŠ¤íŠ¸ë“¤ (Y ì˜¤ì°¨ â‰¤ {y_tolerance}mm):")
        for x, text, _, y in nearby_texts:
            y_diff = abs(y - pipe_pos[1])
            print(f"       X={x:.1f}, Y={y:.1f} (ì°¨ì´={y_diff:.2f}mm): '{text}'")
        
        # PIPE ì™¼ìª½ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ìˆ«ì ì°¾ê¸° (PT)
        left_numbers = [(x, text, entity) for x, text, entity, _ in nearby_texts 
                        if x < pipe_pos[0] and text.isdigit()]
        if left_numbers:
            # ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
            left_numbers.sort(key=lambda item: pipe_pos[0] - item[0])
            pt_value = int(left_numbers[0][1])
            left_numbers[0][2].dxf.color = 1  # RED
            print(f"     PT ì°¾ìŒ: {pt_value} at X={left_numbers[0][0]:.1f}")
        
        # PIPE ì˜¤ë¥¸ìª½ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ìˆ«ì ì°¾ê¸° (SIZE)
        right_numbers = [(x, text, entity) for x, text, entity, _ in nearby_texts 
                         if x > pipe_pos[0] and text.isdigit()]
        if right_numbers:
            # ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
            right_numbers.sort(key=lambda item: item[0] - pipe_pos[0])
            size_value = int(right_numbers[0][1])
            right_numbers[0][2].dxf.color = 1  # RED
            print(f"     SIZE ì°¾ìŒ: {size_value} at X={right_numbers[0][0]:.1f}")
        
        if pt_value is None or size_value is None:
            print(f"     ì£¼ì˜: PT={pt_value}, SIZE={size_value} - ëˆ„ë½ëœ ê°’ì´ ìˆìŠµë‹ˆë‹¤!")
                    
        return pt_value, size_value
    
    def extract_pipe_info(self, pipe_entity, pt_x, size_x):
        """PIPE ì—”í‹°í‹°ì—ì„œ PTì™€ SIZE ì •ë³´ ì¶”ì¶œ"""
        pipe_pos = pipe_entity.dxf.insert
        pipe_y = pipe_pos[1]
        
        # PT ê°’ ì°¾ê¸° (PIPE -X 20mm ë‚´)
        pt_texts = self.find_text_near_point((pt_x, pipe_y), 20)
        pt_value = None
        for text in pt_texts:
            content = text.dxf.text if text.dxftype() == 'TEXT' else text.text
            if content.strip().isdigit():
                pt_value = int(content.strip())
                break
        
        # SIZE ê°’ ì°¾ê¸° (PIPE +X 85mm)
        size_texts = self.find_text_near_point((size_x, pipe_y), 20)
        size_value = None
        for text in size_texts:
            content = text.dxf.text if text.dxftype() == 'TEXT' else text.text
            # ë¬¸ìê°€ í¬í•¨ë˜ì§€ ì•Šì€ ìˆœìˆ˜ ìˆ«ìë§Œ
            if content.strip().isdigit():
                size_value = int(content.strip())
                break
                
        return pt_value, size_value
    
    def find_polylines_with_5_points(self):
        """5ê°œ ì ì„ ê°€ì§„ í´ë¦¬ë¼ì¸ ì°¾ê¸° (ì ê°„ ê±°ë¦¬ í•© 13.5~14.5)"""
        pbox_list = []
        
        for entity in self.msp:
            if entity.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
                points = []
                
                if entity.dxftype() == 'LWPOLYLINE':
                    points = list(entity.get_points('xy'))
                else:  # POLYLINE
                    for vertex in entity.vertices:
                        points.append((vertex.dxf.location.x, vertex.dxf.location.y))
                
                if len(points) == 5:
                    # ì ê°„ ê±°ë¦¬ í•© ê³„ì‚°
                    total_dist = 0
                    for i in range(4):
                        total_dist += self.distance_2d(points[i], points[i+1])
                    
                    if 13.5 <= total_dist <= 14.5:
                        pbox_list.append((entity, points))
                        # RED ìƒ‰ìƒìœ¼ë¡œ ë³€ê²½
                        entity.dxf.color = 1  # RED
                        
        return pbox_list
    
    def find_nearest_pno(self, pbox_center):
        """PBOX ì¤‘ì‹¬ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ PNO ì°¾ê¸°"""
        if len(self.pno_array) < 2:
            return None, None
            
        min_dist = float('inf')
        nearest_idx = 1  # 1ë²ˆ ì œì™¸í•˜ê³  2ë²ˆë¶€í„°
        
        for i in range(1, len(self.pno_array)):
            pno = self.pno_array[i]
            # PNO í…ìŠ¤íŠ¸ ìœ„ì¹˜ ì°¾ê¸°
            for entity in self.msp:
                if entity.dxftype() in ['TEXT', 'MTEXT']:
                    content = entity.dxf.text if entity.dxftype() == 'TEXT' else entity.text
                    if content.strip() == str(pno):
                        pos = entity.dxf.insert
                        dist = self.distance_2d(pbox_center, pos)
                        if dist < min_dist:
                            min_dist = dist
                            nearest_idx = i
                            dpno_entity = entity
                            
        return nearest_idx, dpno_entity if 'dpno_entity' in locals() else None
    
    def get_text_slope(self, text_entity):
        """í…ìŠ¤íŠ¸ ì—”í‹°í‹°ì˜ ê¸°ìš¸ê¸° êµ¬í•˜ê¸°"""
        if text_entity.dxftype() == 'TEXT':
            rotation = text_entity.dxf.rotation
        else:  # MTEXT
            rotation = text_entity.dxf.rotation if hasattr(text_entity.dxf, 'rotation') else 0
            
        return rotation
    
    def find_multiple_polylines_near_pbox(self, pbox_center, radius, max_count=3):
        """PBOX ì¤‘ì‹¬ì—ì„œ ê°€ê¹Œìš´ ìˆœì„œëŒ€ë¡œ ìµœëŒ€ max_countê°œì˜ 2-3ì  í´ë¦¬ë¼ì¸ ì°¾ê¸°"""
        polyline_distances = []
        
        for entity in self.msp:
            if entity.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
                poly_points = []
                
                if entity.dxftype() == 'LWPOLYLINE':
                    poly_points = list(entity.get_points('xy'))
                else:
                    for vertex in entity.vertices:
                        poly_points.append((vertex.dxf.location.x, vertex.dxf.location.y))
                
                if 2 <= len(poly_points) <= 3:
                    # í´ë¦¬ë¼ì¸ì˜ ëª¨ë“  ì ê³¼ PBOX ì¤‘ì‹¬ ì‚¬ì´ì˜ ìµœì†Œ ê±°ë¦¬
                    min_dist = float('inf')
                    for pp in poly_points:
                        dist = self.distance_2d(pbox_center, pp)
                        if dist < min_dist:
                            min_dist = dist
                    
                    if min_dist <= radius:
                        polyline_distances.append((min_dist, entity, poly_points))
        
        # ê±°ë¦¬ìˆœìœ¼ë¡œ ì •ë ¬
        polyline_distances.sort(key=lambda x: x[0])
        
        # ìµœëŒ€ max_countê°œë§Œ ë°˜í™˜
        result = []
        for i, (dist, entity, points) in enumerate(polyline_distances[:max_count]):
            entity.dxf.color = 1  # RED
            result.append((entity, points))
        
        return result
    
    def find_pipe_layer_entities_near_polyline(self, polyline_points, radius=1):
        """í´ë¦¬ë¼ì¸ ê·¼ì²˜ì˜ PIPE ë ˆì´ì–´ ì—”í‹°í‹° ì°¾ê¸° (ì ê³¼ ì„ ë¶„ ëª¨ë‘ í™•ì¸)"""
        found_entities = set()  # ì¤‘ë³µ ì œê±°ë¥¼ ìœ„í•´ set ì‚¬ìš©
        
        # ê° í´ë¦¬ë¼ì¸ ì ì—ì„œ PIPE ì—”í‹°í‹° ì°¾ê¸°
        for point in polyline_points:
            for entity in self.msp:
                if entity.dxf.layer == 'PIPE':
                    found = False
                    
                    # 1. ì  ê¸°ë°˜ ê²€ìƒ‰
                    if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'insert'):
                        if self.distance_2d(point, entity.dxf.insert) <= radius:
                            found = True
                    elif hasattr(entity, 'dxf') and hasattr(entity.dxf, 'start'):
                        if self.distance_2d(point, entity.dxf.start) <= radius:
                            found = True
                    
                    # 2. í´ë¦¬ë¼ì¸ì¸ ê²½ìš° ì ê³¼ ì„ ë¶„ ëª¨ë‘ í™•ì¸
                    if entity.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
                        if entity.dxftype() == 'LWPOLYLINE':
                            pipe_points = list(entity.get_points('xy'))
                        else:
                            pipe_points = []
                            for vertex in entity.vertices:
                                pipe_points.append((vertex.dxf.location.x, vertex.dxf.location.y))
                        
                        # ì  í™•ì¸
                        for pp in pipe_points:
                            if self.distance_2d(point, pp) <= radius:
                                found = True
                                break
                        
                        # ì„ ë¶„ í™•ì¸
                        if not found:
                            for i in range(len(pipe_points) - 1):
                                dist = self.point_to_line_distance(point, pipe_points[i], pipe_points[i+1])
                                if dist <= radius:
                                    found = True
                                    break
                    
                    if found:
                        found_entities.add(entity)
        
        return list(found_entities)
    
    def find_farthest_point_from_pbox(self, g1_points, pbox_center):
        """PBOX ì¤‘ì‹¬ì—ì„œ ê°€ì¥ ë¨¼ G1 ì  ì°¾ê¸°"""
        max_dist = 0
        farthest_point = None
        
        for point in g1_points:
            dist = self.distance_2d(point, pbox_center)
            if dist > max_dist:
                max_dist = dist
                farthest_point = point
                    
        return farthest_point
    
    def find_pipe_layer_entities_near_point(self, point, radius=1):
        """íŠ¹ì • ì  ê·¼ì²˜ì˜ PIPE ë ˆì´ì–´ ì—”í‹°í‹° ì°¾ê¸°"""
        pipe_entities = []
        
        for entity in self.msp:
            if entity.dxf.layer == 'PIPE':
                # ì—”í‹°í‹°ì˜ ëŒ€í‘œ ì  ì°¾ê¸°
                if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'insert'):
                    pos = entity.dxf.insert
                elif hasattr(entity, 'dxf') and hasattr(entity.dxf, 'start'):
                    pos = entity.dxf.start
                elif entity.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
                    # í´ë¦¬ë¼ì¸ì˜ ì²« ì  ì‚¬ìš©
                    if entity.dxftype() == 'LWPOLYLINE':
                        points = list(entity.get_points('xy'))
                        if points:
                            pos = points[0]
                        else:
                            continue
                    else:
                        vertices = list(entity.vertices)
                        if vertices:
                            pos = (vertices[0].dxf.location.x, vertices[0].dxf.location.y)
                        else:
                            continue
                else:
                    continue
                    
                if self.distance_2d(point, pos) <= radius:
                    pipe_entities.append(entity)
                    
        return pipe_entities
    
    def find_pipe_layer_polylines_near_points(self, points, radius=3):
        """PBOX ê° ì  ê·¼ì²˜ë¥¼ ì§€ë‚˜ê°€ëŠ” PIPE ë ˆì´ì–´ í´ë¦¬ë¼ì¸ ì°¾ê¸°"""
        found_entities = []
        
        for point in points:
            min_dist = float('inf')
            closest_entity = None
            
            for entity in self.msp:
                if entity.dxf.layer == 'PIPE' and entity.dxftype() in ['POLYLINE', 'LWPOLYLINE']:
                    # í´ë¦¬ë¼ì¸ì˜ ì ë“¤ ê°€ì ¸ì˜¤ê¸°
                    if entity.dxftype() == 'LWPOLYLINE':
                        poly_points = list(entity.get_points('xy'))
                    else:
                        poly_points = []
                        for vertex in entity.vertices:
                            poly_points.append((vertex.dxf.location.x, vertex.dxf.location.y))
                    
                    # ê° ì„ ë¶„ì— ëŒ€í•´ ì ê³¼ì˜ ê±°ë¦¬ ê³„ì‚°
                    for i in range(len(poly_points) - 1):
                        p1 = poly_points[i]
                        p2 = poly_points[i + 1]
                        
                        # ì„ ë¶„ê³¼ ì  ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
                        dist = self.point_to_line_distance(point, p1, p2)
                        
                        if dist <= radius and dist < min_dist:
                            min_dist = dist
                            closest_entity = entity
            
            if closest_entity:
                found_entities.append(closest_entity)
                        
        return found_entities
    
    def point_to_line_distance(self, point, line_start, line_end):
        """ì ê³¼ ì„ ë¶„ ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°"""
        x0, y0 = point
        x1, y1 = line_start
        x2, y2 = line_end
        
        # ì„ ë¶„ì˜ ê¸¸ì´ ì œê³±
        line_length_sq = (x2 - x1)**2 + (y2 - y1)**2
        
        if line_length_sq == 0:
            # ì„ ë¶„ì´ ì ì¸ ê²½ìš°
            return self.distance_2d(point, line_start)
        
        # ì ì„ ì„ ë¶„ì— íˆ¬ì˜
        t = max(0, min(1, ((x0 - x1) * (x2 - x1) + (y0 - y1) * (y2 - y1)) / line_length_sq))
        
        # íˆ¬ì˜ëœ ì 
        projection = (x1 + t * (x2 - x1), y1 + t * (y2 - y1))
        
        # ì ê³¼ íˆ¬ì˜ëœ ì  ì‚¬ì´ì˜ ê±°ë¦¬
        return self.distance_2d(point, projection)
    
    def process_croschk(self, doc, msp):
        """CROSCHK ì²˜ë¦¬ - docê³¼ mspë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŒ"""
        self.doc = doc
        self.msp = msp
        
        print("\n" + "="*60)
        print("CROSCHK ì²˜ë¦¬ ì‹œì‘...")
        print("="*60)
        
        # 1. FABRICATION MATERIALS ì²˜ë¦¬
        print("1. FABRICATION MATERIALS ê²€ìƒ‰...")
        fab_text = None
        for entity in self.msp:
            if entity.dxftype() in ['TEXT', 'MTEXT']:
                text_content = entity.dxf.text if entity.dxftype() == 'TEXT' else entity.text
                if 'FABRICATION MATERIALS' in text_content:
                    fab_text = entity
                    break
        
        if fab_text:
            print("   FABRICATION MATERIALS ì°¾ìŒ, ì§€ì • ë²”ìœ„ì—ì„œ PIPE ê²€ìƒ‰...")
            # -Y 50mm, +X -10~80mm ë²”ìœ„ì—ì„œ PIPE ì°¾ê¸°
            pipe_items = self.find_pipe_items_in_area(fab_text, y_offset=-50, x_min=-10, x_max=80)
            print(f"   {len(pipe_items)}ê°œì˜ PIPE í•­ëª© ë°œê²¬")
            
            for pipe in pipe_items:
                pt, size = self.extract_pipe_info_from_pipe_text(pipe)
                if pt is not None and size is not None:
                    self.pno_array.append(pt)
                    self.psize_array.append(size)
                    print(f"   PT: {pt}, SIZE: {size}")
        
        # 2. ERECTION MATERIALS ì²˜ë¦¬
        print("2. ERECTION MATERIALS ê²€ìƒ‰...")
        erec_text = None
        erec_candidates = []
        
        for entity in self.msp:
            if entity.dxftype() in ['TEXT', 'MTEXT']:
                text_content = entity.dxf.text if entity.dxftype() == 'TEXT' else entity.text
                if 'ERECTION' in text_content.upper() and 'MATERIALS' in text_content.upper():
                    erec_candidates.append((entity, text_content))
                    if 'ERECTION MATERIALS' in text_content:
                        erec_text = entity
                        break
        
        if not erec_text and erec_candidates:
            # ì •í™•í•œ ë§¤ì¹˜ê°€ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ í›„ë³´ ì‚¬ìš©
            erec_text = erec_candidates[0][0]
            print(f"   ì •í™•í•œ ë§¤ì¹˜ ì—†ìŒ, í›„ë³´ ì‚¬ìš©: {erec_candidates[0][1]}")
        
        if erec_text:
            erec_pos = erec_text.dxf.insert
            print(f"   ERECTION MATERIALS ì°¾ìŒ at ({erec_pos[0]:.2f}, {erec_pos[1]:.2f})")
            print(f"   í…ìŠ¤íŠ¸ ë‚´ìš©: {erec_text.dxf.text if erec_text.dxftype() == 'TEXT' else erec_text.text}")
            
            # -Y 50mm, +X -10~80mm ë²”ìœ„ì—ì„œ PIPE ì°¾ê¸°
            pipe_items = self.find_pipe_items_in_area(erec_text, y_offset=-50, x_min=-10, x_max=80)
            print(f"   {len(pipe_items)}ê°œì˜ PIPE í•­ëª© ë°œê²¬")
            
            for pipe in pipe_items:
                pt, size = self.extract_pipe_info_from_pipe_text(pipe)
                if pt is not None and size is not None:
                    self.pno_array.append(pt)
                    self.psize_array.append(size)
                    print(f"   PT: {pt}, SIZE: {size}")
        
        # 3. ì°¾ì€ PNO, PSIZE í…ìŠ¤íŠ¸ ìƒ‰ìƒ ë³€ê²½ (ì´ë¯¸ extract_pipe_info_from_pipe_textì—ì„œ ì²˜ë¦¬ë¨)
        print("3. PNO, PSIZE ìƒ‰ìƒ ë³€ê²½ ì™„ë£Œ (ì¶”ì¶œ ì‹œ ìë™ ì²˜ë¦¬ë¨)")
        
        # 4. 5ì  í´ë¦¬ë¼ì¸ ì°¾ê¸°
        print("4. 5ì  í´ë¦¬ë¼ì¸(PBOX) ê²€ìƒ‰...")
        self.pbox_entities = self.find_polylines_with_5_points()
        print(f"   {len(self.pbox_entities)}ê°œ PBOX ì°¾ìŒ")
        
        # 5. ê° PBOX ì²˜ë¦¬
        for idx, (pbox, points) in enumerate(self.pbox_entities):
            print(f"5-{idx+1}. PBOX #{idx+1} ì²˜ë¦¬...")
            
            # PBOX ì¤‘ì‹¬ì  ê³„ì‚°
            center_x = sum(p[0] for p in points) / len(points)
            center_y = sum(p[1] for p in points) / len(points)
            pbox_center = (center_x, center_y)
            
            # ê°€ì¥ ê°€ê¹Œìš´ PNO ì°¾ê¸° (1ë²ˆ ì œì™¸)
            pno_idx, dpno_entity = self.find_nearest_pno(pbox_center)
            if not dpno_entity:
                print("   DPNOë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ - ì´ PBOXëŠ” ê±´ë„ˆëœ€")
                continue
            
            # PSIZEê°€ ìˆëŠ”ì§€ í™•ì¸
            if pno_idx >= len(self.psize_array):
                print("   ëŒ€ì‘í•˜ëŠ” PSIZEê°€ ì—†ìŒ - ì´ PBOXëŠ” ê±´ë„ˆëœ€")
                continue
                
            print(f"   ê°€ì¥ ê°€ê¹Œìš´ PNO: {self.pno_array[pno_idx]}, SIZE: {self.psize_array[pno_idx]}")
            
            # ì°¾ì€ PNO í…ìŠ¤íŠ¸ë¥¼ CYANìœ¼ë¡œ ë³€ê²½
            dpno_entity.dxf.color = 4  # CYAN
            print(f"   PNO {self.pno_array[pno_idx]} í…ìŠ¤íŠ¸ë¥¼ CYANìœ¼ë¡œ ë³€ê²½")
            
            # DPNO ê¸°ìš¸ê¸° í™•ì¸
            slope = self.get_text_slope(dpno_entity)
            
            print(f"   DPNO ê¸°ìš¸ê¸°: {slope}Â°")
            
            new_layer_name = f"PIPE_{self.psize_array[pno_idx]}"
            
            if slope == 0:
                # ê¸°ìš¸ê¸°ê°€ 0ì¸ ê²½ìš°: PBOX ì¤‘ì‹¬ì—ì„œ ê°€ê¹Œìš´ ìˆœì„œëŒ€ë¡œ ìµœëŒ€ 3ê°œì˜ G1 ì°¾ê¸°
                print("   ê¸°ìš¸ê¸° 0: PBOX ì¤‘ì‹¬ì—ì„œ 10mm ë°˜ê²½ ë‚´ 2-3ì  í´ë¦¬ë¼ì¸ ê²€ìƒ‰ (ìµœëŒ€ 3ê°œ)...")
                g1_polylines = self.find_multiple_polylines_near_pbox(pbox_center, 10, max_count=3)
                
                if not g1_polylines:
                    print("   G1 í´ë¦¬ë¼ì¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                    continue
                
                print(f"   {len(g1_polylines)}ê°œì˜ G1 í´ë¦¬ë¼ì¸ ì°¾ìŒ")
                
                # ê° G1ì— ëŒ€í•´ PIPE ì°¾ê¸° ì‹œë„
                pipe_found = False
                for g1_idx, (g1_entity, g1_points) in enumerate(g1_polylines):
                    print(f"   G1 #{g1_idx+1} ({len(g1_points)}ì ) ê²€ì‚¬ ì¤‘...")
                    
                    # G1 ì ë“¤ì—ì„œ 1mm ë‚´ì˜ PIPE ë ˆì´ì–´ ì—”í‹°í‹° ì°¾ê¸° (ì ê³¼ ì„ ë¶„ ëª¨ë‘)
                    pipe_entities = self.find_pipe_layer_entities_near_polyline(g1_points, 1)
                    
                    if pipe_entities:
                        print(f"   G1 #{g1_idx+1}ì—ì„œ {len(pipe_entities)}ê°œì˜ PIPE ë ˆì´ì–´ ì°¾ìŒ")
                        
                        for entity in pipe_entities:
                            # ìƒˆ ë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ìƒì„±
                            if new_layer_name not in self.doc.layers:
                                self.doc.layers.new(name=new_layer_name)
                            
                            # ë ˆì´ì–´ ë³€ê²½
                            entity.dxf.layer = new_layer_name
                            print(f"   ë ˆì´ì–´ ë³€ê²½: PIPE â†’ {new_layer_name}")
                        
                        pipe_found = True
                        break  # PIPEë¥¼ ì°¾ì•˜ìœ¼ë¯€ë¡œ ë‹¤ìŒ G1ì€ ê²€ì‚¬í•˜ì§€ ì•ŠìŒ
                    else:
                        print(f"   G1 #{g1_idx+1}ì—ì„œ PIPEë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                
                if not pipe_found:
                    print(f"   {len(g1_polylines)}ê°œì˜ G1 ëª¨ë‘ì—ì„œ PIPEë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                    
            else:
                # ê¸°ìš¸ê¸°ê°€ 0ì´ ì•„ë‹Œ ê²½ìš°: PBOX ì  ê·¼ì²˜ë¥¼ ì§€ë‚˜ê°€ëŠ” PIPE ë ˆì´ì–´ í´ë¦¬ë¼ì¸ ì°¾ê¸°
                print("   ê¸°ìš¸ê¸° â‰  0: 3mm ë°˜ê²½ì—ì„œ ì„ ë¶„ì´ ì§€ë‚˜ê°€ëŠ” PIPE ë ˆì´ì–´ í´ë¦¬ë¼ì¸ ê²€ìƒ‰...")
                pipe_entities = self.find_pipe_layer_polylines_near_points(points, 3)
                
                if not pipe_entities:
                    print("   PIPE ë ˆì´ì–´ í´ë¦¬ë¼ì¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                    continue
                
                for entity in pipe_entities:
                    # ìƒˆ ë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ìƒì„±
                    if new_layer_name not in self.doc.layers:
                        self.doc.layers.new(name=new_layer_name)
                    
                    # ë ˆì´ì–´ ë³€ê²½
                    entity.dxf.layer = new_layer_name
                    print(f"   ë ˆì´ì–´ ë³€ê²½: PIPE â†’ {new_layer_name}")
        
        print("\nCROSCHK ì²˜ë¦¬ ì™„ë£Œ!")
        return True

# =============== í†µí•© ì²˜ë¦¬ í•¨ìˆ˜ ===============
def process_dxf_integrated(filepath: str):
    """PLTONEWLINEê³¼ CROSCHKë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰í•˜ëŠ” í†µí•© í•¨ìˆ˜"""
    print(f"\nğŸ“ í†µí•© ì²˜ë¦¬ ì‹œì‘: {Path(filepath).name}")
    
    # 1ë‹¨ê³„: PLTONEWLINE ì²˜ë¦¬
    print("\n[1ë‹¨ê³„] PLTONEWLINE ì²˜ë¦¬ ì¤‘...")
    doc = ezdxf.readfile(filepath)
    modifier = DxfModifier(filepath)
    c_keys, direct_ls = modifier.find_and_modify_green_lines(doc)
    msp = doc.modelspace()

    # 1. C_LINES ë¶„ë¥˜: width 0.6 -> ELBO or PIPE
    for dl in direct_ls:
        if not dl.width or abs(dl.width-0.6)>1e-3: continue
        pts = dl.points
        n = len(pts)
        
        # POLYLINEê³¼ LWPOLYLINE ëª¨ë‘ ì²˜ë¦¬í•˜ë„ë¡ ìˆ˜ì •
        for ent in msp:
            if ent.dxftype() not in ['POLYLINE', 'LWPOLYLINE']:
                continue
                
            # ê° íƒ€ì…ì— ë§ê²Œ ì¢Œí‘œ ì¶”ì¶œ
            if ent.dxftype() == 'POLYLINE':
                epts = [(v.dxf.location.x, v.dxf.location.y) for v in ent.vertices]
            else:  # LWPOLYLINE
                epts = [(pt[0], pt[1]) for pt in ent.get_points('xy')]
                
            # ì¢Œí‘œê°€ ì¼ì¹˜í•˜ëŠ” ì—”í‹°í‹°ë¥¼ ì°¾ì•„ì„œ ë ˆì´ì–´ ì„¤ì •
            if len(epts)==n and all(abs(epts[i][0]-pts[i][0])<1e-4 and abs(epts[i][1]-pts[i][1])<1e-4 for i in range(n)):
                # bulgeê°€ ìˆìœ¼ë©´ ELBO, ì—†ìœ¼ë©´ PIPE ë ˆì´ì–´ë¡œ ì„¤ì •
                ent.dxf.layer = 'ELBO' if has_bulge(ent) else 'PIPE'
                break

    # 2. PL ì²˜ë¦¬: ë‹¤ì–‘í•œ ì  ê°œìˆ˜ë³„ ë ˆì´ì–´ ë³€ê²½
    for ent in list(msp):
        if ent.dxftype() not in ['LWPOLYLINE','POLYLINE']: continue
        pts = polypoints(ent)
        n = len(pts)
        key = tuple((round(x,6),round(y,6)) for x,y in pts)
        if ent.dxftype()=='POLYLINE' and key in c_keys: continue
        if getattr(ent.dxf,'const_width',0)!=0: continue

        # 3ì  polyline (PL3)
        if n==3:
            if has_bulge(ent):
                r = get_bulge_radius(ent)
                if r and 2 <= r <= 3:
                    ent.dxf.layer = 'weldno'
                    ent.dxf.color = 2
                elif r and 5 <= r <= 8:
                    ent.dxf.layer = 'instno'
                    ent.dxf.color = 2
                else:
                    ent.dxf.layer = 'ARROW'
                    ent.dxf.color = 7
            else:
                if 1.9 <= distance(pts[0], pts[1]) <= 2.1:
                    ent.dxf.layer = 'ARROW'
                    ent.dxf.color = 7
            ent.dxf.layer = 'ARROW'

        # 4ì  polyline (PL4) - FALL ì¡°ê±´ ì¶”ê°€
        elif n==4:
            # ì ê°„ ê±°ë¦¬ ê³„ì‚° (ë§ˆì§€ë§‰ ì ì—ì„œ ì²« ì ìœ¼ë¡œì˜ ê±°ë¦¬ í¬í•¨)
            dists = all_pair_distances(pts)
            last_to_first = distance(pts[3], pts[0])
            
            # FALL íŒ¨í„´ í™•ì¸ (í—ˆìš© ì˜¤ì°¨ 0.1mm)
            tolerance = 0.1
            if (len(dists) >= 3 and
                abs(dists[0] - 7.445) <= tolerance and  # ì 1â†’ì 2
                abs(dists[1] - 1.612) <= tolerance and  # ì 2â†’ì 3
                abs(dists[2] - 7.592) <= tolerance and  # ì 3â†’ì 4
                abs(last_to_first - 0) <= tolerance):   # ì 4â†’ì 1
                ent.dxf.layer = 'FALL'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL4'
                ent.dxf.color = 7

        # 5ì  polyline (PL5)
        elif n==5:
            dists = all_pair_distances(pts)
            if all(d<=4.5 for d in dists):
                ent.dxf.layer = 'itemno'
            elif any(d>=30 for d in dists):
                ent.dxf.layer = 'spoolno'
            else:
                ent.dxf.layer = 'PL5'
            ent.dxf.color = 7

        # 6ì  polyline (PL6)
        elif n==6:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ëª¨ë“  ì ê°„ ê±°ë¦¬ì˜ í•©
            
            # ê¸¸ì´ê°’ í•©ê³„ ê¸°ì¤€ìœ¼ë¡œ ë ˆì´ì–´ ì§€ì •
            if 10 <= total_dist <= 11:
                ent.dxf.layer = 'SFW'
                ent.dxf.color = 2
            elif 17.5 <= total_dist <= 22:
                ent.dxf.layer = 'REDU'
                ent.dxf.color = 2
            elif 16 <= total_dist <= 16.5:
                ent.dxf.layer = 'REDU'
                ent.dxf.color = 2
            elif 17 <= total_dist <= 17.3:
                ent.dxf.layer = 'FLOW'
                ent.dxf.color = 2
            elif 12 <= total_dist <= 13.3:
                ent.dxf.layer = 'OLET'
                ent.dxf.color = 2
            elif any(d<=1.0 for d in dists):
                ent.dxf.layer = 'FLAN'
                ent.dxf.color = 2
            elif sum(1 for d in dists if 6<=d<=15)>=2:
                ent.dxf.layer = 'VALV'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL6'
                ent.dxf.color = 7

        elif n==7:
            dists = all_pair_distances(pts)
            mov_idx = [i for i,d in enumerate(dists) if 3<=d<=5]
            if len(mov_idx)>=2:
                ent.dxf.layer = 'MOV'
                ent.dxf.color = 2
            elif all(d<=2.2 for d in dists):
                ent.dxf.layer='weld'
                ent.dxf.color=2
            else:
                ent.dxf.layer = 'PL7'
                ent.dxf.color = 4

        elif n==8:
            dists = all_pair_distances(pts)
            if sum(1 for d in dists if 1.5<=d<=4)>=5:
                ent.dxf.layer = 'WOLET'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL8'
                ent.dxf.color = 7

        elif n==9:
            dists = all_pair_distances(pts)
            if all(d<=5 for d in dists):
                ent.dxf.layer = 'CV'
                ent.dxf.color = 2
            else:
                ent.dxf.layer = 'PL9'
                ent.dxf.color = 7

        elif n==10:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ëª¨ë“  ì ê°„ ê±°ë¦¬ì˜ í•©
            
            if 13.5 <= total_dist <= 14.5:
                ent.dxf.layer = 'CAP'
                ent.dxf.color = 2  # Yellow
            else:
                ent.dxf.layer = 'PL10'
                ent.dxf.color = 7

        elif n==12:
            dists = all_pair_distances(pts)
            total_dist = sum(dists)  # ëª¨ë“  ì ê°„ ê±°ë¦¬ì˜ í•©
            
            if 34 <= total_dist <= 35:
                ent.dxf.layer = 'SFW'
                ent.dxf.color = 2  # Yellow
            else:
                ent.dxf.layer = 'PL12'
                ent.dxf.color = 7

        elif n==2:
            ent.dxf.layer = 'PL2'
            ent.dxf.color = 7
    
    # 3. TEXT ë ˆì´ì–´ ì§€ì •
    for ent in msp.query('TEXT'):
        txt = ent.dxf.text.upper()
        if '<' in txt and '>' in txt:
            ent.dxf.layer = 'itemno'
        elif any(tag in txt for tag in ['EL+','EL-','FL+','FL-']):
            ent.dxf.layer = 'ELEV'
        elif any(letter in txt for letter in ['F','G']):
            ent.dxf.layer = 'FLAN'
        elif 'FALL' in txt:
            ent.dxf.layer = 'FALL'

    # 4. SP3, SP7 ì²˜ë¦¬ (ë ˆì´ì–´ë§Œ ì§€ì •)
    for ent in msp:
        if ent.dxftype() not in ['LWPOLYLINE','POLYLINE']: continue
        pts = polypoints(ent)
        n = len(pts)
        # ARROW ì„ ê¸‹ê¸° - ì¤‘ë³µ ì²´í¬ ì¶”ê°€
        if n==3:
            dists = all_pair_distances(pts)
            if all(1.5 <= d <= 2.3 for d in dists) and distance(pts[0], pts[2]) <= 1:
                # LINEì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                if not line_exists_between_points(msp, pts[2], pts[0]):
                    # ì›ë˜ ì‚¼ê°í˜• ì„¸ ë³€
                    line20 = msp.add_line(pts[2], pts[0], dxfattribs={'color': 7, 'layer': 'ARROW'})
                    print(f"ìƒˆ LINE ì¶”ê°€: {pts[2]} -> {pts[0]}")
                else:
                    print(f"LINE ì´ë¯¸ ì¡´ì¬: {pts[2]} -> {pts[0]} (SKIP)")
        elif n==7:
            dists = all_pair_distances(pts)
            if any(d>30 for d in dists):
                ent.dxf.layer = 'SUPP'

    # 5. PIPE ë ˆì´ì–´ ì²˜ë¦¬ (ì‚­ì œ X, color ë§Œ ì²˜ë¦¬)
    for ent in list(msp):
        if ent.dxftype() in ['LWPOLYLINE','POLYLINE'] and ent.dxf.layer=='PIPE':
            ent.dxf.color = 3

    # FALL ë ˆì´ì–´ì˜ 2ì  í´ë¦¬ë¼ì¸ ìƒ‰ìƒì„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½
    for ent in list(msp):
        if ent.dxftype() in ['LWPOLYLINE','POLYLINE'] and ent.dxf.layer=='FALL':
            pts = polypoints(ent)
            if len(pts) == 2:
                ent.dxf.color = 7  # í°ìƒ‰

    for txt in msp.query('TEXT'):
        txt.dxf.color = 2
        txt.dxf.style = "ARIAL"

    def set_width_by_f_x(msp):
        # 1. FABRICATION MATERIALS í…ìŠ¤íŠ¸ì˜ 'F' ë¬¸ì ìœ„ì¹˜(Xì¢Œí‘œ) ì°¾ê¸°
        f_x = None
        for txt in msp.query('TEXT'):
            if txt.dxf.text and txt.dxf.text.strip().upper().startswith('F'):
                f_x = txt.dxf.insert[0]
                break  # ì²« 'F'ë§Œ ì°¾ìœ¼ë©´ ë¨

        if f_x is None:
            print("FABRICATION MATERIALSì˜ F ìœ„ì¹˜ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
            return

        # 2. ì „ì²´ TEXTë¥¼ ëŒë©´ì„œ F ê¸°ì¤€ ì™¼ìª½/ì˜¤ë¥¸ìª½ì— width ì ìš©
        for txt in msp.query('TEXT'):
            if not txt.dxf.text:
                continue
            x = txt.dxf.insert[0]
            # í­ì€ ëª¨ë‘ floatìœ¼ë¡œ ë¹„êµ
            if x < f_x - 1e-4:  # Fì˜ Xë³´ë‹¤ ì™¼ìª½
                txt.dxf.width = 0.87
            else:  # F í¬í•¨ ì˜¤ë¥¸ìª½(í¬í•¨)
                txt.dxf.width = 0.8
            txt.dxf.style = "ARIAL"
            txt.dxf.color = 2

        if "ARIAL" not in doc.styles:
            doc.styles.new("ARIAL", dxfattribs={"font": "arial.ttf"})
    
    set_width_by_f_x(msp)
    
    print("âœ… PLTONEWLINE ì²˜ë¦¬ ì™„ë£Œ")
    
    # 2ë‹¨ê³„: CROSCHK ì²˜ë¦¬
    print("\n[2ë‹¨ê³„] CROSCHK ì²˜ë¦¬ ì¤‘...")
    pipe_renamer = PipeLayerRenamer()
    croschk_success = pipe_renamer.process_croschk(doc, msp)
    
    if croschk_success:
        print("âœ… CROSCHK ì²˜ë¦¬ ì™„ë£Œ")
    else:
        print("âŒ CROSCHK ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ")
    
    # íŒŒì¼ ì €ì¥
    outname = Path(filepath).with_stem(Path(filepath).stem + '_Integrated')
    doc.saveas(str(outname))
    print(f"\nâœ… í†µí•© ì²˜ë¦¬ ì™„ë£Œ! ì €ì¥: {outname}")
    
    return str(outname)

def select_files_and_process():
    root = tk.Tk()
    root.withdraw()
    files = filedialog.askopenfilenames(filetypes=[('DXF files','*.dxf')])
    for f in files:
        process_dxf_integrated(f)

if __name__ == '__main__':
    select_files_and_process()